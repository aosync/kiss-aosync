diff -u a/dbus/bus.cc b/dbus/bus.cc
--- a/dbus/bus.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/bus.cc	2020-06-09 20:12:39.135339564 +0200
@@ -49,50 +49,29 @@
 // communication.
 class Watch {
  public:
-  explicit Watch(DBusWatch* watch) : raw_watch_(watch) {
-    dbus_watch_set_data(raw_watch_, this, nullptr);
+  explicit Watch(const void* watch) : raw_watch_(watch) { // Warning
   }
 
-  ~Watch() { dbus_watch_set_data(raw_watch_, nullptr, nullptr); }
+  ~Watch() {  }
 
   // Returns true if the underlying file descriptor is ready to be watched.
   bool IsReadyToBeWatched() {
-    return dbus_watch_get_enabled(raw_watch_);
+    return false;
   }
 
   // Starts watching the underlying file descriptor.
   void StartWatching() {
-    const int file_descriptor = dbus_watch_get_unix_fd(raw_watch_);
-    const unsigned int flags = dbus_watch_get_flags(raw_watch_);
-
-    // Using base::Unretained(this) is safe because watches are automatically
-    // canceled when |read_watcher_| and |write_watcher_| are destroyed.
-    if (flags & DBUS_WATCH_READABLE) {
-      read_watcher_ = base::FileDescriptorWatcher::WatchReadable(
-          file_descriptor,
-          base::BindRepeating(&Watch::OnFileReady, base::Unretained(this),
-                              DBUS_WATCH_READABLE));
-    }
-    if (flags & DBUS_WATCH_WRITABLE) {
-      write_watcher_ = base::FileDescriptorWatcher::WatchWritable(
-          file_descriptor,
-          base::BindRepeating(&Watch::OnFileReady, base::Unretained(this),
-                              DBUS_WATCH_WRITABLE));
-    }
   }
 
   // Stops watching the underlying file descriptor.
   void StopWatching() {
-    read_watcher_.reset();
-    write_watcher_.reset();
   }
 
  private:
   void OnFileReady(unsigned int flags) {
-    CHECK(dbus_watch_handle(raw_watch_, flags)) << "Unable to allocate memory";
   }
 
-  DBusWatch* raw_watch_;
+  void* raw_watch_;
   std::unique_ptr<base::FileDescriptorWatcher::Controller> read_watcher_;
   std::unique_ptr<base::FileDescriptorWatcher::Controller> write_watcher_;
 
@@ -103,42 +82,33 @@
 // calls.
 class Timeout {
  public:
-  explicit Timeout(DBusTimeout* timeout) : raw_timeout_(timeout) {
-    // Associated |this| with the underlying DBusTimeout.
-    dbus_timeout_set_data(raw_timeout_, this, nullptr);
+  explicit Timeout(const void* timeout) : raw_timeout_(timeout) {
   }
 
   ~Timeout() {
-    // Remove the association between |this| and the |raw_timeout_|.
-    dbus_timeout_set_data(raw_timeout_, nullptr, nullptr);
   }
 
   // Returns true if the timeout is ready to be monitored.
   bool IsReadyToBeMonitored() {
-    return dbus_timeout_get_enabled(raw_timeout_);
+    return false;
   }
 
   // Starts monitoring the timeout.
   void StartMonitoring(Bus* bus) {
-    bus->GetDBusTaskRunner()->PostDelayedTask(
-        FROM_HERE,
-        base::BindOnce(&Timeout::HandleTimeout, weak_ptr_factory_.GetWeakPtr()),
-        GetInterval());
   }
 
   // Stops monitoring the timeout.
-  void StopMonitoring() { weak_ptr_factory_.InvalidateWeakPtrs(); }
+  void StopMonitoring() { }
 
   base::TimeDelta GetInterval() {
-    return base::TimeDelta::FromMilliseconds(
-        dbus_timeout_get_interval(raw_timeout_));
+    return base::TimeDelta::FromMilliseconds(1000);
   }
 
  private:
   // Calls DBus to handle the timeout.
-  void HandleTimeout() { CHECK(dbus_timeout_handle(raw_timeout_)); }
+  void HandleTimeout() { }
 
-  DBusTimeout* raw_timeout_;
+  void* raw_timeout_;
 
   base::WeakPtrFactory<Timeout> weak_ptr_factory_{this};
 
@@ -167,1075 +137,247 @@
       num_pending_watches_(0),
       num_pending_timeouts_(0),
       address_(options.address) {
-  // This is safe to call multiple times.
-  dbus_threads_init_default();
-  // The origin message loop is unnecessary if the client uses synchronous
-  // functions only.
-  if (base::SequencedTaskRunnerHandle::IsSet())
-    origin_task_runner_ = base::SequencedTaskRunnerHandle::Get();
 }
 
 Bus::~Bus() {
-  DCHECK(!connection_);
-  DCHECK(owned_service_names_.empty());
-  DCHECK(match_rules_added_.empty());
-  DCHECK(filter_functions_added_.empty());
-  DCHECK(registered_object_paths_.empty());
-  DCHECK_EQ(0, num_pending_watches_);
-  // TODO(satorux): This check fails occasionally in browser_tests for tests
-  // that run very quickly. Perhaps something does not have time to clean up.
-  // Despite the check failing, the tests seem to run fine. crosbug.com/23416
-  // DCHECK_EQ(0, num_pending_timeouts_);
 }
 
 ObjectProxy* Bus::GetObjectProxy(const std::string& service_name,
                                  const ObjectPath& object_path) {
-  return GetObjectProxyWithOptions(service_name, object_path,
-                                   ObjectProxy::DEFAULT_OPTIONS);
+  return nullptr;
 }
 
 ObjectProxy* Bus::GetObjectProxyWithOptions(const std::string& service_name,
                                             const ObjectPath& object_path,
                                             int options) {
-  AssertOnOriginThread();
-
-  // Check if we already have the requested object proxy.
-  const ObjectProxyTable::key_type key(service_name + object_path.value(),
-                                       options);
-  ObjectProxyTable::iterator iter = object_proxy_table_.find(key);
-  if (iter != object_proxy_table_.end()) {
-    return iter->second.get();
-  }
-
-  scoped_refptr<ObjectProxy> object_proxy =
-      new ObjectProxy(this, service_name, object_path, options);
-  object_proxy_table_[key] = object_proxy;
-
-  return object_proxy.get();
+  return nullptr;
 }
 
 bool Bus::RemoveObjectProxy(const std::string& service_name,
                             const ObjectPath& object_path,
                             base::OnceClosure callback) {
-  return RemoveObjectProxyWithOptions(service_name, object_path,
-                                      ObjectProxy::DEFAULT_OPTIONS,
-                                      std::move(callback));
+  return true;
 }
 
 bool Bus::RemoveObjectProxyWithOptions(const std::string& service_name,
                                        const ObjectPath& object_path,
                                        int options,
                                        base::OnceClosure callback) {
-  AssertOnOriginThread();
-
-  // Check if we have the requested object proxy.
-  const ObjectProxyTable::key_type key(service_name + object_path.value(),
-                                       options);
-  ObjectProxyTable::iterator iter = object_proxy_table_.find(key);
-  if (iter != object_proxy_table_.end()) {
-    scoped_refptr<ObjectProxy> object_proxy = iter->second;
-    object_proxy_table_.erase(iter);
-    // Object is present. Remove it now and Detach on the DBus thread.
-    GetDBusTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&Bus::RemoveObjectProxyInternal, this,
-                                  object_proxy, std::move(callback)));
-    return true;
-  }
-  return false;
+  return true;
 }
 
 void Bus::RemoveObjectProxyInternal(scoped_refptr<ObjectProxy> object_proxy,
                                     base::OnceClosure callback) {
-  AssertOnDBusThread();
-
-  object_proxy->Detach();
-
-  GetOriginTaskRunner()->PostTask(FROM_HERE, std::move(callback));
 }
 
 ExportedObject* Bus::GetExportedObject(const ObjectPath& object_path) {
-  AssertOnOriginThread();
-
-  // Check if we already have the requested exported object.
-  ExportedObjectTable::iterator iter = exported_object_table_.find(object_path);
-  if (iter != exported_object_table_.end()) {
-    return iter->second.get();
-  }
-
-  scoped_refptr<ExportedObject> exported_object =
-      new ExportedObject(this, object_path);
-  exported_object_table_[object_path] = exported_object;
-
-  return exported_object.get();
+  return nullptr;
 }
 
 void Bus::UnregisterExportedObject(const ObjectPath& object_path) {
-  AssertOnOriginThread();
-
-  // Remove the registered object from the table first, to allow a new
-  // GetExportedObject() call to return a new object, rather than this one.
-  ExportedObjectTable::iterator iter = exported_object_table_.find(object_path);
-  if (iter == exported_object_table_.end())
-    return;
-
-  scoped_refptr<ExportedObject> exported_object = iter->second;
-  exported_object_table_.erase(iter);
-
-  // Post the task to perform the final unregistration to the D-Bus thread.
-  // Since the registration also happens on the D-Bus thread in
-  // TryRegisterObjectPath(), and the task runner we post to is a
-  // SequencedTaskRunner, there is a guarantee that this will happen before any
-  // future registration call.
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::UnregisterExportedObjectInternal, this,
-                                exported_object));
 }
 
 void Bus::UnregisterExportedObjectInternal(
     scoped_refptr<ExportedObject> exported_object) {
-  AssertOnDBusThread();
-
-  exported_object->Unregister();
 }
 
 ObjectManager* Bus::GetObjectManager(const std::string& service_name,
                                      const ObjectPath& object_path) {
-  AssertOnOriginThread();
-
-  // Check if we already have the requested object manager.
-  const ObjectManagerTable::key_type key(service_name + object_path.value());
-  ObjectManagerTable::iterator iter = object_manager_table_.find(key);
-  if (iter != object_manager_table_.end()) {
-    return iter->second.get();
-  }
-
-  scoped_refptr<ObjectManager> object_manager =
-      ObjectManager::Create(this, service_name, object_path);
-  object_manager_table_[key] = object_manager;
-
-  return object_manager.get();
+  return nullptr;
 }
 
 bool Bus::RemoveObjectManager(const std::string& service_name,
                               const ObjectPath& object_path,
                               base::OnceClosure callback) {
-  AssertOnOriginThread();
-  DCHECK(!callback.is_null());
-
-  const ObjectManagerTable::key_type key(service_name + object_path.value());
-  ObjectManagerTable::iterator iter = object_manager_table_.find(key);
-  if (iter == object_manager_table_.end())
-    return false;
-
-  // ObjectManager is present. Remove it now and CleanUp on the DBus thread.
-  scoped_refptr<ObjectManager> object_manager = iter->second;
-  object_manager_table_.erase(iter);
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::RemoveObjectManagerInternal, this,
-                                object_manager, std::move(callback)));
-
   return true;
 }
 
 void Bus::RemoveObjectManagerInternal(
     scoped_refptr<dbus::ObjectManager> object_manager,
     base::OnceClosure callback) {
-  AssertOnDBusThread();
-  DCHECK(object_manager.get());
-
-  object_manager->CleanUp();
-
-  // The ObjectManager has to be deleted on the origin thread since it was
-  // created there.
-  GetOriginTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::RemoveObjectManagerInternalHelper, this,
-                                object_manager, std::move(callback)));
 }
 
 void Bus::RemoveObjectManagerInternalHelper(
     scoped_refptr<dbus::ObjectManager> object_manager,
     base::OnceClosure callback) {
-  AssertOnOriginThread();
-  DCHECK(object_manager);
-
-  // Release the object manager and run the callback.
-  object_manager = nullptr;
-  std::move(callback).Run();
 }
 
 bool Bus::Connect() {
-  // dbus_bus_get_private() and dbus_bus_get() are blocking calls.
-  AssertOnDBusThread();
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  // Check if it's already initialized.
-  if (connection_)
-    return true;
-
-  ScopedDBusError error;
-  if (bus_type_ == CUSTOM_ADDRESS) {
-    if (connection_type_ == PRIVATE) {
-      connection_ = dbus_connection_open_private(address_.c_str(), error.get());
-    } else {
-      connection_ = dbus_connection_open(address_.c_str(), error.get());
-    }
-  } else {
-    const DBusBusType dbus_bus_type = static_cast<DBusBusType>(bus_type_);
-    if (connection_type_ == PRIVATE) {
-      connection_ = dbus_bus_get_private(dbus_bus_type, error.get());
-    } else {
-      connection_ = dbus_bus_get(dbus_bus_type, error.get());
-    }
-  }
-  if (!connection_) {
-    LOG(ERROR) << "Failed to connect to the bus: "
-               << (error.is_set() ? error.message() : "");
-    return false;
-  }
-
-  if (bus_type_ == CUSTOM_ADDRESS) {
-    // We should call dbus_bus_register here, otherwise unique name can not be
-    // acquired. According to dbus specification, it is responsible to call
-    // org.freedesktop.DBus.Hello method at the beging of bus connection to
-    // acquire unique name. In the case of dbus_bus_get, dbus_bus_register is
-    // called internally.
-    if (!dbus_bus_register(connection_, error.get())) {
-      LOG(ERROR) << "Failed to register the bus component: "
-                 << (error.is_set() ? error.message() : "");
-      return false;
-    }
-  }
-  // We shouldn't exit on the disconnected signal.
-  dbus_connection_set_exit_on_disconnect(connection_, false);
-
-  // Watch Disconnected signal.
-  AddFilterFunction(Bus::OnConnectionDisconnectedFilter, this);
-  AddMatch(kDisconnectedMatchRule, error.get());
-
   return true;
 }
 
 void Bus::ClosePrivateConnection() {
-  // dbus_connection_close is blocking call.
-  AssertOnDBusThread();
-  DCHECK_EQ(PRIVATE, connection_type_)
-      << "non-private connection should not be closed";
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  dbus_connection_close(connection_);
 }
 
 void Bus::ShutdownAndBlock() {
-  AssertOnDBusThread();
-
-  if (shutdown_completed_)
-    return;  // Already shutdowned, just return.
-
-  // Unregister the exported objects.
-  for (ExportedObjectTable::iterator iter = exported_object_table_.begin();
-       iter != exported_object_table_.end(); ++iter) {
-    iter->second->Unregister();
-  }
-
-  // Release all service names.
-  for (std::set<std::string>::iterator iter = owned_service_names_.begin();
-       iter != owned_service_names_.end();) {
-    // This is a bit tricky but we should increment the iter here as
-    // ReleaseOwnership() may remove |service_name| from the set.
-    const std::string& service_name = *iter++;
-    ReleaseOwnership(service_name);
-  }
-  if (!owned_service_names_.empty()) {
-    LOG(ERROR) << "Failed to release all service names. # of services left: "
-               << owned_service_names_.size();
-  }
-
-  // Detach from the remote objects.
-  for (ObjectProxyTable::iterator iter = object_proxy_table_.begin();
-       iter != object_proxy_table_.end(); ++iter) {
-    iter->second->Detach();
-  }
-
-  // Clean up the object managers.
-  for (ObjectManagerTable::iterator iter = object_manager_table_.begin();
-       iter != object_manager_table_.end(); ++iter) {
-    iter->second->CleanUp();
-  }
-
-  // Release object proxies and exported objects here. We should do this
-  // here rather than in the destructor to avoid memory leaks due to
-  // cyclic references.
-  object_proxy_table_.clear();
-  exported_object_table_.clear();
-
-  // Private connection should be closed.
-  if (connection_) {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-
-    // Remove Disconnected watcher.
-    ScopedDBusError error;
-    RemoveFilterFunction(Bus::OnConnectionDisconnectedFilter, this);
-    RemoveMatch(kDisconnectedMatchRule, error.get());
-
-    if (connection_type_ == PRIVATE)
-      ClosePrivateConnection();
-    // dbus_connection_close() won't unref.
-    dbus_connection_unref(connection_);
-  }
-
-  connection_ = nullptr;
-  shutdown_completed_ = true;
 }
 
 void Bus::ShutdownOnDBusThreadAndBlock() {
-  AssertOnOriginThread();
-  DCHECK(dbus_task_runner_);
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&Bus::ShutdownOnDBusThreadAndBlockInternal, this));
-
-  // http://crbug.com/125222
-  base::ScopedAllowBaseSyncPrimitivesOutsideBlockingScope allow_wait;
-
-  // Wait until the shutdown is complete on the D-Bus thread.
-  // The shutdown should not hang, but set timeout just in case.
-  const int kTimeoutSecs = 3;
-  const base::TimeDelta timeout(base::TimeDelta::FromSeconds(kTimeoutSecs));
-  const bool signaled = on_shutdown_.TimedWait(timeout);
-  LOG_IF(ERROR, !signaled) << "Failed to shutdown the bus";
 }
 
 void Bus::RequestOwnership(const std::string& service_name,
                            ServiceOwnershipOptions options,
                            OnOwnershipCallback on_ownership_callback) {
-  AssertOnOriginThread();
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&Bus::RequestOwnershipInternal, this, service_name,
-                     options, std::move(on_ownership_callback)));
 }
 
 void Bus::RequestOwnershipInternal(const std::string& service_name,
                                    ServiceOwnershipOptions options,
                                    OnOwnershipCallback on_ownership_callback) {
-  AssertOnDBusThread();
-
-  bool success = Connect();
-  if (success)
-    success = RequestOwnershipAndBlock(service_name, options);
-
-  GetOriginTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(on_ownership_callback), service_name, success));
 }
 
 bool Bus::RequestOwnershipAndBlock(const std::string& service_name,
                                    ServiceOwnershipOptions options) {
-  DCHECK(connection_);
-  // dbus_bus_request_name() is a blocking call.
-  AssertOnDBusThread();
-
-  // Check if we already own the service name.
-  if (owned_service_names_.find(service_name) != owned_service_names_.end()) {
-    return true;
-  }
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  ScopedDBusError error;
-  const int result = dbus_bus_request_name(connection_,
-                                           service_name.c_str(),
-                                           options,
-                                           error.get());
-  if (result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) {
-    LOG(ERROR) << "Failed to get the ownership of " << service_name << ": "
-               << (error.is_set() ? error.message() : "");
-    return false;
-  }
-  owned_service_names_.insert(service_name);
   return true;
 }
 
 bool Bus::ReleaseOwnership(const std::string& service_name) {
-  DCHECK(connection_);
-  // dbus_bus_release_name() is a blocking call.
-  AssertOnDBusThread();
-
-  // Check if we already own the service name.
-  std::set<std::string>::iterator found =
-      owned_service_names_.find(service_name);
-  if (found == owned_service_names_.end()) {
-    LOG(ERROR) << service_name << " is not owned by the bus";
-    return false;
-  }
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  ScopedDBusError error;
-  const int result = dbus_bus_release_name(connection_, service_name.c_str(),
-                                           error.get());
-  if (result == DBUS_RELEASE_NAME_REPLY_RELEASED) {
-    owned_service_names_.erase(found);
-    return true;
-  } else {
-    LOG(ERROR) << "Failed to release the ownership of " << service_name << ": "
-               << (error.is_set() ? error.message() : "")
-               << ", result code: " << result;
-    return false;
-  }
+  return true;
 }
 
 bool Bus::SetUpAsyncOperations() {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  if (async_operations_set_up_)
-    return true;
-
-  // Process all the incoming data if any, so that OnDispatchStatus() will
-  // be called when the incoming data is ready.
-  ProcessAllIncomingDataIfAny();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  bool success = dbus_connection_set_watch_functions(
-      connection_, &Bus::OnAddWatchThunk, &Bus::OnRemoveWatchThunk,
-      &Bus::OnToggleWatchThunk, this, nullptr);
-  CHECK(success) << "Unable to allocate memory";
-
-  success = dbus_connection_set_timeout_functions(
-      connection_, &Bus::OnAddTimeoutThunk, &Bus::OnRemoveTimeoutThunk,
-      &Bus::OnToggleTimeoutThunk, this, nullptr);
-  CHECK(success) << "Unable to allocate memory";
-
-  dbus_connection_set_dispatch_status_function(
-      connection_, &Bus::OnDispatchStatusChangedThunk, this, nullptr);
-
-  async_operations_set_up_ = true;
-
   return true;
 }
 
-DBusMessage* Bus::SendWithReplyAndBlock(DBusMessage* request,
+void* Bus::SendWithReplyAndBlock(const void* request,
                                         int timeout_ms,
-                                        DBusError* error) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  base::ElapsedTimer elapsed;
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  DBusMessage* reply = dbus_connection_send_with_reply_and_block(
-      connection_, request, timeout_ms, error);
-
-  constexpr base::TimeDelta kLongCall = base::TimeDelta::FromSeconds(1);
-  LOG_IF(WARNING, elapsed.Elapsed() >= kLongCall)
-      << "Bus::SendWithReplyAndBlock took "
-      << elapsed.Elapsed().InMilliseconds() << "ms to process message: "
-      << "type=" << dbus_message_type_to_string(dbus_message_get_type(request))
-      << ", path=" << dbus_message_get_path(request)
-      << ", interface=" << dbus_message_get_interface(request)
-      << ", member=" << dbus_message_get_member(request);
-
-  return reply;
+                                        const void* error) {
+  return nullptr;
 }
 
-void Bus::SendWithReply(DBusMessage* request,
-                        DBusPendingCall** pending_call,
+void Bus::SendWithReply(const void* request,
+                        const void** pending_call,
                         int timeout_ms) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  const bool success = dbus_connection_send_with_reply(
-      connection_, request, pending_call, timeout_ms);
-  CHECK(success) << "Unable to allocate memory";
-}
-
-void Bus::Send(DBusMessage* request, uint32_t* serial) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  const bool success = dbus_connection_send(connection_, request, serial);
-  CHECK(success) << "Unable to allocate memory";
-}
-
-void Bus::AddFilterFunction(DBusHandleMessageFunction filter_function,
-                            void* user_data) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  std::pair<DBusHandleMessageFunction, void*> filter_data_pair =
-      std::make_pair(filter_function, user_data);
-  if (filter_functions_added_.find(filter_data_pair) !=
-      filter_functions_added_.end()) {
-    VLOG(1) << "Filter function already exists: " << filter_function
-            << " with associated data: " << user_data;
-    return;
-  }
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  const bool success = dbus_connection_add_filter(connection_, filter_function,
-                                                  user_data, nullptr);
-  CHECK(success) << "Unable to allocate memory";
-  filter_functions_added_.insert(filter_data_pair);
-}
-
-void Bus::RemoveFilterFunction(DBusHandleMessageFunction filter_function,
-                               void* user_data) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  std::pair<DBusHandleMessageFunction, void*> filter_data_pair =
-      std::make_pair(filter_function, user_data);
-  if (filter_functions_added_.find(filter_data_pair) ==
-      filter_functions_added_.end()) {
-    VLOG(1) << "Requested to remove an unknown filter function: "
-            << filter_function
-            << " with associated data: " << user_data;
-    return;
-  }
+}
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  dbus_connection_remove_filter(connection_, filter_function, user_data);
-  filter_functions_added_.erase(filter_data_pair);
-}
-
-void Bus::AddMatch(const std::string& match_rule, DBusError* error) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  std::map<std::string, int>::iterator iter =
-      match_rules_added_.find(match_rule);
-  if (iter != match_rules_added_.end()) {
-    // The already existing rule's counter is incremented.
-    iter->second++;
+void Bus::Send(const void* request, uint32_t* serial) {
+}
 
-    VLOG(1) << "Match rule already exists: " << match_rule;
-    return;
-  }
 
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  dbus_bus_add_match(connection_, match_rule.c_str(), error);
-  match_rules_added_[match_rule] = 1;
+void Bus::AddMatch(const std::string& match_rule, const void* error) {
 }
 
-bool Bus::RemoveMatch(const std::string& match_rule, DBusError* error) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  std::map<std::string, int>::iterator iter =
-      match_rules_added_.find(match_rule);
-  if (iter == match_rules_added_.end()) {
-    LOG(ERROR) << "Requested to remove an unknown match rule: " << match_rule;
-    return false;
-  }
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  // The rule's counter is decremented and the rule is deleted when reachs 0.
-  iter->second--;
-  if (iter->second == 0) {
-    dbus_bus_remove_match(connection_, match_rule.c_str(), error);
-    match_rules_added_.erase(match_rule);
-  }
+bool Bus::RemoveMatch(const std::string& match_rule, const void* error) {
   return true;
 }
 
 bool Bus::TryRegisterObjectPath(const ObjectPath& object_path,
-                                const DBusObjectPathVTable* vtable,
+                                const void* vtable,
                                 void* user_data,
-                                DBusError* error) {
-  return TryRegisterObjectPathInternal(
-      object_path, vtable, user_data, error,
-      dbus_connection_try_register_object_path);
+                                const void* error) {
+  return true;
 }
 
 bool Bus::TryRegisterFallback(const ObjectPath& object_path,
-                              const DBusObjectPathVTable* vtable,
+                              const const void* vtable,
                               void* user_data,
-                              DBusError* error) {
-  return TryRegisterObjectPathInternal(object_path, vtable, user_data, error,
-                                       dbus_connection_try_register_fallback);
+                              const void* error) {
+  return true;
 }
 
 bool Bus::TryRegisterObjectPathInternal(
     const ObjectPath& object_path,
-    const DBusObjectPathVTable* vtable,
+    const const void* vtable,
     void* user_data,
-    DBusError* error,
+    const void* error,
     TryRegisterObjectPathFunction* register_function) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  if (registered_object_paths_.find(object_path) !=
-      registered_object_paths_.end()) {
-    LOG(ERROR) << "Object path already registered: " << object_path.value();
-    return false;
-  }
-
-  const bool success = register_function(
-      connection_, object_path.value().c_str(), vtable, user_data, error);
-  if (success)
-    registered_object_paths_.insert(object_path);
-  return success;
+  return true;
 }
 
 void Bus::UnregisterObjectPath(const ObjectPath& object_path) {
-  DCHECK(connection_);
-  AssertOnDBusThread();
-
-  if (registered_object_paths_.find(object_path) ==
-      registered_object_paths_.end()) {
-    LOG(ERROR) << "Requested to unregister an unknown object path: "
-               << object_path.value();
-    return;
-  }
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  const bool success = dbus_connection_unregister_object_path(
-      connection_,
-      object_path.value().c_str());
-  CHECK(success) << "Unable to allocate memory";
-  registered_object_paths_.erase(object_path);
 }
 
 void Bus::ShutdownOnDBusThreadAndBlockInternal() {
-  AssertOnDBusThread();
-
-  ShutdownAndBlock();
-  on_shutdown_.Signal();
-}
-
-void Bus::ProcessAllIncomingDataIfAny() {
-  AssertOnDBusThread();
-
-  // As mentioned at the class comment in .h file, connection_ can be NULL.
-  if (!connection_)
-    return;
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  // It is safe and necessary to call dbus_connection_get_dispatch_status even
-  // if the connection is lost.
-  if (dbus_connection_get_dispatch_status(connection_) ==
-      DBUS_DISPATCH_DATA_REMAINS) {
-    while (dbus_connection_dispatch(connection_) ==
-           DBUS_DISPATCH_DATA_REMAINS) {
-    }
-  }
 }
 
 base::SequencedTaskRunner* Bus::GetDBusTaskRunner() {
-  if (dbus_task_runner_)
-    return dbus_task_runner_.get();
-  else
-    return GetOriginTaskRunner();
+  return nullptr;
 }
 
 base::SequencedTaskRunner* Bus::GetOriginTaskRunner() {
-  DCHECK(origin_task_runner_);
-  return origin_task_runner_.get();
+  return nullptr;
 }
 
 bool Bus::HasDBusThread() {
-  return dbus_task_runner_ != nullptr;
+  return false;
 }
 
 void Bus::AssertOnOriginThread() {
-  if (origin_task_runner_) {
-    CHECK(origin_task_runner_->RunsTasksInCurrentSequence());
-  } else {
-    CHECK_EQ(origin_thread_id_, base::PlatformThread::CurrentId());
-  }
 }
 
 void Bus::AssertOnDBusThread() {
-  if (dbus_task_runner_) {
-    CHECK(dbus_task_runner_->RunsTasksInCurrentSequence());
-  } else {
-    AssertOnOriginThread();
-  }
 }
 
 std::string Bus::GetServiceOwnerAndBlock(const std::string& service_name,
                                          GetServiceOwnerOption options) {
-  AssertOnDBusThread();
-
-  MethodCall get_name_owner_call("org.freedesktop.DBus", "GetNameOwner");
-  MessageWriter writer(&get_name_owner_call);
-  writer.AppendString(service_name);
-  VLOG(1) << "Method call: " << get_name_owner_call.ToString();
-
-  const ObjectPath obj_path("/org/freedesktop/DBus");
-  if (!get_name_owner_call.SetDestination("org.freedesktop.DBus") ||
-      !get_name_owner_call.SetPath(obj_path)) {
-    if (options == REPORT_ERRORS)
-      LOG(ERROR) << "Failed to get name owner.";
-    return "";
-  }
-
-  ScopedDBusError error;
-  DBusMessage* response_message =
-      SendWithReplyAndBlock(get_name_owner_call.raw_message(),
-                            ObjectProxy::TIMEOUT_USE_DEFAULT,
-                            error.get());
-  if (!response_message) {
-    if (options == REPORT_ERRORS) {
-      LOG(ERROR) << "Failed to get name owner. Got " << error.name() << ": "
-                 << error.message();
-    }
-    return "";
-  }
-
-  std::unique_ptr<Response> response(
-      Response::FromRawMessage(response_message));
-  MessageReader reader(response.get());
-
-  std::string service_owner;
-  if (!reader.PopString(&service_owner))
-    service_owner.clear();
-  return service_owner;
+  return "";
 }
 
 void Bus::GetServiceOwner(const std::string& service_name,
                           GetServiceOwnerCallback callback) {
-  AssertOnOriginThread();
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::GetServiceOwnerInternal, this,
-                                service_name, std::move(callback)));
 }
 
 void Bus::GetServiceOwnerInternal(const std::string& service_name,
                                   GetServiceOwnerCallback callback) {
-  AssertOnDBusThread();
-
-  std::string service_owner;
-  if (Connect())
-    service_owner = GetServiceOwnerAndBlock(service_name, SUPPRESS_ERRORS);
-  GetOriginTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(std::move(callback), service_owner));
 }
 
 void Bus::ListenForServiceOwnerChange(
     const std::string& service_name,
     const ServiceOwnerChangeCallback& callback) {
-  AssertOnOriginThread();
-  DCHECK(!service_name.empty());
-  DCHECK(!callback.is_null());
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::ListenForServiceOwnerChangeInternal, this,
-                                service_name, callback));
 }
 
 void Bus::ListenForServiceOwnerChangeInternal(
     const std::string& service_name,
     const ServiceOwnerChangeCallback& callback) {
-  AssertOnDBusThread();
-  DCHECK(!service_name.empty());
-  DCHECK(!callback.is_null());
-
-  if (!Connect() || !SetUpAsyncOperations())
-    return;
-
-  if (service_owner_changed_listener_map_.empty())
-    AddFilterFunction(Bus::OnServiceOwnerChangedFilter, this);
-
-  ServiceOwnerChangedListenerMap::iterator it =
-      service_owner_changed_listener_map_.find(service_name);
-  if (it == service_owner_changed_listener_map_.end()) {
-    // Add a match rule for the new service name.
-    const std::string name_owner_changed_match_rule =
-        base::StringPrintf(kServiceNameOwnerChangeMatchRule,
-                           service_name.c_str());
-    ScopedDBusError error;
-    AddMatch(name_owner_changed_match_rule, error.get());
-    if (error.is_set()) {
-      LOG(ERROR) << "Failed to add match rule for " << service_name
-                 << ". Got " << error.name() << ": " << error.message();
-      return;
-    }
-
-    service_owner_changed_listener_map_[service_name].push_back(callback);
-    return;
-  }
-
-  // Check if the callback has already been added.
-  std::vector<ServiceOwnerChangeCallback>& callbacks = it->second;
-  for (size_t i = 0; i < callbacks.size(); ++i) {
-    if (callbacks[i] == callback)
-      return;
-  }
-  callbacks.push_back(callback);
 }
 
 void Bus::UnlistenForServiceOwnerChange(
     const std::string& service_name,
     const ServiceOwnerChangeCallback& callback) {
-  AssertOnOriginThread();
-  DCHECK(!service_name.empty());
-  DCHECK(!callback.is_null());
-
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::UnlistenForServiceOwnerChangeInternal,
-                                this, service_name, callback));
 }
 
 void Bus::UnlistenForServiceOwnerChangeInternal(
     const std::string& service_name,
     const ServiceOwnerChangeCallback& callback) {
-  AssertOnDBusThread();
-  DCHECK(!service_name.empty());
-  DCHECK(!callback.is_null());
-
-  ServiceOwnerChangedListenerMap::iterator it =
-      service_owner_changed_listener_map_.find(service_name);
-  if (it == service_owner_changed_listener_map_.end())
-    return;
-
-  std::vector<ServiceOwnerChangeCallback>& callbacks = it->second;
-  for (size_t i = 0; i < callbacks.size(); ++i) {
-    if (callbacks[i] == callback) {
-      callbacks.erase(callbacks.begin() + i);
-      break;  // There can be only one.
-    }
-  }
-  if (!callbacks.empty())
-    return;
-
-  // Last callback for |service_name| has been removed, remove match rule.
-  const std::string name_owner_changed_match_rule =
-      base::StringPrintf(kServiceNameOwnerChangeMatchRule,
-                         service_name.c_str());
-  ScopedDBusError error;
-  RemoveMatch(name_owner_changed_match_rule, error.get());
-  // And remove |service_owner_changed_listener_map_| entry.
-  service_owner_changed_listener_map_.erase(it);
-
-  if (service_owner_changed_listener_map_.empty())
-    RemoveFilterFunction(Bus::OnServiceOwnerChangedFilter, this);
 }
 
 std::string Bus::GetConnectionName() {
-  if (!connection_)
-    return "";
-  return dbus_bus_get_unique_name(connection_);
+  return "";
 }
 
 bool Bus::IsConnected() {
-  return connection_ != nullptr;
-}
-
-dbus_bool_t Bus::OnAddWatch(DBusWatch* raw_watch) {
-  AssertOnDBusThread();
-
-  // watch will be deleted when raw_watch is removed in OnRemoveWatch().
-  Watch* watch = new Watch(raw_watch);
-  if (watch->IsReadyToBeWatched()) {
-    watch->StartWatching();
-  }
-  ++num_pending_watches_;
   return true;
 }
 
-void Bus::OnRemoveWatch(DBusWatch* raw_watch) {
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  Watch* watch = static_cast<Watch*>(dbus_watch_get_data(raw_watch));
-  delete watch;
-  --num_pending_watches_;
-}
-
-void Bus::OnToggleWatch(DBusWatch* raw_watch) {
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  Watch* watch = static_cast<Watch*>(dbus_watch_get_data(raw_watch));
-  if (watch->IsReadyToBeWatched())
-    watch->StartWatching();
-  else
-    watch->StopWatching();
-}
-
-dbus_bool_t Bus::OnAddTimeout(DBusTimeout* raw_timeout) {
-  AssertOnDBusThread();
-
-  // |timeout| will be deleted by OnRemoveTimeoutThunk().
-  Timeout* timeout = new Timeout(raw_timeout);
-  if (timeout->IsReadyToBeMonitored()) {
-    timeout->StartMonitoring(this);
-  }
-  ++num_pending_timeouts_;
-  return true;
+void Bus::OnRemoveWatch(const void* raw_watch) {
 }
 
-void Bus::OnRemoveTimeout(DBusTimeout* raw_timeout) {
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  Timeout* timeout = static_cast<Timeout*>(dbus_timeout_get_data(raw_timeout));
-  delete timeout;
-  --num_pending_timeouts_;
-}
-
-void Bus::OnToggleTimeout(DBusTimeout* raw_timeout) {
-  AssertOnDBusThread();
-
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-  Timeout* timeout = static_cast<Timeout*>(dbus_timeout_get_data(raw_timeout));
-  if (timeout->IsReadyToBeMonitored()) {
-    timeout->StartMonitoring(this);
-  } else {
-    timeout->StopMonitoring();
-  }
+void Bus::OnToggleWatch(const void* raw_watch) {
 }
 
-void Bus::OnDispatchStatusChanged(DBusConnection* connection,
-                                  DBusDispatchStatus status) {
-  DCHECK_EQ(connection, connection_);
-  AssertOnDBusThread();
-
-  // We cannot call ProcessAllIncomingDataIfAny() here, as calling
-  // dbus_connection_dispatch() inside DBusDispatchStatusFunction is
-  // prohibited by the D-Bus library. Hence, we post a task here instead.
-  // See comments for dbus_connection_set_dispatch_status_function().
-  GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&Bus::ProcessAllIncomingDataIfAny, this));
-}
-
-void Bus::OnServiceOwnerChanged(DBusMessage* message) {
-  DCHECK(message);
-  AssertOnDBusThread();
-
-  // |message| will be unrefed on exit of the function. Increment the
-  // reference so we can use it in Signal::FromRawMessage() below.
-  dbus_message_ref(message);
-  std::unique_ptr<Signal> signal(Signal::FromRawMessage(message));
-
-  // Confirm the validity of the NameOwnerChanged signal.
-  if (signal->GetMember() != kNameOwnerChangedSignal ||
-      signal->GetInterface() != DBUS_INTERFACE_DBUS ||
-      signal->GetSender() != DBUS_SERVICE_DBUS) {
-    return;
-  }
-
-  MessageReader reader(signal.get());
-  std::string service_name;
-  std::string old_owner;
-  std::string new_owner;
-  if (!reader.PopString(&service_name) ||
-      !reader.PopString(&old_owner) ||
-      !reader.PopString(&new_owner)) {
-    return;
-  }
-
-  ServiceOwnerChangedListenerMap::const_iterator it =
-      service_owner_changed_listener_map_.find(service_name);
-  if (it == service_owner_changed_listener_map_.end())
-    return;
-
-  const std::vector<ServiceOwnerChangeCallback>& callbacks = it->second;
-  for (size_t i = 0; i < callbacks.size(); ++i) {
-    GetOriginTaskRunner()->PostTask(FROM_HERE,
-                                    base::BindOnce(callbacks[i], new_owner));
-  }
+void Bus::OnRemoveTimeout(const void* raw_timeout) {
 }
 
-// static
-dbus_bool_t Bus::OnAddWatchThunk(DBusWatch* raw_watch, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  return self->OnAddWatch(raw_watch);
+void Bus::OnToggleTimeout(const void* raw_timeout) {
 }
 
-// static
-void Bus::OnRemoveWatchThunk(DBusWatch* raw_watch, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  self->OnRemoveWatch(raw_watch);
+void Bus::OnServiceOwnerChanged(const void* message) {
 }
 
-// static
-void Bus::OnToggleWatchThunk(DBusWatch* raw_watch, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  self->OnToggleWatch(raw_watch);
-}
 
 // static
-dbus_bool_t Bus::OnAddTimeoutThunk(DBusTimeout* raw_timeout, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  return self->OnAddTimeout(raw_timeout);
+void Bus::OnRemoveWatchThunk(const void* raw_watch, void* data) {
 }
 
 // static
-void Bus::OnRemoveTimeoutThunk(DBusTimeout* raw_timeout, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  self->OnRemoveTimeout(raw_timeout);
+void Bus::OnToggleWatchThunk(const void* raw_watch, void* data) {
 }
 
 // static
-void Bus::OnToggleTimeoutThunk(DBusTimeout* raw_timeout, void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  self->OnToggleTimeout(raw_timeout);
+void Bus::OnRemoveTimeoutThunk(const void* raw_timeout, void* data) {
 }
 
 // static
-void Bus::OnDispatchStatusChangedThunk(DBusConnection* connection,
-                                       DBusDispatchStatus status,
-                                       void* data) {
-  Bus* self = static_cast<Bus*>(data);
-  self->OnDispatchStatusChanged(connection, status);
-}
-
-// static
-DBusHandlerResult Bus::OnConnectionDisconnectedFilter(
-    DBusConnection* connection,
-    DBusMessage* message,
-    void* data) {
-  if (dbus_message_is_signal(message,
-                             DBUS_INTERFACE_LOCAL,
-                             kDisconnectedSignal)) {
-    // Abort when the connection is lost.
-    LOG(FATAL) << "D-Bus connection was disconnected. Aborting.";
-  }
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-// static
-DBusHandlerResult Bus::OnServiceOwnerChangedFilter(
-    DBusConnection* connection,
-    DBusMessage* message,
-    void* data) {
-  if (dbus_message_is_signal(message,
-                             DBUS_INTERFACE_DBUS,
-                             kNameOwnerChangedSignal)) {
-    Bus* self = static_cast<Bus*>(data);
-    self->OnServiceOwnerChanged(message);
-  }
-  // Always return unhandled to let others, e.g. ObjectProxies, handle the same
-  // signal.
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
+void Bus::OnToggleTimeoutThunk(const void* raw_timeout, void* data) {
 }
 
 }  // namespace dbus
diff -u a/dbus/bus.h b/dbus/bus.h
--- a/dbus/bus.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/bus.h	2020-06-09 20:53:14.667456911 +0200
@@ -5,7 +5,6 @@
 #ifndef DBUS_BUS_H_
 #define DBUS_BUS_H_
 
-#include <dbus/dbus.h>
 #include <stdint.h>
 
 #include <map>
@@ -139,9 +138,9 @@
   // system-wide services like NetworkManager. CUSTOM_ADDRESS is used to
   // communicate with an user specified address.
   enum BusType {
-    SESSION = DBUS_BUS_SESSION,
-    SYSTEM = DBUS_BUS_SYSTEM,
-    CUSTOM_ADDRESS,
+    SESSION = 0,
+    SYSTEM = 1,
+    CUSTOM_ADDRESS = 2,
   };
 
   // Specifies the connection type. PRIVATE should usually be used unless
@@ -175,10 +174,8 @@
   //
   // REQUIRE_PRIMARY_ALLOW_REPLACEMENT does the obvious.
   enum ServiceOwnershipOptions {
-    REQUIRE_PRIMARY = (DBUS_NAME_FLAG_DO_NOT_QUEUE |
-                       DBUS_NAME_FLAG_REPLACE_EXISTING),
-    REQUIRE_PRIMARY_ALLOW_REPLACEMENT = (REQUIRE_PRIMARY |
-                                         DBUS_NAME_FLAG_ALLOW_REPLACEMENT),
+    REQUIRE_PRIMARY = 0,
+    REQUIRE_PRIMARY_ALLOW_REPLACEMENT = 1,
   };
 
   // Options used to create a Bus object.
@@ -381,7 +378,7 @@
   virtual void ShutdownOnDBusThreadAndBlock();
 
   // Returns true if the shutdown has been completed.
-  bool shutdown_completed() { return shutdown_completed_; }
+  bool shutdown_completed() { return true; }
 
   //
   // The public functions below are not intended to be used in client
@@ -440,23 +437,23 @@
   // received. Used to implement synchronous method calls.
   //
   // BLOCKING CALL.
-  virtual DBusMessage* SendWithReplyAndBlock(DBusMessage* request,
+  virtual void* SendWithReplyAndBlock(const void* request,
                                              int timeout_ms,
-                                             DBusError* error);
+                                             const void* error);
 
   // Requests to send a message to the bus. The reply is handled with
   // |pending_call| at a later time.
   //
   // BLOCKING CALL.
-  virtual void SendWithReply(DBusMessage* request,
-                             DBusPendingCall** pending_call,
+  virtual void SendWithReply(const void* request,
+                             const void** pending_call,
                              int timeout_ms);
 
   // Requests to send a message to the bus. The message serial number will
   // be stored in |serial|.
   //
   // BLOCKING CALL.
-  virtual void Send(DBusMessage* request, uint32_t* serial);
+  virtual void Send(const void* request, uint32_t* serial);
 
   // Adds the message filter function. |filter_function| will be called
   // when incoming messages are received.
@@ -468,15 +465,6 @@
   // The same filter function associated with the same user data cannot be
   // added more than once.
   //
-  // BLOCKING CALL.
-  virtual void AddFilterFunction(DBusHandleMessageFunction filter_function,
-                                 void* user_data);
-
-  // Removes the message filter previously added by AddFilterFunction().
-  //
-  // BLOCKING CALL.
-  virtual void RemoveFilterFunction(DBusHandleMessageFunction filter_function,
-                                    void* user_data);
 
   // Adds the match rule. Messages that match the rule will be processed
   // by the filter functions added by AddFilterFunction().
@@ -496,14 +484,14 @@
   // http://dbus.freedesktop.org/doc/dbus-specification.html#message-bus-routing
   //
   // BLOCKING CALL.
-  virtual void AddMatch(const std::string& match_rule, DBusError* error);
+  virtual void AddMatch(const std::string& match_rule, const void* error);
 
   // Removes the match rule previously added by AddMatch().
   // Returns false if the requested match rule is unknown or has already been
   // removed. Otherwise, returns true and sets |error| accordingly.
   //
   // BLOCKING CALL.
-  virtual bool RemoveMatch(const std::string& match_rule, DBusError* error);
+  virtual bool RemoveMatch(const std::string& match_rule, const void* error);
 
   // Tries to register the object path. Returns true on success.
   // Returns false if the object path is already registered.
@@ -518,9 +506,9 @@
   //
   // BLOCKING CALL.
   virtual bool TryRegisterObjectPath(const ObjectPath& object_path,
-                                     const DBusObjectPathVTable* vtable,
+                                     const void* vtable,
                                      void* user_data,
-                                     DBusError* error);
+                                     const void* error);
 
   // Tries to register the object path and its sub paths.
   // Returns true on success.
@@ -536,9 +524,9 @@
   //
   // BLOCKING CALL.
   virtual bool TryRegisterFallback(const ObjectPath& object_path,
-                                   const DBusObjectPathVTable* vtable,
+                                   const void* vtable,
                                    void* user_data,
-                                   DBusError* error);
+                                   const void* error);
 
   // Unregister the object path.
   //
@@ -610,20 +598,15 @@
   virtual ~Bus();
 
  private:
-  using TryRegisterObjectPathFunction =
-      dbus_bool_t(DBusConnection* connection,
-                  const char* object_path,
-                  const DBusObjectPathVTable* vtable,
-                  void* user_data,
-                  DBusError* error);
+  using TryRegisterObjectPathFunction = bool;
 
   friend class base::RefCountedThreadSafe<Bus>;
 
   bool TryRegisterObjectPathInternal(
       const ObjectPath& object_path,
-      const DBusObjectPathVTable* vtable,
+      const void* vtable,
       void* user_data,
-      DBusError* error,
+      const void* error,
       TryRegisterObjectPathFunction* register_function);
 
   // Helper function used for RemoveObjectProxy().
@@ -669,62 +652,35 @@
   // BLOCKING CALL.
   void ProcessAllIncomingDataIfAny();
 
-  // Called when a watch object is added. Used to start monitoring the
-  // file descriptor used for D-Bus communication.
-  dbus_bool_t OnAddWatch(DBusWatch* raw_watch);
-
   // Called when a watch object is removed.
-  void OnRemoveWatch(DBusWatch* raw_watch);
+  void OnRemoveWatch(const void* raw_watch);
 
   // Called when the "enabled" status of |raw_watch| is toggled.
-  void OnToggleWatch(DBusWatch* raw_watch);
-
-  // Called when a timeout object is added. Used to start monitoring
-  // timeout for method calls.
-  dbus_bool_t OnAddTimeout(DBusTimeout* raw_timeout);
+  void OnToggleWatch(const void* raw_watch);
 
   // Called when a timeout object is removed.
-  void OnRemoveTimeout(DBusTimeout* raw_timeout);
+  void OnRemoveTimeout(const void* raw_timeout);
 
   // Called when the "enabled" status of |raw_timeout| is toggled.
-  void OnToggleTimeout(DBusTimeout* raw_timeout);
+  void OnToggleTimeout(const void* raw_timeout);
 
   // Called when the dispatch status (i.e. if any incoming data is
   // available) is changed.
-  void OnDispatchStatusChanged(DBusConnection* connection,
-                               DBusDispatchStatus status);
 
   // Called when a service owner change occurs.
-  void OnServiceOwnerChanged(DBusMessage* message);
+  void OnServiceOwnerChanged(const void* message);
 
   // Callback helper functions. Redirects to the corresponding member function.
-  static dbus_bool_t OnAddWatchThunk(DBusWatch* raw_watch, void* data);
-  static void OnRemoveWatchThunk(DBusWatch* raw_watch, void* data);
-  static void OnToggleWatchThunk(DBusWatch* raw_watch, void* data);
-  static dbus_bool_t OnAddTimeoutThunk(DBusTimeout* raw_timeout, void* data);
-  static void OnRemoveTimeoutThunk(DBusTimeout* raw_timeout, void* data);
-  static void OnToggleTimeoutThunk(DBusTimeout* raw_timeout, void* data);
-  static void OnDispatchStatusChangedThunk(DBusConnection* connection,
-                                           DBusDispatchStatus status,
-                                           void* data);
-
-  // Calls OnConnectionDisconnected if the Disconnected signal is received.
-  static DBusHandlerResult OnConnectionDisconnectedFilter(
-      DBusConnection* connection,
-      DBusMessage* message,
-      void* user_data);
-
-  // Calls OnServiceOwnerChanged for a NameOwnerChanged signal.
-  static DBusHandlerResult OnServiceOwnerChangedFilter(
-      DBusConnection* connection,
-      DBusMessage* message,
-      void* user_data);
+  static void OnRemoveWatchThunk(const void* raw_watch, void* data);
+  static void OnToggleWatchThunk(const void* raw_watch, void* data);
+  static void OnRemoveTimeoutThunk(const void* raw_timeout, void* data);
+  static void OnToggleTimeoutThunk(const void* raw_timeout, void* data);
 
   const BusType bus_type_;
   const ConnectionType connection_type_;
   scoped_refptr<base::SequencedTaskRunner> dbus_task_runner_;
   base::WaitableEvent on_shutdown_;
-  DBusConnection* connection_;
+  void* connection_;
 
   base::PlatformThreadId origin_thread_id_;
   scoped_refptr<base::SequencedTaskRunner> origin_task_runner_;
@@ -736,7 +692,6 @@
   // match rules are counted in a map.
   std::map<std::string, int> match_rules_added_;
   std::set<ObjectPath> registered_object_paths_;
-  std::set<std::pair<DBusHandleMessageFunction, void*>> filter_functions_added_;
 
   // ObjectProxyTable is used to hold the object proxies created by the
   // bus object. Key is a pair; the first part is a concatenated string of
diff -u a/dbus/bus_unittest.cc b/dbus/bus_unittest.cc
--- a/dbus/bus_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/bus_unittest.cc	2020-06-09 18:29:47.806642502 +0200
@@ -35,19 +35,9 @@
   ~RunLoopWithExpectedCount() = default;
 
   void Run(int expected_quit_calls) {
-    DCHECK_EQ(0, expected_quit_calls_);
-    DCHECK_EQ(0, actual_quit_calls_);
-    expected_quit_calls_ = expected_quit_calls;
-    run_loop_.reset(new base::RunLoop());
-    run_loop_->Run();
   }
 
   void QuitIfConditionIsSatisified() {
-    if (++actual_quit_calls_ != expected_quit_calls_)
-      return;
-    run_loop_->Quit();
-    expected_quit_calls_ = 0;
-    actual_quit_calls_ = 0;
   }
 
  private:
@@ -63,352 +53,8 @@
                            std::string* service_owner,
                            int* num_of_owner_changes,
                            const std::string& new_service_owner) {
-  *service_owner = new_service_owner;
-  ++(*num_of_owner_changes);
-  run_loop_state->QuitIfConditionIsSatisified();
 }
 
 }  // namespace
 
-TEST(BusTest, GetObjectProxy) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-
-  ObjectProxy* object_proxy1 =
-      bus->GetObjectProxy("org.chromium.TestService",
-                          ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy1);
-
-  // This should return the same object.
-  ObjectProxy* object_proxy2 =
-      bus->GetObjectProxy("org.chromium.TestService",
-                          ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy2);
-  EXPECT_EQ(object_proxy1, object_proxy2);
-
-  // This should not.
-  ObjectProxy* object_proxy3 =
-      bus->GetObjectProxy(
-          "org.chromium.TestService",
-          ObjectPath("/org/chromium/DifferentTestObject"));
-  ASSERT_TRUE(object_proxy3);
-  EXPECT_NE(object_proxy1, object_proxy3);
-
-  bus->ShutdownAndBlock();
-}
-
-TEST(BusTest, GetObjectProxyIgnoreUnknownService) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-
-  ObjectProxy* object_proxy1 =
-      bus->GetObjectProxyWithOptions(
-          "org.chromium.TestService",
-          ObjectPath("/org/chromium/TestObject"),
-          ObjectProxy::IGNORE_SERVICE_UNKNOWN_ERRORS);
-  ASSERT_TRUE(object_proxy1);
-
-  // This should return the same object.
-  ObjectProxy* object_proxy2 =
-      bus->GetObjectProxyWithOptions(
-          "org.chromium.TestService",
-          ObjectPath("/org/chromium/TestObject"),
-          ObjectProxy::IGNORE_SERVICE_UNKNOWN_ERRORS);
-  ASSERT_TRUE(object_proxy2);
-  EXPECT_EQ(object_proxy1, object_proxy2);
-
-  // This should not.
-  ObjectProxy* object_proxy3 =
-      bus->GetObjectProxyWithOptions(
-          "org.chromium.TestService",
-          ObjectPath("/org/chromium/DifferentTestObject"),
-          ObjectProxy::IGNORE_SERVICE_UNKNOWN_ERRORS);
-  ASSERT_TRUE(object_proxy3);
-  EXPECT_NE(object_proxy1, object_proxy3);
-
-  bus->ShutdownAndBlock();
-}
-
-TEST(BusTest, RemoveObjectProxy) {
-  base::test::SingleThreadTaskEnvironment task_environment;
-
-  // Start the D-Bus thread.
-  base::Thread::Options thread_options;
-  thread_options.message_pump_type = base::MessagePumpType::IO;
-  base::Thread dbus_thread("D-Bus thread");
-  dbus_thread.StartWithOptions(thread_options);
-
-  // Create the bus.
-  Bus::Options options;
-  options.dbus_task_runner = dbus_thread.task_runner();
-  scoped_refptr<Bus> bus = new Bus(options);
-  ASSERT_FALSE(bus->shutdown_completed());
-
-  // Try to remove a non existant object proxy should return false.
-  ASSERT_FALSE(bus->RemoveObjectProxy("org.chromium.TestService",
-                                      ObjectPath("/org/chromium/TestObject"),
-                                      base::DoNothing()));
-
-  ObjectProxy* object_proxy1 =
-      bus->GetObjectProxy("org.chromium.TestService",
-                          ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy1);
-
-  // Increment the reference count to the object proxy to avoid destroying it
-  // while removing the object.
-  object_proxy1->AddRef();
-
-  // Remove the object from the bus. This will invalidate any other usage of
-  // object_proxy1 other than destroy it. We keep this object for a comparison
-  // at a later time.
-  ASSERT_TRUE(bus->RemoveObjectProxy("org.chromium.TestService",
-                                     ObjectPath("/org/chromium/TestObject"),
-                                     base::DoNothing()));
-
-  // This should return a different object because the first object was removed
-  // from the bus, but not deleted from memory.
-  ObjectProxy* object_proxy2 =
-      bus->GetObjectProxy("org.chromium.TestService",
-                          ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy2);
-
-  // Compare the new object with the first object. The first object still exists
-  // thanks to the increased reference.
-  EXPECT_NE(object_proxy1, object_proxy2);
-
-  // Release object_proxy1.
-  object_proxy1->Release();
-
-  // Shut down synchronously.
-  bus->ShutdownOnDBusThreadAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-  dbus_thread.Stop();
-}
-
-TEST(BusTest, GetExportedObject) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-
-  ExportedObject* object_proxy1 =
-      bus->GetExportedObject(ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy1);
-
-  // This should return the same object.
-  ExportedObject* object_proxy2 =
-      bus->GetExportedObject(ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy2);
-  EXPECT_EQ(object_proxy1, object_proxy2);
-
-  // This should not.
-  ExportedObject* object_proxy3 =
-      bus->GetExportedObject(
-          ObjectPath("/org/chromium/DifferentTestObject"));
-  ASSERT_TRUE(object_proxy3);
-  EXPECT_NE(object_proxy1, object_proxy3);
-
-  bus->ShutdownAndBlock();
-}
-
-TEST(BusTest, UnregisterExportedObject) {
-  // Start the D-Bus thread.
-  base::Thread::Options thread_options;
-  thread_options.message_pump_type = base::MessagePumpType::IO;
-  base::Thread dbus_thread("D-Bus thread");
-  dbus_thread.StartWithOptions(thread_options);
-
-  // Create the bus.
-  Bus::Options options;
-  options.dbus_task_runner = dbus_thread.task_runner();
-  scoped_refptr<Bus> bus = new Bus(options);
-  ASSERT_FALSE(bus->shutdown_completed());
-
-  ExportedObject* object_proxy1 =
-      bus->GetExportedObject(ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy1);
-
-  // Increment the reference count to the object proxy to avoid destroying it
-  // calling UnregisterExportedObject. This ensures the dbus::ExportedObject is
-  // not freed from memory. See http://crbug.com/137846 for details.
-  object_proxy1->AddRef();
-
-  bus->UnregisterExportedObject(ObjectPath("/org/chromium/TestObject"));
-
-  // This should return a new object because the object_proxy1 is still in
-  // alloc'ed memory.
-  ExportedObject* object_proxy2 =
-      bus->GetExportedObject(ObjectPath("/org/chromium/TestObject"));
-  ASSERT_TRUE(object_proxy2);
-  EXPECT_NE(object_proxy1, object_proxy2);
-
-  // Release the incremented reference.
-  object_proxy1->Release();
-
-  // Shut down synchronously.
-  bus->ShutdownOnDBusThreadAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-  dbus_thread.Stop();
-}
-
-TEST(BusTest, ShutdownAndBlock) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-  ASSERT_FALSE(bus->shutdown_completed());
-
-  // Shut down synchronously.
-  bus->ShutdownAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-}
-
-TEST(BusTest, ShutdownAndBlockWithDBusThread) {
-  // Start the D-Bus thread.
-  base::Thread::Options thread_options;
-  thread_options.message_pump_type = base::MessagePumpType::IO;
-  base::Thread dbus_thread("D-Bus thread");
-  dbus_thread.StartWithOptions(thread_options);
-
-  // Create the bus.
-  Bus::Options options;
-  options.dbus_task_runner = dbus_thread.task_runner();
-  scoped_refptr<Bus> bus = new Bus(options);
-  ASSERT_FALSE(bus->shutdown_completed());
-
-  // Shut down synchronously.
-  bus->ShutdownOnDBusThreadAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-  dbus_thread.Stop();
-}
-
-TEST(BusTest, DoubleAddAndRemoveMatch) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-  ScopedDBusError error;
-
-  bus->Connect();
-
-  // Adds the same rule twice.
-  bus->AddMatch(
-      "type='signal',interface='org.chromium.TestService',path='/'",
-      error.get());
-  ASSERT_FALSE(error.is_set());
-
-  bus->AddMatch(
-      "type='signal',interface='org.chromium.TestService',path='/'",
-      error.get());
-  ASSERT_FALSE(error.is_set());
-
-  // Removes the same rule twice.
-  ASSERT_TRUE(bus->RemoveMatch(
-      "type='signal',interface='org.chromium.TestService',path='/'",
-      error.get()));
-  ASSERT_FALSE(error.is_set());
-
-  // The rule should be still in the bus since it was removed only once.
-  // A second removal shouldn't give an error.
-  ASSERT_TRUE(bus->RemoveMatch(
-      "type='signal',interface='org.chromium.TestService',path='/'",
-      error.get()));
-  ASSERT_FALSE(error.is_set());
-
-  // A third attemp to remove the same rule should fail.
-  ASSERT_FALSE(bus->RemoveMatch(
-      "type='signal',interface='org.chromium.TestService',path='/'",
-      error.get()));
-
-  bus->ShutdownAndBlock();
-}
-
-TEST(BusTest, ListenForServiceOwnerChange) {
-  base::test::SingleThreadTaskEnvironment task_environment(
-      base::test::SingleThreadTaskEnvironment::MainThreadType::IO);
-
-  RunLoopWithExpectedCount run_loop_state;
-
-  // Create the bus.
-  Bus::Options bus_options;
-  scoped_refptr<Bus> bus = new Bus(bus_options);
-
-  // Add a listener.
-  std::string service_owner1;
-  int num_of_owner_changes1 = 0;
-  Bus::ServiceOwnerChangeCallback callback1 =
-      base::BindRepeating(&OnServiceOwnerChanged, &run_loop_state,
-                          &service_owner1, &num_of_owner_changes1);
-  bus->ListenForServiceOwnerChange("org.chromium.TestService", callback1);
-  // This should be a no-op.
-  bus->ListenForServiceOwnerChange("org.chromium.TestService", callback1);
-  base::RunLoop().RunUntilIdle();
-
-  // Nothing has happened yet. Check initial state.
-  EXPECT_TRUE(service_owner1.empty());
-  EXPECT_EQ(0, num_of_owner_changes1);
-
-  // Make an ownership change.
-  ASSERT_TRUE(bus->RequestOwnershipAndBlock("org.chromium.TestService",
-                                            Bus::REQUIRE_PRIMARY));
-  run_loop_state.Run(1);
-
-  {
-    // Get the current service owner and check to make sure the listener got
-    // the right value.
-    std::string current_service_owner =
-        bus->GetServiceOwnerAndBlock("org.chromium.TestService",
-                                     Bus::REPORT_ERRORS);
-    ASSERT_FALSE(current_service_owner.empty());
-
-    // Make sure the listener heard about the new owner.
-    EXPECT_EQ(current_service_owner, service_owner1);
-
-    // Test the second ListenForServiceOwnerChange() above is indeed a no-op.
-    EXPECT_EQ(1, num_of_owner_changes1);
-  }
-
-  // Add a second listener.
-  std::string service_owner2;
-  int num_of_owner_changes2 = 0;
-  Bus::ServiceOwnerChangeCallback callback2 =
-      base::BindRepeating(&OnServiceOwnerChanged, &run_loop_state,
-                          &service_owner2, &num_of_owner_changes2);
-  bus->ListenForServiceOwnerChange("org.chromium.TestService", callback2);
-  base::RunLoop().RunUntilIdle();
-
-  // Release the ownership and make sure the service owner listeners fire with
-  // the right values and the right number of times.
-  ASSERT_TRUE(bus->ReleaseOwnership("org.chromium.TestService"));
-  run_loop_state.Run(2);
-
-  EXPECT_TRUE(service_owner1.empty());
-  EXPECT_TRUE(service_owner2.empty());
-  EXPECT_EQ(2, num_of_owner_changes1);
-  EXPECT_EQ(1, num_of_owner_changes2);
-
-  // Unlisten so shutdown can proceed correctly.
-  bus->UnlistenForServiceOwnerChange("org.chromium.TestService", callback1);
-  bus->UnlistenForServiceOwnerChange("org.chromium.TestService", callback2);
-  base::RunLoop().RunUntilIdle();
-
-  // Shut down synchronously.
-  bus->ShutdownAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-}
-
-TEST(BusTest, GetConnectionName) {
-  Bus::Options options;
-  scoped_refptr<Bus> bus = new Bus(options);
-
-  // Connection name is empty since bus is not connected.
-  EXPECT_FALSE(bus->IsConnected());
-  EXPECT_TRUE(bus->GetConnectionName().empty());
-
-  // Connect bus to D-Bus.
-  bus->Connect();
-
-  // Connection name is not empty after connection is established.
-  EXPECT_TRUE(bus->IsConnected());
-  EXPECT_FALSE(bus->GetConnectionName().empty());
-
-  // Shut down synchronously.
-  bus->ShutdownAndBlock();
-  EXPECT_TRUE(bus->shutdown_completed());
-}
-
 }  // namespace dbus
diff -u a/dbus/dbus_statistics.cc b/dbus/dbus_statistics.cc
--- a/dbus/dbus_statistics.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/dbus_statistics.cc	2020-06-09 18:41:42.617632256 +0200
@@ -48,7 +48,6 @@
   }
 
   ~DBusStatistics() {
-    DCHECK_EQ(origin_thread_id_, base::PlatformThread::CurrentId());
   }
 
   // Enum to specify which field in Stat to increment in AddStat.
@@ -63,21 +62,6 @@
                const std::string& interface,
                const std::string& method,
                StatType type) {
-    if (base::PlatformThread::CurrentId() != origin_thread_id_) {
-      DVLOG(1) << "Ignoring DBusStatistics::AddStat call from thread: "
-               << base::PlatformThread::CurrentId();
-      return;
-    }
-    StatValue* stat = GetStats(service, interface, method, true);
-    DCHECK(stat);
-    if (type == TYPE_SENT_METHOD_CALLS)
-      ++stat->sent_method_calls;
-    else if (type == TYPE_RECEIVED_SIGNALS)
-      ++stat->received_signals;
-    else if (type == TYPE_SENT_BLOCKING_METHOD_CALLS)
-      ++stat->sent_blocking_method_calls;
-    else
-      NOTREACHED();
   }
 
   // Look up the Stat entry in |stats_|. If |add_stat| is true, add a new entry
@@ -86,17 +70,6 @@
                       const std::string& interface,
                       const std::string& method,
                       bool add_stat) {
-    DCHECK_EQ(origin_thread_id_, base::PlatformThread::CurrentId());
-
-    StatKey key = {service, interface, method};
-    auto it = stats_.find(key);
-    if (it != stats_.end())
-      return &(it->second);
-
-    if (!add_stat)
-      return nullptr;
-
-    return &(stats_[key]);
   }
 
   StatMap& stats() { return stats_; }
@@ -119,127 +92,30 @@
 namespace statistics {
 
 void Initialize() {
-  if (g_dbus_statistics)
-    delete g_dbus_statistics;  // reset statistics
-  g_dbus_statistics = new DBusStatistics();
 }
 
 void Shutdown() {
-  delete g_dbus_statistics;
-  g_dbus_statistics = nullptr;
 }
 
 void AddSentMethodCall(const std::string& service,
                        const std::string& interface,
                        const std::string& method) {
-  if (!g_dbus_statistics)
-    return;
-  g_dbus_statistics->AddStat(
-      service, interface, method, DBusStatistics::TYPE_SENT_METHOD_CALLS);
 }
 
 void AddReceivedSignal(const std::string& service,
                        const std::string& interface,
                        const std::string& method) {
-  if (!g_dbus_statistics)
-    return;
-  g_dbus_statistics->AddStat(
-      service, interface, method, DBusStatistics::TYPE_RECEIVED_SIGNALS);
 }
 
 void AddBlockingSentMethodCall(const std::string& service,
                                const std::string& interface,
                                const std::string& method) {
-  if (!g_dbus_statistics)
-    return;
-  g_dbus_statistics->AddStat(
-      service, interface, method,
-      DBusStatistics::TYPE_SENT_BLOCKING_METHOD_CALLS);
 }
 
 // NOTE: If the output format is changed, be certain to change the test
 // expectations as well.
 std::string GetAsString(ShowInString show, FormatString format) {
-  if (!g_dbus_statistics)
-    return "DBusStatistics not initialized.";
-
-  const StatMap& stats = g_dbus_statistics->stats();
-  if (stats.empty())
-    return "No DBus calls.";
-
-  base::TimeDelta dtime = base::Time::Now() - g_dbus_statistics->start_time();
-  int dminutes = dtime.InMinutes();
-  dminutes = std::max(dminutes, 1);
-
-  std::string result;
-  int sent = 0, received = 0, sent_blocking = 0;
-  // Stats are stored in order by service, then interface, then method.
-  for (auto iter = stats.begin(); iter != stats.end();) {
-    auto cur_iter = iter;
-    auto next_iter = ++iter;
-    const StatKey& stat_key = cur_iter->first;
-    const StatValue& stat = cur_iter->second;
-    sent += stat.sent_method_calls;
-    received += stat.received_signals;
-    sent_blocking += stat.sent_blocking_method_calls;
-    // If this is not the last stat, and if the next stat matches the current
-    // stat, continue.
-    if (next_iter != stats.end() &&
-        next_iter->first.service == stat_key.service &&
-        (show < SHOW_INTERFACE ||
-         next_iter->first.interface == stat_key.interface) &&
-        (show < SHOW_METHOD || next_iter->first.method == stat_key.method))
-      continue;
-
-    if (!sent && !received && !sent_blocking)
-        continue;  // No stats collected for this line, skip it and continue.
-
-    // Add a line to the result and clear the counts.
-    std::string line;
-    if (show == SHOW_SERVICE) {
-      line += stat_key.service;
-    } else {
-      // The interface usually includes the service so don't show both.
-      line += stat_key.interface;
-      if (show >= SHOW_METHOD)
-        line += "." + stat_key.method;
-    }
-    line += base::StringPrintf(":");
-    if (sent_blocking) {
-      line += base::StringPrintf(" Sent (BLOCKING):");
-      if (format == FORMAT_TOTALS)
-        line += base::StringPrintf(" %d", sent_blocking);
-      else if (format == FORMAT_PER_MINUTE)
-        line += base::StringPrintf(" %d/min", sent_blocking / dminutes);
-      else if (format == FORMAT_ALL)
-        line += base::StringPrintf(" %d (%d/min)",
-                                   sent_blocking, sent_blocking / dminutes);
-    }
-    if (sent) {
-      line += base::StringPrintf(" Sent:");
-      if (format == FORMAT_TOTALS)
-        line += base::StringPrintf(" %d", sent);
-      else if (format == FORMAT_PER_MINUTE)
-        line += base::StringPrintf(" %d/min", sent / dminutes);
-      else if (format == FORMAT_ALL)
-        line += base::StringPrintf(" %d (%d/min)", sent, sent / dminutes);
-    }
-    if (received) {
-      line += base::StringPrintf(" Received:");
-      if (format == FORMAT_TOTALS)
-        line += base::StringPrintf(" %d", received);
-      else if (format == FORMAT_PER_MINUTE)
-        line += base::StringPrintf(" %d/min", received / dminutes);
-      else if (format == FORMAT_ALL)
-        line += base::StringPrintf(
-            " %d (%d/min)", received, received / dminutes);
-    }
-    result += line + "\n";
-    sent = 0;
-    sent_blocking = 0;
-    received = 0;
-  }
-  return result;
+  return "";
 }
 
 namespace testing {
@@ -250,15 +126,6 @@
               int* sent,
               int* received,
               int* blocking) {
-  if (!g_dbus_statistics)
-    return false;
-  StatValue* stat =
-      g_dbus_statistics->GetStats(service, interface, method, false);
-  if (!stat)
-    return false;
-  *sent = stat->sent_method_calls;
-  *received = stat->received_signals;
-  *blocking = stat->sent_blocking_method_calls;
   return true;
 }
 
diff -u a/dbus/dbus_statistics_unittest.cc b/dbus/dbus_statistics_unittest.cc
--- a/dbus/dbus_statistics_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/dbus_statistics_unittest.cc	2020-06-09 18:38:07.274920599 +0200
@@ -14,165 +14,16 @@
  public:
   DBusStatisticsTest() = default;
 
-  void SetUp() override { statistics::Initialize(); }
+  void SetUp() override { }
 
-  void TearDown() override { statistics::Shutdown(); }
+  void TearDown() override {  }
 
  protected:
   void AddTestMethodCalls() {
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method1");
-    statistics::AddReceivedSignal(
-        "service1", "service1.interface1", "method1");
-    statistics::AddBlockingSentMethodCall(
-        "service1", "service1.interface1", "method1");
-
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method2");
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method2");
-    statistics::AddReceivedSignal(
-        "service1", "service1.interface1", "method2");
-
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method3");
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method3");
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface1", "method3");
-
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface2", "method1");
-
-    statistics::AddSentMethodCall(
-        "service1", "service1.interface2", "method2");
-
-    statistics::AddSentMethodCall(
-        "service2", "service2.interface1", "method1");
   }
 
  private:
   DISALLOW_COPY_AND_ASSIGN(DBusStatisticsTest);
 };
 
-TEST_F(DBusStatisticsTest, TestDBusStatsBasic) {
-  int sent = 0, received = 0, block = 0;
-
-  // Add a sent call
-  statistics::AddSentMethodCall("service1", "service1.interface1", "method1");
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(0, received);
-  EXPECT_EQ(0, block);
-
-  // Add a received call
-  statistics::AddReceivedSignal("service1", "service1.interface1", "method1");
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(1, received);
-  EXPECT_EQ(0, block);
-
-  // Add a block call
-  statistics::AddBlockingSentMethodCall(
-      "service1", "service1.interface1", "method1");
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(1, received);
-  EXPECT_EQ(1, block);
-}
-
-TEST_F(DBusStatisticsTest, TestDBusStatsMulti) {
-  int sent = 0, received = 0, block = 0;
-
-  // Add some more stats to exercise accessing multiple different stats.
-  AddTestMethodCalls();
-
-  // Make sure all entries can be found in the set and their counts were
-  // incremented correctly.
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(1, received);
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method2", &sent, &received, &block));
-  EXPECT_EQ(2, sent);
-  EXPECT_EQ(1, received);
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface1", "method3", &sent, &received, &block));
-  EXPECT_EQ(3, sent);
-  EXPECT_EQ(0, received);
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface2", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(0, received);
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service1", "service1.interface2", "method2", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(0, received);
-  ASSERT_TRUE(statistics::testing::GetCalls(
-      "service2", "service2.interface1", "method1", &sent, &received, &block));
-  EXPECT_EQ(1, sent);
-  EXPECT_EQ(0, received);
-
-  ASSERT_FALSE(statistics::testing::GetCalls(
-      "service1", "service1.interface3", "method2", &sent, &received, &block));
-}
-
-TEST_F(DBusStatisticsTest, TestGetAsString) {
-  std::string output_none = GetAsString(statistics::SHOW_SERVICE,
-                                        statistics::FORMAT_TOTALS);
-  EXPECT_EQ("No DBus calls.", output_none);
-
-  AddTestMethodCalls();
-
-  std::string output_service = GetAsString(statistics::SHOW_SERVICE,
-                                           statistics::FORMAT_TOTALS);
-  const std::string expected_output_service(
-      "service1: Sent (BLOCKING): 1 Sent: 8 Received: 2\n"
-      "service2: Sent: 1\n");
-  EXPECT_EQ(expected_output_service, output_service);
-
-  std::string output_interface = GetAsString(statistics::SHOW_INTERFACE,
-                                             statistics::FORMAT_TOTALS);
-  const std::string expected_output_interface(
-      "service1.interface1: Sent (BLOCKING): 1 Sent: 6 Received: 2\n"
-      "service1.interface2: Sent: 2\n"
-      "service2.interface1: Sent: 1\n");
-  EXPECT_EQ(expected_output_interface, output_interface);
-
-  std::string output_per_minute = GetAsString(statistics::SHOW_INTERFACE,
-                                              statistics::FORMAT_PER_MINUTE);
-  const std::string expected_output_per_minute(
-      "service1.interface1: Sent (BLOCKING): 1/min Sent: 6/min"
-      " Received: 2/min\n"
-      "service1.interface2: Sent: 2/min\n"
-      "service2.interface1: Sent: 1/min\n");
-  EXPECT_EQ(expected_output_per_minute, output_per_minute);
-
-  std::string output_all = GetAsString(statistics::SHOW_INTERFACE,
-                                       statistics::FORMAT_ALL);
-  const std::string expected_output_all(
-      "service1.interface1: Sent (BLOCKING): 1 (1/min) Sent: 6 (6/min)"
-      " Received: 2 (2/min)\n"
-      "service1.interface2: Sent: 2 (2/min)\n"
-      "service2.interface1: Sent: 1 (1/min)\n");
-  EXPECT_EQ(expected_output_all, output_all);
-
-
-  std::string output_method = GetAsString(statistics::SHOW_METHOD,
-                                          statistics::FORMAT_TOTALS);
-  const std::string expected_output_method(
-      "service1.interface1.method1: Sent (BLOCKING): 1 Sent: 1 Received: 1\n"
-      "service1.interface1.method2: Sent: 2 Received: 1\n"
-      "service1.interface1.method3: Sent: 3\n"
-      "service1.interface2.method1: Sent: 1\n"
-      "service1.interface2.method2: Sent: 1\n"
-      "service2.interface1.method1: Sent: 1\n");
-  EXPECT_EQ(expected_output_method, output_method);
-
-}
-
 }  // namespace dbus
diff -u a/dbus/end_to_end_async_unittest.cc b/dbus/end_to_end_async_unittest.cc
--- a/dbus/end_to_end_async_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/end_to_end_async_unittest.cc	2020-06-09 18:21:50.965598521 +0200
@@ -41,214 +41,68 @@
 class EndToEndAsyncTest : public testing::Test {
  public:
   void SetUp() override {
-    // Make the main thread not to allow IO.
-    base::ThreadRestrictions::SetIOAllowed(false);
-
-    // Start the D-Bus thread.
-    dbus_thread_.reset(new base::Thread("D-Bus Thread"));
-    base::Thread::Options thread_options;
-    thread_options.message_pump_type = base::MessagePumpType::IO;
-    ASSERT_TRUE(dbus_thread_->StartWithOptions(thread_options));
-
-    // Start the test service, using the D-Bus thread.
-    TestService::Options options;
-    options.dbus_task_runner = dbus_thread_->task_runner();
-    test_service_.reset(new TestService(options));
-    ASSERT_TRUE(test_service_->StartService());
-    test_service_->WaitUntilServiceIsStarted();
-    ASSERT_TRUE(test_service_->HasDBusThread());
-
-    // Create the client, using the D-Bus thread.
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::SESSION;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_options.dbus_task_runner = dbus_thread_->task_runner();
-    bus_ = new Bus(bus_options);
-    object_proxy_ = bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    // Connect to the "Test" signal of "org.chromium.TestInterface" from
-    // the remote object.
-    object_proxy_->ConnectToSignal(
-        "org.chromium.TestInterface", "Test",
-        base::BindRepeating(&EndToEndAsyncTest::OnTestSignal,
-                            base::Unretained(this)),
-        base::BindOnce(&EndToEndAsyncTest::OnConnected,
-                       base::Unretained(this)));
-    // Wait until the object proxy is connected to the signal.
-    run_loop_.reset(new base::RunLoop());
-    run_loop_->Run();
-
-    // Connect to the "Test2" signal of "org.chromium.TestInterface" from
-    // the remote object. There was a bug where we were emitting error
-    // messages like "Requested to remove an unknown match rule: ..." at
-    // the shutdown of Bus when an object proxy is connected to more than
-    // one signal of the same interface. See crosbug.com/23382 for details.
-    object_proxy_->ConnectToSignal(
-        "org.chromium.TestInterface", "Test2",
-        base::BindRepeating(&EndToEndAsyncTest::OnTest2Signal,
-                            base::Unretained(this)),
-        base::BindOnce(&EndToEndAsyncTest::OnConnected,
-                       base::Unretained(this)));
-    // Wait until the object proxy is connected to the signal.
-    run_loop_.reset(new base::RunLoop());
-    run_loop_->Run();
-
-    // Create a second object proxy for the root object.
-    root_object_proxy_ = bus_->GetObjectProxy(test_service_->service_name(),
-                                              ObjectPath("/"));
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    // Connect to the "Test" signal of "org.chromium.TestInterface" from
-    // the root remote object too.
-    root_object_proxy_->ConnectToSignal(
-        "org.chromium.TestInterface", "Test",
-        base::BindRepeating(&EndToEndAsyncTest::OnRootTestSignal,
-                            base::Unretained(this)),
-        base::BindOnce(&EndToEndAsyncTest::OnConnected,
-                       base::Unretained(this)));
-    // Wait until the root object proxy is connected to the signal.
-    run_loop_.reset(new base::RunLoop());
-    run_loop_->Run();
   }
 
   void TearDown() override {
-    bus_->ShutdownOnDBusThreadAndBlock();
-
-    // Shut down the service.
-    test_service_->ShutdownAndBlock();
-
-    // Reset to the default.
-    base::ThreadRestrictions::SetIOAllowed(true);
-
-    // Stopping a thread is considered an IO operation, so do this after
-    // allowing IO.
-    test_service_->Stop();
   }
 
  protected:
   // Replaces the bus with a broken one.
   void SetUpBrokenBus() {
-    // Shut down the existing bus.
-    bus_->ShutdownOnDBusThreadAndBlock();
-
-    // Create new bus with invalid address.
-    const char kInvalidAddress[] = "";
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::CUSTOM_ADDRESS;
-    bus_options.address = kInvalidAddress;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_options.dbus_task_runner = dbus_thread_->task_runner();
-    bus_ = new Bus(bus_options);
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    // Create new object proxy.
-    object_proxy_ = bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
   }
 
   // Calls the method asynchronously. OnResponse() will be called once the
   // response is received.
   void CallMethod(MethodCall* method_call,
                   int timeout_ms) {
-    object_proxy_->CallMethod(
-        method_call, timeout_ms,
-        base::BindOnce(&EndToEndAsyncTest::OnResponse, base::Unretained(this)));
   }
 
   // Calls the method asynchronously. OnResponse() will be called once the
   // response is received without error, otherwise OnError() will be called.
   void CallMethodWithErrorCallback(MethodCall* method_call,
                                    int timeout_ms) {
-    object_proxy_->CallMethodWithErrorCallback(
-        method_call, timeout_ms,
-        base::BindOnce(&EndToEndAsyncTest::OnResponse, base::Unretained(this)),
-        base::BindOnce(&EndToEndAsyncTest::OnError, base::Unretained(this)));
   }
 
   // Wait for the give number of responses.
   void WaitForResponses(size_t num_responses) {
-    while (response_strings_.size() < num_responses) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
   }
 
   // Called when the response is received.
   void OnResponse(Response* response) {
-    // |response| will be deleted on exit of the function. Copy the
-    // payload to |response_strings_|.
-    if (response) {
-      MessageReader reader(response);
-      std::string response_string;
-      ASSERT_TRUE(reader.PopString(&response_string));
-      response_strings_.push_back(response_string);
-    } else {
-      response_strings_.push_back(std::string());
-    }
-    run_loop_->Quit();
   }
 
   // Wait for the given number of errors.
   void WaitForErrors(size_t num_errors) {
-    while (error_names_.size() < num_errors) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
   }
 
   // Called when an error is received.
   void OnError(ErrorResponse* error) {
-    // |error| will be deleted on exit of the function. Copy the payload to
-    // |error_names_|.
-    if (error) {
-      ASSERT_NE("", error->GetErrorName());
-      error_names_.push_back(error->GetErrorName());
-    } else {
-      error_names_.push_back(std::string());
-    }
-    run_loop_->Quit();
   }
 
   // Called when the "Test" signal is received, in the main thread.
   // Copy the string payload to |test_signal_string_|.
   void OnTestSignal(Signal* signal) {
-    MessageReader reader(signal);
-    ASSERT_TRUE(reader.PopString(&test_signal_string_));
-    run_loop_->Quit();
   }
 
   // Called when the "Test" signal is received, in the main thread, by
   // the root object proxy. Copy the string payload to
   // |root_test_signal_string_|.
   void OnRootTestSignal(Signal* signal) {
-    MessageReader reader(signal);
-    ASSERT_TRUE(reader.PopString(&root_test_signal_string_));
-    run_loop_->Quit();
   }
 
   // Called when the "Test2" signal is received, in the main thread.
   void OnTest2Signal(Signal* signal) {
-    MessageReader reader(signal);
-    run_loop_->Quit();
   }
 
   // Called when connected to the signal.
   void OnConnected(const std::string& interface_name,
                    const std::string& signal_name,
                    bool success) {
-    ASSERT_TRUE(success);
-    run_loop_->Quit();
   }
 
   // Wait for the hey signal to be received.
   void WaitForTestSignal() {
     // OnTestSignal() will quit the message loop.
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
   }
 
   base::test::SingleThreadTaskEnvironment task_environment_;
@@ -266,374 +120,27 @@
   std::string root_test_signal_string_;
 };
 
-TEST_F(EndToEndAsyncTest, Echo) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-
-  // Check the response.
-  WaitForResponses(1);
-  EXPECT_EQ(kHello, response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, EchoWithErrorCallback) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-
-  // Check the response.
-  WaitForResponses(1);
-  EXPECT_EQ(kHello, response_strings_[0]);
-  EXPECT_TRUE(error_names_.empty());
-}
-
-// Call Echo method three times.
-TEST_F(EndToEndAsyncTest, EchoThreeTimes) {
-  const char* kMessages[] = { "foo", "bar", "baz" };
-
-  for (size_t i = 0; i < base::size(kMessages); ++i) {
-    // Create the method call.
-    MethodCall method_call("org.chromium.TestInterface", "Echo");
-    MessageWriter writer(&method_call);
-    writer.AppendString(kMessages[i]);
-
-    // Call the method.
-    const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-    CallMethod(&method_call, timeout_ms);
-  }
-
-  // Check the responses.
-  WaitForResponses(3);
-  // Sort as the order of the returned messages is not deterministic.
-  std::sort(response_strings_.begin(), response_strings_.end());
-  EXPECT_EQ("bar", response_strings_[0]);
-  EXPECT_EQ("baz", response_strings_[1]);
-  EXPECT_EQ("foo", response_strings_[2]);
-}
-
-TEST_F(EndToEndAsyncTest, Echo_HugePayload) {
-  const std::string kHugePayload(kHugePayloadSize, 'o');
-
-  // Create the method call with a huge payload.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHugePayload);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-
-  // This caused a DCHECK failure before. Ensure that the issue is fixed.
-  WaitForResponses(1);
-  EXPECT_EQ(kHugePayload, response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, BrokenBus) {
-  const char* kHello = "hello";
-
-  // Set up a broken bus.
-  SetUpBrokenBus();
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-  WaitForResponses(1);
-
-  // Should fail because of the broken bus.
-  ASSERT_EQ("", response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, BrokenBusWithErrorCallback) {
-  const char* kHello = "hello";
-
-  // Set up a broken bus.
-  SetUpBrokenBus();
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-  WaitForErrors(1);
-
-  // Should fail because of the broken bus.
-  ASSERT_TRUE(response_strings_.empty());
-  ASSERT_EQ("", error_names_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, Timeout) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "SlowEcho");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method with timeout of 0ms.
-  const int timeout_ms = 0;
-  CallMethod(&method_call, timeout_ms);
-  WaitForResponses(1);
-
-  // Should fail because of timeout.
-  ASSERT_EQ("", response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, TimeoutWithErrorCallback) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "SlowEcho");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method with timeout of 0ms.
-  const int timeout_ms = 0;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-  WaitForErrors(1);
-
-  // Should fail because of timeout.
-  ASSERT_TRUE(response_strings_.empty());
-  ASSERT_EQ(DBUS_ERROR_NO_REPLY, error_names_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, CancelPendingCalls) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-
-  // Remove the object proxy before receiving the result.
-  // This results in cancelling the pending method call.
-  bus_->RemoveObjectProxy(test_service_->service_name(),
-                          ObjectPath("/org/chromium/TestObject"),
-                          base::DoNothing());
-
-  // We shouldn't receive any responses. Wait for a while just to make sure.
-  run_loop_.reset(new base::RunLoop);
-  task_environment_.GetMainThreadTaskRunner()->PostDelayedTask(
-      FROM_HERE, run_loop_->QuitClosure(), TestTimeouts::tiny_timeout());
-  run_loop_->Run();
-  EXPECT_TRUE(response_strings_.empty());
-}
-
-// Tests calling a method that sends its reply asynchronously.
-TEST_F(EndToEndAsyncTest, AsyncEcho) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "AsyncEcho");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-
-  // Check the response.
-  WaitForResponses(1);
-  EXPECT_EQ(kHello, response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, NonexistentMethod) {
-  MethodCall method_call("org.chromium.TestInterface", "Nonexistent");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-  WaitForResponses(1);
-
-  // Should fail because the method is nonexistent.
-  ASSERT_EQ("", response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, NonexistentMethodWithErrorCallback) {
-  MethodCall method_call("org.chromium.TestInterface", "Nonexistent");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-  WaitForErrors(1);
-
-  // Should fail because the method is nonexistent.
-  ASSERT_TRUE(response_strings_.empty());
-  ASSERT_EQ(DBUS_ERROR_UNKNOWN_METHOD, error_names_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, BrokenMethod) {
-  MethodCall method_call("org.chromium.TestInterface", "BrokenMethod");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethod(&method_call, timeout_ms);
-  WaitForResponses(1);
-
-  // Should fail because the method is broken.
-  ASSERT_EQ("", response_strings_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, BrokenMethodWithErrorCallback) {
-  MethodCall method_call("org.chromium.TestInterface", "BrokenMethod");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-  WaitForErrors(1);
-
-  // Should fail because the method is broken.
-  ASSERT_TRUE(response_strings_.empty());
-  ASSERT_EQ(DBUS_ERROR_FAILED, error_names_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, InvalidServiceName) {
-  // Bus name cannot contain '/'.
-  const std::string invalid_service_name = ":1/2";
-
-  // Replace object proxy with new one.
-  object_proxy_ = bus_->GetObjectProxy(invalid_service_name,
-                                       ObjectPath("/org/chromium/TestObject"));
-
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  CallMethodWithErrorCallback(&method_call, timeout_ms);
-  WaitForErrors(1);
-
-  // Should fail because of the invalid bus name.
-  ASSERT_TRUE(response_strings_.empty());
-  ASSERT_EQ("", error_names_[0]);
-}
-
-TEST_F(EndToEndAsyncTest, EmptyResponseCallback) {
-  const char* kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method with an empty callback.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  object_proxy_->CallMethod(&method_call, timeout_ms, base::DoNothing());
-  // Post a delayed task to quit the RunLoop.
-  run_loop_.reset(new base::RunLoop);
-  task_environment_.GetMainThreadTaskRunner()->PostDelayedTask(
-      FROM_HERE, run_loop_->QuitClosure(), TestTimeouts::tiny_timeout());
-  run_loop_->Run();
-  // We cannot tell if the empty callback is called, but at least we can
-  // check if the test does not crash.
-}
-
-TEST_F(EndToEndAsyncTest, TestSignal) {
-  const char kMessage[] = "hello, world";
-  // Send the test signal from the exported object.
-  test_service_->SendTestSignal(kMessage);
-  // Receive the signal with the object proxy. The signal is handled in
-  // EndToEndAsyncTest::OnTestSignal() in the main thread.
-  WaitForTestSignal();
-  ASSERT_EQ(kMessage, test_signal_string_);
-}
-
-TEST_F(EndToEndAsyncTest, TestSignalFromRoot) {
-  const char kMessage[] = "hello, world";
-  // Object proxies are tied to a particular object path, if a signal
-  // arrives from a different object path like "/" the first object proxy
-  // |object_proxy_| should not handle it, and should leave it for the root
-  // object proxy |root_object_proxy_|.
-  test_service_->SendTestSignalFromRoot(kMessage);
-  WaitForTestSignal();
-  // Verify the signal was not received by the specific proxy.
-  ASSERT_TRUE(test_signal_string_.empty());
-  // Verify the string WAS received by the root proxy.
-  ASSERT_EQ(kMessage, root_test_signal_string_);
-}
-
-TEST_F(EndToEndAsyncTest, TestHugeSignal) {
-  const std::string kHugeMessage(kHugePayloadSize, 'o');
-
-  // Send the huge signal from the exported object.
-  test_service_->SendTestSignal(kHugeMessage);
-  // This caused a DCHECK failure before. Ensure that the issue is fixed.
-  WaitForTestSignal();
-  ASSERT_EQ(kHugeMessage, test_signal_string_);
-}
-
 class SignalMultipleHandlerTest : public EndToEndAsyncTest {
  public:
   SignalMultipleHandlerTest() = default;
 
   void SetUp() override {
-    // Set up base class.
-    EndToEndAsyncTest::SetUp();
-
-    // Connect the root object proxy's signal handler to a new handler
-    // so that we can verify that a second call to ConnectSignal() delivers
-    // to both our new handler and the old.
-    object_proxy_->ConnectToSignal(
-        "org.chromium.TestInterface", "Test",
-        base::BindRepeating(&SignalMultipleHandlerTest::OnAdditionalTestSignal,
-                            base::Unretained(this)),
-        base::BindOnce(&SignalMultipleHandlerTest::OnAdditionalConnected,
-                       base::Unretained(this)));
-    // Wait until the object proxy is connected to the signal.
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
   }
 
  protected:
   // Called when the "Test" signal is received, in the main thread.
   // Copy the string payload to |additional_test_signal_string_|.
   void OnAdditionalTestSignal(Signal* signal) {
-    MessageReader reader(signal);
-    ASSERT_TRUE(reader.PopString(&additional_test_signal_string_));
-    run_loop_->Quit();
   }
 
   // Called when connected to the signal.
   void OnAdditionalConnected(const std::string& interface_name,
                              const std::string& signal_name,
                              bool success) {
-    ASSERT_TRUE(success);
-    run_loop_->Quit();
   }
 
   // Text message from "Test" signal delivered to additional handler.
   std::string additional_test_signal_string_;
 };
 
-TEST_F(SignalMultipleHandlerTest, TestMultipleHandlers) {
-  const char kMessage[] = "hello, world";
-  // Send the test signal from the exported object.
-  test_service_->SendTestSignal(kMessage);
-  // Receive the signal with the object proxy.
-  WaitForTestSignal();
-  // Verify the string WAS received by the original handler.
-  ASSERT_EQ(kMessage, test_signal_string_);
-  // Verify the signal WAS ALSO received by the additional handler.
-  ASSERT_EQ(kMessage, additional_test_signal_string_);
-}
-
 }  // namespace dbus
diff -u a/dbus/end_to_end_sync_unittest.cc b/dbus/end_to_end_sync_unittest.cc
--- a/dbus/end_to_end_sync_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/end_to_end_sync_unittest.cc	2020-06-09 18:42:59.729773733 +0200
@@ -22,28 +22,9 @@
   EndToEndSyncTest() = default;
 
   void SetUp() override {
-    // Start the test service;
-    TestService::Options options;
-    test_service_.reset(new TestService(options));
-    ASSERT_TRUE(test_service_->StartService());
-    test_service_->WaitUntilServiceIsStarted();
-    ASSERT_FALSE(test_service_->HasDBusThread());
-
-    // Create the client.
-    Bus::Options client_bus_options;
-    client_bus_options.bus_type = Bus::SESSION;
-    client_bus_options.connection_type = Bus::PRIVATE;
-    client_bus_ = new Bus(client_bus_options);
-    object_proxy_ = client_bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
-    ASSERT_FALSE(client_bus_->HasDBusThread());
   }
 
   void TearDown() override {
-    test_service_->ShutdownAndBlock();
-    test_service_->Stop();
-    client_bus_->ShutdownAndBlock();
   }
 
  protected:
@@ -52,75 +33,4 @@
   ObjectProxy* object_proxy_;
 };
 
-TEST_F(EndToEndSyncTest, Echo) {
-  const std::string kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  std::unique_ptr<Response> response(
-      object_proxy_->CallMethodAndBlock(&method_call, timeout_ms));
-  ASSERT_TRUE(response.get());
-
-  // Check the response. kHello should be echoed back.
-  MessageReader reader(response.get());
-  std::string returned_message;
-  ASSERT_TRUE(reader.PopString(&returned_message));
-  EXPECT_EQ(kHello, returned_message);
-}
-
-TEST_F(EndToEndSyncTest, Timeout) {
-  const std::string kHello = "hello";
-
-  // Create the method call.
-  MethodCall method_call("org.chromium.TestInterface", "DelayedEcho");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method with timeout of 0ms.
-  const int timeout_ms = 0;
-  std::unique_ptr<Response> response(
-      object_proxy_->CallMethodAndBlock(&method_call, timeout_ms));
-  // Should fail because of timeout.
-  ASSERT_FALSE(response.get());
-}
-
-TEST_F(EndToEndSyncTest, NonexistentMethod) {
-  MethodCall method_call("org.chromium.TestInterface", "Nonexistent");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  std::unique_ptr<Response> response(
-      object_proxy_->CallMethodAndBlock(&method_call, timeout_ms));
-  ASSERT_FALSE(response.get());
-}
-
-TEST_F(EndToEndSyncTest, BrokenMethod) {
-  MethodCall method_call("org.chromium.TestInterface", "BrokenMethod");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  std::unique_ptr<Response> response(
-      object_proxy_->CallMethodAndBlock(&method_call, timeout_ms));
-  ASSERT_FALSE(response.get());
-}
-
-TEST_F(EndToEndSyncTest, InvalidServiceName) {
-  // Bus name cannot contain '/'.
-  const std::string invalid_service_name = ":1/2";
-
-  // Replace object proxy with new one.
-  object_proxy_ = client_bus_->GetObjectProxy(
-      invalid_service_name, ObjectPath("/org/chromium/TestObject"));
-
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-
-  const int timeout_ms = ObjectProxy::TIMEOUT_USE_DEFAULT;
-  std::unique_ptr<Response> response(
-      object_proxy_->CallMethodAndBlock(&method_call, timeout_ms));
-  ASSERT_FALSE(response.get());
-}
-
 }  // namespace dbus
diff -u a/dbus/exported_object.cc b/dbus/exported_object.cc
--- a/dbus/exported_object.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/exported_object.cc	2020-06-09 17:42:56.724085790 +0200
@@ -35,54 +35,20 @@
     : bus_(bus),
       object_path_(object_path),
       object_is_registered_(false) {
-  LOG_IF(FATAL, !object_path_.IsValid()) << object_path_.value();
 }
 
 ExportedObject::~ExportedObject() {
-  DCHECK(!object_is_registered_);
 }
 
 bool ExportedObject::ExportMethodAndBlock(
     const std::string& interface_name,
     const std::string& method_name,
     const MethodCallCallback& method_call_callback) {
-  bus_->AssertOnDBusThread();
-
-  // Check if the method is already exported.
-  const std::string absolute_method_name =
-      GetAbsoluteMemberName(interface_name, method_name);
-  if (method_table_.find(absolute_method_name) != method_table_.end()) {
-    LOG(ERROR) << absolute_method_name << " is already exported";
-    return false;
-  }
-
-  if (!bus_->Connect())
-    return false;
-  if (!bus_->SetUpAsyncOperations())
-    return false;
-  if (!Register())
-    return false;
-
-  // Add the method callback to the method table.
-  method_table_[absolute_method_name] = method_call_callback;
-
   return true;
 }
 
 bool ExportedObject::UnexportMethodAndBlock(const std::string& interface_name,
                                             const std::string& method_name) {
-  bus_->AssertOnDBusThread();
-
-  const std::string absolute_method_name =
-      GetAbsoluteMemberName(interface_name, method_name);
-  MethodTable::const_iterator iter = method_table_.find(absolute_method_name);
-  if (iter == method_table_.end()) {
-    LOG(ERROR) << absolute_method_name << " is not exported";
-    return false;
-  }
-
-  method_table_.erase(iter);
-
   return true;
 }
 
@@ -91,60 +57,18 @@
     const std::string& method_name,
     const MethodCallCallback& method_call_callback,
     OnExportedCallback on_exported_callback) {
-  bus_->AssertOnOriginThread();
-
-  base::OnceClosure task = base::BindOnce(
-      &ExportedObject::ExportMethodInternal, this, interface_name, method_name,
-      method_call_callback, std::move(on_exported_callback));
-  bus_->GetDBusTaskRunner()->PostTask(FROM_HERE, std::move(task));
 }
 
 void ExportedObject::UnexportMethod(
     const std::string& interface_name,
     const std::string& method_name,
     OnUnexportedCallback on_unexported_callback) {
-  bus_->AssertOnOriginThread();
-
-  base::OnceClosure task = base::BindOnce(
-      &ExportedObject::UnexportMethodInternal, this, interface_name,
-      method_name, std::move(on_unexported_callback));
-  bus_->GetDBusTaskRunner()->PostTask(FROM_HERE, std::move(task));
 }
 
 void ExportedObject::SendSignal(Signal* signal) {
-  // For signals, the object path should be set to the path to the sender
-  // object, which is this exported object here.
-  CHECK(signal->SetPath(object_path_));
-
-  // Increment the reference count so we can safely reference the
-  // underlying signal message until the signal sending is complete. This
-  // will be unref'ed in SendSignalInternal().
-  DBusMessage* signal_message = signal->raw_message();
-  dbus_message_ref(signal_message);
-
-  const base::TimeTicks start_time = base::TimeTicks::Now();
-  if (bus_->GetDBusTaskRunner()->RunsTasksInCurrentSequence()) {
-    // The Chrome OS power manager doesn't use a dedicated TaskRunner for
-    // sending DBus messages.  Sending signals asynchronously can cause an
-    // inversion in the message order if the power manager calls
-    // ObjectProxy::CallMethodAndBlock() before going back to the top level of
-    // the MessageLoop: crbug.com/472361.
-    SendSignalInternal(start_time, signal_message);
-  } else {
-    bus_->GetDBusTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ExportedObject::SendSignalInternal, this,
-                                  start_time, signal_message));
-  }
 }
 
 void ExportedObject::Unregister() {
-  bus_->AssertOnDBusThread();
-
-  if (!object_is_registered_)
-    return;
-
-  bus_->UnregisterObjectPath(object_path_);
-  object_is_registered_ = false;
 }
 
 void ExportedObject::ExportMethodInternal(
@@ -152,209 +76,65 @@
     const std::string& method_name,
     const MethodCallCallback& method_call_callback,
     OnExportedCallback on_exported_callback) {
-  bus_->AssertOnDBusThread();
-
-  const bool success = ExportMethodAndBlock(interface_name,
-                                            method_name,
-                                            method_call_callback);
-  bus_->GetOriginTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&ExportedObject::OnExported, this,
-                                std::move(on_exported_callback), interface_name,
-                                method_name, success));
 }
 
 void ExportedObject::UnexportMethodInternal(
     const std::string& interface_name,
     const std::string& method_name,
     OnUnexportedCallback on_unexported_callback) {
-  bus_->AssertOnDBusThread();
-
-  const bool success = UnexportMethodAndBlock(interface_name, method_name);
-  bus_->GetOriginTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&ExportedObject::OnUnexported, this,
-                                std::move(on_unexported_callback),
-                                interface_name, method_name, success));
 }
 
 void ExportedObject::OnExported(OnExportedCallback on_exported_callback,
                                 const std::string& interface_name,
                                 const std::string& method_name,
                                 bool success) {
-  bus_->AssertOnOriginThread();
-
-  std::move(on_exported_callback).Run(interface_name, method_name, success);
 }
 
 void ExportedObject::OnUnexported(OnExportedCallback on_unexported_callback,
                                   const std::string& interface_name,
                                   const std::string& method_name,
                                   bool success) {
-  bus_->AssertOnOriginThread();
-
-  std::move(on_unexported_callback).Run(interface_name, method_name, success);
 }
 
 void ExportedObject::SendSignalInternal(base::TimeTicks start_time,
-                                        DBusMessage* signal_message) {
-  uint32_t serial = 0;
-  bus_->Send(signal_message, &serial);
-  dbus_message_unref(signal_message);
-  // Record time spent to send the the signal. This is not accurate as the
-  // signal will actually be sent from the next run of the message loop,
-  // but we can at least tell the number of signals sent.
-  UMA_HISTOGRAM_TIMES("DBus.SignalSendTime",
-                      base::TimeTicks::Now() - start_time);
+                                        const void* signal_message) {
 }
 
 bool ExportedObject::Register() {
-  bus_->AssertOnDBusThread();
-
-  if (object_is_registered_)
-    return true;
-
-  ScopedDBusError error;
-
-  DBusObjectPathVTable vtable = {};
-  vtable.message_function = &ExportedObject::HandleMessageThunk;
-  vtable.unregister_function = &ExportedObject::OnUnregisteredThunk;
-  const bool success = bus_->TryRegisterObjectPath(object_path_,
-                                                   &vtable,
-                                                   this,
-                                                   error.get());
-  if (!success) {
-    LOG(ERROR) << "Failed to register the object: " << object_path_.value()
-               << ": " << (error.is_set() ? error.message() : "");
-    return false;
-  }
-
-  object_is_registered_ = true;
   return true;
 }
 
-DBusHandlerResult ExportedObject::HandleMessage(
-    DBusConnection* connection,
-    DBusMessage* raw_message) {
-  bus_->AssertOnDBusThread();
-  // ExportedObject only handles method calls. Ignore other message types (e.g.
-  // signal).
-  if (dbus_message_get_type(raw_message) != DBUS_MESSAGE_TYPE_METHOD_CALL)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  // raw_message will be unrefed on exit of the function. Increment the
-  // reference so we can use it in MethodCall.
-  dbus_message_ref(raw_message);
-  std::unique_ptr<MethodCall> method_call(
-      MethodCall::FromRawMessage(raw_message));
-  const std::string interface = method_call->GetInterface();
-  const std::string member = method_call->GetMember();
-
-  if (interface.empty()) {
-    // We don't support method calls without interface.
-    LOG(WARNING) << "Interface is missing: " << method_call->ToString();
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
-
-  // Check if we know about the method.
-  const std::string absolute_method_name = GetAbsoluteMemberName(
-      interface, member);
-  MethodTable::const_iterator iter = method_table_.find(absolute_method_name);
-  if (iter == method_table_.end()) {
-    // Don't know about the method.
-    LOG(WARNING) << "Unknown method: " << method_call->ToString();
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
-
-  const base::TimeTicks start_time = base::TimeTicks::Now();
-  if (bus_->HasDBusThread()) {
-    // Post a task to run the method in the origin thread.
-    bus_->GetOriginTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&ExportedObject::RunMethod, this, iter->second,
-                       std::move(method_call), start_time));
-  } else {
-    // If the D-Bus thread is not used, just call the method directly.
-    MethodCall* method = method_call.get();
-    iter->second.Run(
-        method, base::BindOnce(&ExportedObject::SendResponse, this, start_time,
-                               std::move(method_call)));
-  }
-
-  // It's valid to say HANDLED here, and send a method response at a later
-  // time from OnMethodCompleted() asynchronously.
-  return DBUS_HANDLER_RESULT_HANDLED;
+void ExportedObject::HandleMessage(
+    const void* connection,
+    const void* raw_message) {
 }
 
 void ExportedObject::RunMethod(const MethodCallCallback& method_call_callback,
                                std::unique_ptr<MethodCall> method_call,
                                base::TimeTicks start_time) {
-  bus_->AssertOnOriginThread();
-  MethodCall* method = method_call.get();
-  method_call_callback.Run(
-      method, base::BindOnce(&ExportedObject::SendResponse, this, start_time,
-                             std::move(method_call)));
 }
 
 void ExportedObject::SendResponse(base::TimeTicks start_time,
                                   std::unique_ptr<MethodCall> method_call,
                                   std::unique_ptr<Response> response) {
-  DCHECK(method_call);
-  if (bus_->HasDBusThread()) {
-    bus_->GetDBusTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ExportedObject::OnMethodCompleted, this,
-                                  std::move(method_call), std::move(response),
-                                  start_time));
-  } else {
-    OnMethodCompleted(std::move(method_call), std::move(response), start_time);
-  }
 }
 
 void ExportedObject::OnMethodCompleted(std::unique_ptr<MethodCall> method_call,
                                        std::unique_ptr<Response> response,
                                        base::TimeTicks start_time) {
-  bus_->AssertOnDBusThread();
-
-  // Record if the method call is successful, or not. 1 if successful.
-  UMA_HISTOGRAM_ENUMERATION("DBus.ExportedMethodHandleSuccess",
-                            response ? 1 : 0,
-                            kSuccessRatioHistogramMaxValue);
-
-  // Check if the bus is still connected. If the method takes long to
-  // complete, the bus may be shut down meanwhile.
-  if (!bus_->IsConnected())
-    return;
-
-  if (!response) {
-    // Something bad happened in the method call.
-    std::unique_ptr<ErrorResponse> error_response(ErrorResponse::FromMethodCall(
-        method_call.get(), DBUS_ERROR_FAILED,
-        "error occurred in " + method_call->GetMember()));
-    bus_->Send(error_response->raw_message(), nullptr);
-    return;
-  }
-
-  // The method call was successful.
-  bus_->Send(response->raw_message(), nullptr);
-
-  // Record time spent to handle the the method call. Don't include failures.
-  UMA_HISTOGRAM_TIMES("DBus.ExportedMethodHandleTime",
-                      base::TimeTicks::Now() - start_time);
 }
 
-void ExportedObject::OnUnregistered(DBusConnection* connection) {
+void ExportedObject::OnUnregistered(const void* connection) {
 }
 
-DBusHandlerResult ExportedObject::HandleMessageThunk(
-    DBusConnection* connection,
-    DBusMessage* raw_message,
+void ExportedObject::HandleMessageThunk(
+    const void* connection,
+    const void* raw_message,
     void* user_data) {
-  ExportedObject* self = reinterpret_cast<ExportedObject*>(user_data);
-  return self->HandleMessage(connection, raw_message);
 }
 
-void ExportedObject::OnUnregisteredThunk(DBusConnection *connection,
+void ExportedObject::OnUnregisteredThunk(const void *connection,
                                          void* user_data) {
-  ExportedObject* self = reinterpret_cast<ExportedObject*>(user_data);
-  return self->OnUnregistered(connection);
 }
 
 }  // namespace dbus
diff -u a/dbus/exported_object.h b/dbus/exported_object.h
--- a/dbus/exported_object.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/exported_object.h	2020-06-09 17:44:54.556989603 +0200
@@ -5,8 +5,6 @@
 #ifndef DBUS_EXPORTED_OBJECT_H_
 #define DBUS_EXPORTED_OBJECT_H_
 
-#include <dbus/dbus.h>
-
 #include <map>
 #include <memory>
 #include <string>
@@ -161,7 +159,7 @@
 
   // Helper function for SendSignal().
   void SendSignalInternal(base::TimeTicks start_time,
-                          DBusMessage* signal_message);
+                          const void* signal_message);
 
   // Registers this object to the bus.
   // Returns true on success, or the object is already registered.
@@ -171,8 +169,8 @@
 
   // Handles the incoming request messages and dispatches to the exported
   // methods.
-  DBusHandlerResult HandleMessage(DBusConnection* connection,
-                                  DBusMessage* raw_message);
+  void HandleMessage(const void* connection,
+                                  const void* raw_message);
 
   // Runs the method. Helper function for HandleMessage().
   void RunMethod(const MethodCallCallback& method_call_callback,
@@ -193,15 +191,15 @@
                          base::TimeTicks start_time);
 
   // Called when the object is unregistered.
-  void OnUnregistered(DBusConnection* connection);
+  void OnUnregistered(const void* connection);
 
   // Redirects the function call to HandleMessage().
-  static DBusHandlerResult HandleMessageThunk(DBusConnection* connection,
-                                              DBusMessage* raw_message,
+  static void HandleMessageThunk(const void* connection,
+                                              const void* raw_message,
                                               void* user_data);
 
   // Redirects the function call to OnUnregistered().
-  static void OnUnregisteredThunk(DBusConnection* connection,
+  static void OnUnregisteredThunk(const void* connection,
                                   void* user_data);
 
   scoped_refptr<Bus> bus_;
diff -u a/dbus/message.cc b/dbus/message.cc
--- a/dbus/message.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/message.cc	2020-06-09 18:51:54.273459835 +0200
@@ -42,323 +42,100 @@
 namespace dbus {
 
 bool IsDBusTypeUnixFdSupported() {
-  int major = 0, minor = 0, micro = 0;
-  dbus_get_version(&major, &minor, &micro);
-  return major >= 1 && minor >= 4;
+  return true;
 }
 
 Message::Message() : raw_message_(nullptr) {}
 
 Message::~Message() {
-  if (raw_message_)
-    dbus_message_unref(raw_message_);
 }
 
-void Message::Init(DBusMessage* raw_message) {
-  DCHECK(!raw_message_);
-  raw_message_ = raw_message;
+void Message::Init(const void* raw_message) {
+  raw_message_ = nullptr;
 }
 
 Message::MessageType Message::GetMessageType() {
-  if (!raw_message_)
-    return MESSAGE_INVALID;
-  const int type = dbus_message_get_type(raw_message_);
+  const int type = 0;
   return static_cast<Message::MessageType>(type);
 }
 
 std::string Message::GetMessageTypeAsString() {
-  switch (GetMessageType()) {
-    case MESSAGE_INVALID:
-      return "MESSAGE_INVALID";
-    case MESSAGE_METHOD_CALL:
-      return "MESSAGE_METHOD_CALL";
-    case MESSAGE_METHOD_RETURN:
-      return "MESSAGE_METHOD_RETURN";
-    case MESSAGE_SIGNAL:
-      return "MESSAGE_SIGNAL";
-    case MESSAGE_ERROR:
-      return "MESSAGE_ERROR";
-  }
-  NOTREACHED();
-  return std::string();
+  return "MESSAGE_INVALID";
 }
 
 std::string Message::ToStringInternal(const std::string& indent,
                                       MessageReader* reader) {
-  const char* kBrokenMessage = "[broken message]";
-  std::string output;
-  while (reader->HasMoreData()) {
-    const DataType type = reader->GetDataType();
-    switch (type) {
-      case BYTE: {
-        uint8_t value = 0;
-        if (!reader->PopByte(&value))
-          return kBrokenMessage;
-        output += indent + "byte " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case BOOL: {
-        bool value = false;
-        if (!reader->PopBool(&value))
-          return kBrokenMessage;
-        output += indent + "bool " + (value ? "true" : "false") + "\n";
-        break;
-      }
-      case INT16: {
-        int16_t value = 0;
-        if (!reader->PopInt16(&value))
-          return kBrokenMessage;
-        output += indent + "int16_t " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case UINT16: {
-        uint16_t value = 0;
-        if (!reader->PopUint16(&value))
-          return kBrokenMessage;
-        output += indent + "uint16_t " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case INT32: {
-        int32_t value = 0;
-        if (!reader->PopInt32(&value))
-          return kBrokenMessage;
-        output += indent + "int32_t " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case UINT32: {
-        uint32_t value = 0;
-        if (!reader->PopUint32(&value))
-          return kBrokenMessage;
-        output += indent + "uint32_t " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case INT64: {
-        int64_t value = 0;
-        if (!reader->PopInt64(&value))
-          return kBrokenMessage;
-        output += (indent + "int64_t " + base::NumberToString(value) + "\n");
-        break;
-      }
-      case UINT64: {
-        uint64_t value = 0;
-        if (!reader->PopUint64(&value))
-          return kBrokenMessage;
-        output += (indent + "uint64_t " + base::NumberToString(value) + "\n");
-        break;
-      }
-      case DOUBLE: {
-        double value = 0;
-        if (!reader->PopDouble(&value))
-          return kBrokenMessage;
-        output += indent + "double " + base::NumberToString(value) + "\n";
-        break;
-      }
-      case STRING: {
-        std::string value;
-        if (!reader->PopString(&value))
-          return kBrokenMessage;
-        // Truncate if the string is longer than the limit.
-        const size_t kTruncateLength = 100;
-        if (value.size() < kTruncateLength) {
-          output += indent + "string \"" + value + "\"\n";
-        } else {
-          std::string truncated;
-          base::TruncateUTF8ToByteSize(value, kTruncateLength, &truncated);
-          base::StringAppendF(&truncated, "... (%" PRIuS " bytes in total)",
-                              value.size());
-          output += indent + "string \"" + truncated + "\"\n";
-        }
-        break;
-      }
-      case OBJECT_PATH: {
-        ObjectPath value;
-        if (!reader->PopObjectPath(&value))
-          return kBrokenMessage;
-        output += indent + "object_path \"" + value.value() + "\"\n";
-        break;
-      }
-      case ARRAY: {
-        MessageReader sub_reader(this);
-        if (!reader->PopArray(&sub_reader))
-          return kBrokenMessage;
-        output += indent + "array [\n";
-        output += ToStringInternal(indent + "  ", &sub_reader);
-        output += indent + "]\n";
-        break;
-      }
-      case STRUCT: {
-        MessageReader sub_reader(this);
-        if (!reader->PopStruct(&sub_reader))
-          return kBrokenMessage;
-        output += indent + "struct {\n";
-        output += ToStringInternal(indent + "  ", &sub_reader);
-        output += indent + "}\n";
-        break;
-      }
-      case DICT_ENTRY: {
-        MessageReader sub_reader(this);
-        if (!reader->PopDictEntry(&sub_reader))
-          return kBrokenMessage;
-        output += indent + "dict entry {\n";
-        output += ToStringInternal(indent + "  ", &sub_reader);
-        output += indent + "}\n";
-        break;
-      }
-      case VARIANT: {
-        MessageReader sub_reader(this);
-        if (!reader->PopVariant(&sub_reader))
-          return kBrokenMessage;
-        output += indent + "variant ";
-        output += ToStringInternal(indent + "  ", &sub_reader);
-        break;
-      }
-      case UNIX_FD: {
-        CHECK(IsDBusTypeUnixFdSupported());
-
-        base::ScopedFD file_descriptor;
-        if (!reader->PopFileDescriptor(&file_descriptor))
-          return kBrokenMessage;
-        output +=
-            indent + "fd#" + base::NumberToString(file_descriptor.get()) + "\n";
-        break;
-      }
-      default:
-        LOG(FATAL) << "Unknown type: " << type;
-    }
-  }
-  return output;
-}
-
-// The returned string consists of message headers such as
-// destination if any, followed by a blank line, and the message
-// payload. For example, a MethodCall's ToString() will look like:
-//
-// destination: com.example.Service
-// path: /com/example/Object
-// interface: com.example.Interface
-// member: SomeMethod
-//
-// string \"payload\"
-// ...
-std::string Message::ToString() {
-  if (!raw_message_)
-    return std::string();
+  return "";
+}
 
-  // Generate headers first.
-  std::string headers;
-  AppendStringHeader("message_type", GetMessageTypeAsString(), &headers);
-  AppendStringHeader("destination", GetDestination(), &headers);
-  AppendStringHeader("path", GetPath().value(), &headers);
-  AppendStringHeader("interface", GetInterface(), &headers);
-  AppendStringHeader("member", GetMember(), &headers);
-  AppendStringHeader("error_name", GetErrorName(), &headers);
-  AppendStringHeader("sender", GetSender(), &headers);
-  AppendStringHeader("signature", GetSignature(), &headers);
-  AppendUint32Header("serial", GetSerial(), &headers);
-  AppendUint32Header("reply_serial", GetReplySerial(), &headers);
-
-  // Generate the payload.
-  MessageReader reader(this);
-  return headers + "\n" + ToStringInternal(std::string(), &reader);
+std::string Message::ToString() {
+  return "";
 }
 
 bool Message::SetDestination(const std::string& destination) {
-  if (!dbus_validate_bus_name(destination.c_str(), nullptr)) {
-    LOG(ERROR) << "Invalid bus name: " << destination;
-    return false;
-  }
-  return dbus_message_set_destination(raw_message_, destination.c_str());
+  return true;
 }
 
 bool Message::SetPath(const ObjectPath& path) {
-  if (!path.IsValid()) {
-    LOG(ERROR) << "Invalid path: " << path.value();
-    return false;
-  }
-  return dbus_message_set_path(raw_message_, path.value().c_str());
+  return true;
 }
 
 bool Message::SetInterface(const std::string& interface) {
-  if (!dbus_validate_interface(interface.c_str(), nullptr)) {
-    LOG(ERROR) << "Invalid interface: " << interface;
-    return false;
-  }
-  return dbus_message_set_interface(raw_message_, interface.c_str());
+  return true;
 }
 
 bool Message::SetMember(const std::string& member) {
-  if (!dbus_validate_member(member.c_str(), nullptr)) {
-    LOG(ERROR) << "Invalid member: " << member;
-    return false;
-  }
-  return dbus_message_set_member(raw_message_, member.c_str());
+  return true;
 }
 
 bool Message::SetErrorName(const std::string& error_name) {
-  if (!dbus_validate_error_name(error_name.c_str(), nullptr)) {
-    LOG(ERROR) << "Invalid error name: " << error_name;
-    return false;
-  }
-  return dbus_message_set_error_name(raw_message_, error_name.c_str());
+  return true;
 }
 
 bool Message::SetSender(const std::string& sender) {
-  if (!dbus_validate_bus_name(sender.c_str(), nullptr)) {
-    LOG(ERROR) << "Invalid bus name: " << sender;
-    return false;
-  }
-  return dbus_message_set_sender(raw_message_, sender.c_str());
+  return true;
 }
 
 void Message::SetSerial(uint32_t serial) {
-  dbus_message_set_serial(raw_message_, serial);
 }
 
 void Message::SetReplySerial(uint32_t reply_serial) {
-  dbus_message_set_reply_serial(raw_message_, reply_serial);
 }
 
 std::string Message::GetDestination() {
-  const char* destination = dbus_message_get_destination(raw_message_);
-  return destination ? destination : "";
+  return "";
 }
 
 ObjectPath Message::GetPath() {
-  const char* path = dbus_message_get_path(raw_message_);
-  return ObjectPath(path ? path : "");
+  return ObjectPath("");
 }
 
 std::string Message::GetInterface() {
-  const char* interface = dbus_message_get_interface(raw_message_);
-  return interface ? interface : "";
+  return "";
 }
 
 std::string Message::GetMember() {
-  const char* member = dbus_message_get_member(raw_message_);
-  return member ? member : "";
+  return "";
 }
 
 std::string Message::GetErrorName() {
-  const char* error_name = dbus_message_get_error_name(raw_message_);
-  return error_name ? error_name : "";
+  return "";
 }
 
 std::string Message::GetSender() {
-  const char* sender = dbus_message_get_sender(raw_message_);
-  return sender ? sender : "";
+  return "";
 }
 
 std::string Message::GetSignature() {
-  const char* signature = dbus_message_get_signature(raw_message_);
-  return signature ? signature : "";
+  return "";
 }
 
 uint32_t Message::GetSerial() {
-  return dbus_message_get_serial(raw_message_);
+  return 0;
 }
 
 uint32_t Message::GetReplySerial() {
-  return dbus_message_get_reply_serial(raw_message_);
+  return 0;
 }
 
 //
@@ -367,20 +144,12 @@
 
 MethodCall::MethodCall(const std::string& interface_name,
                        const std::string& method_name) {
-  Init(dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_CALL));
-
-  CHECK(SetInterface(interface_name));
-  CHECK(SetMember(method_name));
 }
 
 MethodCall::MethodCall() = default;
 
-std::unique_ptr<MethodCall> MethodCall::FromRawMessage(
-    DBusMessage* raw_message) {
-  DCHECK_EQ(DBUS_MESSAGE_TYPE_METHOD_CALL, dbus_message_get_type(raw_message));
-
+std::unique_ptr<MethodCall> MethodCall::FromRawMessage(const void* raw_message) {
   std::unique_ptr<MethodCall> method_call(new MethodCall());
-  method_call->Init(raw_message);
   return method_call;
 }
 
@@ -389,19 +158,12 @@
 //
 Signal::Signal(const std::string& interface_name,
                const std::string& method_name) {
-  Init(dbus_message_new(DBUS_MESSAGE_TYPE_SIGNAL));
-
-  CHECK(SetInterface(interface_name));
-  CHECK(SetMember(method_name));
 }
 
 Signal::Signal() = default;
 
-std::unique_ptr<Signal> Signal::FromRawMessage(DBusMessage* raw_message) {
-  DCHECK_EQ(DBUS_MESSAGE_TYPE_SIGNAL, dbus_message_get_type(raw_message));
-
+std::unique_ptr<Signal> Signal::FromRawMessage(const void* raw_message) {
   std::unique_ptr<Signal> signal(new Signal());
-  signal->Init(raw_message);
   return signal;
 }
 
@@ -411,24 +173,18 @@
 
 Response::Response() = default;
 
-std::unique_ptr<Response> Response::FromRawMessage(DBusMessage* raw_message) {
-  DCHECK_EQ(DBUS_MESSAGE_TYPE_METHOD_RETURN,
-            dbus_message_get_type(raw_message));
-
+std::unique_ptr<Response> Response::FromRawMessage(const void* raw_message) {
   std::unique_ptr<Response> response(new Response());
-  response->Init(raw_message);
   return response;
 }
 
-std::unique_ptr<Response> Response::FromMethodCall(MethodCall* method_call) {
+std::unique_ptr<Response> Response::FromMethodCall(const void* method_call) {
   std::unique_ptr<Response> response(new Response());
-  response->Init(dbus_message_new_method_return(method_call->raw_message()));
   return response;
 }
 
 std::unique_ptr<Response> Response::CreateEmpty() {
   std::unique_ptr<Response> response(new Response());
-  response->Init(dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_RETURN));
   return response;
 }
 
@@ -438,12 +194,8 @@
 
 ErrorResponse::ErrorResponse() = default;
 
-std::unique_ptr<ErrorResponse> ErrorResponse::FromRawMessage(
-    DBusMessage* raw_message) {
-  DCHECK_EQ(DBUS_MESSAGE_TYPE_ERROR, dbus_message_get_type(raw_message));
-
+std::unique_ptr<ErrorResponse> ErrorResponse::FromRawMessage(const void* raw_message) {
   std::unique_ptr<ErrorResponse> response(new ErrorResponse());
-  response->Init(raw_message);
   return response;
 }
 
@@ -452,8 +204,6 @@
     const std::string& error_name,
     const std::string& error_message) {
   std::unique_ptr<ErrorResponse> response(new ErrorResponse());
-  response->Init(dbus_message_new_error(
-      method_call->raw_message(), error_name.c_str(), error_message.c_str()));
   return response;
 }
 
@@ -461,284 +211,128 @@
 // MessageWriter implementation.
 //
 
-MessageWriter::MessageWriter(Message* message)
+MessageWriter::MessageWriter(const void* message)
     : message_(message), container_is_open_(false) {
-  memset(&raw_message_iter_, 0, sizeof(raw_message_iter_));
-  if (message)
-    dbus_message_iter_init_append(message_->raw_message(), &raw_message_iter_);
 }
 
 MessageWriter::~MessageWriter() = default;
 
 void MessageWriter::AppendByte(uint8_t value) {
-  AppendBasic(DBUS_TYPE_BYTE, &value);
 }
 
 void MessageWriter::AppendBool(bool value) {
-  // The size of dbus_bool_t and the size of bool are different. The
-  // former is always 4 per dbus-types.h, whereas the latter is usually 1.
-  // dbus_message_iter_append_basic() used in AppendBasic() expects four
-  // bytes for DBUS_TYPE_BOOLEAN, so we must pass a dbus_bool_t, instead
-  // of a bool, to AppendBasic().
-  dbus_bool_t dbus_value = value ? 1 : 0;
-  AppendBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
 }
 
 void MessageWriter::AppendInt16(int16_t value) {
-  AppendBasic(DBUS_TYPE_INT16, &value);
 }
 
 void MessageWriter::AppendUint16(uint16_t value) {
-  AppendBasic(DBUS_TYPE_UINT16, &value);
 }
 
 void MessageWriter::AppendInt32(int32_t value) {
-  AppendBasic(DBUS_TYPE_INT32, &value);
 }
 
 void MessageWriter::AppendUint32(uint32_t value) {
-  AppendBasic(DBUS_TYPE_UINT32, &value);
 }
 
 void MessageWriter::AppendInt64(int64_t value) {
-  AppendBasic(DBUS_TYPE_INT64, &value);
 }
 
 void MessageWriter::AppendUint64(uint64_t value) {
-  AppendBasic(DBUS_TYPE_UINT64, &value);
 }
 
 void MessageWriter::AppendDouble(double value) {
-  AppendBasic(DBUS_TYPE_DOUBLE, &value);
 }
 
 void MessageWriter::AppendString(const std::string& value) {
-  // D-Bus Specification (0.19) says a string "must be valid UTF-8".
-  CHECK(base::IsStringUTF8(value));
-  const char* pointer = value.c_str();
-  AppendBasic(DBUS_TYPE_STRING, &pointer);
-  // TODO(satorux): It may make sense to return an error here, as the
-  // input string can be large. If needed, we could add something like
-  // bool AppendStringWithErrorChecking().
 }
 
 void MessageWriter::AppendObjectPath(const ObjectPath& value) {
-  CHECK(value.IsValid());
-  const char* pointer = value.value().c_str();
-  AppendBasic(DBUS_TYPE_OBJECT_PATH, &pointer);
 }
 
-// Ideally, client shouldn't need to supply the signature string, but
-// the underlying D-Bus library requires us to supply this before
-// appending contents to array and variant. It's technically possible
-// for us to design API that doesn't require the signature but it will
-// complicate the implementation so we decided to have the signature
-// parameter. Hopefully, variants are less used in request messages from
-// client side than response message from server side, so this should
-// not be a big issue.
 void MessageWriter::OpenArray(const std::string& signature,
                               MessageWriter* writer) {
-  DCHECK(!container_is_open_);
-
-  const bool success = dbus_message_iter_open_container(
-      &raw_message_iter_, DBUS_TYPE_ARRAY, signature.c_str(),
-      &writer->raw_message_iter_);
-  CHECK(success) << "Unable to allocate memory";
-  container_is_open_ = true;
 }
 
 void MessageWriter::OpenVariant(const std::string& signature,
                                 MessageWriter* writer) {
-  DCHECK(!container_is_open_);
-
-  const bool success = dbus_message_iter_open_container(
-      &raw_message_iter_, DBUS_TYPE_VARIANT, signature.c_str(),
-      &writer->raw_message_iter_);
-  CHECK(success) << "Unable to allocate memory";
-  container_is_open_ = true;
 }
 
 void MessageWriter::OpenStruct(MessageWriter* writer) {
-  DCHECK(!container_is_open_);
-
-  const bool success =
-      dbus_message_iter_open_container(&raw_message_iter_, DBUS_TYPE_STRUCT,
-                                       nullptr,  // Signature should be nullptr.
-                                       &writer->raw_message_iter_);
-  CHECK(success) << "Unable to allocate memory";
-  container_is_open_ = true;
 }
 
 void MessageWriter::OpenDictEntry(MessageWriter* writer) {
-  DCHECK(!container_is_open_);
-
-  const bool success =
-      dbus_message_iter_open_container(&raw_message_iter_, DBUS_TYPE_DICT_ENTRY,
-                                       nullptr,  // Signature should be nullptr.
-                                       &writer->raw_message_iter_);
-  CHECK(success) << "Unable to allocate memory";
-  container_is_open_ = true;
 }
 
 void MessageWriter::CloseContainer(MessageWriter* writer) {
-  DCHECK(container_is_open_);
-
-  const bool success = dbus_message_iter_close_container(
-      &raw_message_iter_, &writer->raw_message_iter_);
-  CHECK(success) << "Unable to allocate memory";
-  container_is_open_ = false;
 }
 
 void MessageWriter::AppendArrayOfBytes(const uint8_t* values, size_t length) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("y", &array_writer);
-  const bool success = dbus_message_iter_append_fixed_array(
-      &(array_writer.raw_message_iter_), DBUS_TYPE_BYTE, &values,
-      static_cast<int>(length));
-  CHECK(success) << "Unable to allocate memory";
-  CloseContainer(&array_writer);
 }
 
 void MessageWriter::AppendArrayOfInt32s(const int32_t* values, size_t length) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("i", &array_writer);
-  const bool success = dbus_message_iter_append_fixed_array(
-      &(array_writer.raw_message_iter_), DBUS_TYPE_INT32, &values,
-      static_cast<int>(length));
-  CHECK(success) << "Unable to allocate memory";
-  CloseContainer(&array_writer);
 }
 
 void MessageWriter::AppendArrayOfUint32s(const uint32_t* values,
                                          size_t length) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("u", &array_writer);
-  const bool success = dbus_message_iter_append_fixed_array(
-      &(array_writer.raw_message_iter_), DBUS_TYPE_UINT32, &values,
-      static_cast<int>(length));
-  CHECK(success) << "Unable to allocate memory";
-  CloseContainer(&array_writer);
 }
 
 void MessageWriter::AppendArrayOfDoubles(const double* values, size_t length) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("d", &array_writer);
-  const bool success = dbus_message_iter_append_fixed_array(
-      &(array_writer.raw_message_iter_), DBUS_TYPE_DOUBLE, &values,
-      static_cast<int>(length));
-  CHECK(success) << "Unable to allocate memory";
-  CloseContainer(&array_writer);
 }
 
 void MessageWriter::AppendArrayOfStrings(
     const std::vector<std::string>& strings) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("s", &array_writer);
-  for (size_t i = 0; i < strings.size(); ++i) {
-    array_writer.AppendString(strings[i]);
-  }
-  CloseContainer(&array_writer);
 }
 
 void MessageWriter::AppendArrayOfObjectPaths(
     const std::vector<ObjectPath>& object_paths) {
-  DCHECK(!container_is_open_);
-  MessageWriter array_writer(message_);
-  OpenArray("o", &array_writer);
-  for (size_t i = 0; i < object_paths.size(); ++i) {
-    array_writer.AppendObjectPath(object_paths[i]);
-  }
-  CloseContainer(&array_writer);
 }
 
 bool MessageWriter::AppendProtoAsArrayOfBytes(
     const google::protobuf::MessageLite& protobuf) {
-  std::string serialized_proto;
-  if (!protobuf.SerializeToString(&serialized_proto)) {
-    LOG(ERROR) << "Unable to serialize supplied protocol buffer";
-    return false;
-  }
-  AppendArrayOfBytes(reinterpret_cast<const uint8_t*>(serialized_proto.data()),
-                     serialized_proto.size());
   return true;
 }
 
 void MessageWriter::AppendVariantOfByte(uint8_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_BYTE, &value);
 }
 
 void MessageWriter::AppendVariantOfBool(bool value) {
-  // See the comment at MessageWriter::AppendBool().
-  dbus_bool_t dbus_value = value;
-  AppendVariantOfBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
 }
 
 void MessageWriter::AppendVariantOfInt16(int16_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_INT16, &value);
 }
 
 void MessageWriter::AppendVariantOfUint16(uint16_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_UINT16, &value);
 }
 
 void MessageWriter::AppendVariantOfInt32(int32_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_INT32, &value);
 }
 
 void MessageWriter::AppendVariantOfUint32(uint32_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_UINT32, &value);
 }
 
 void MessageWriter::AppendVariantOfInt64(int64_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_INT64, &value);
 }
 
 void MessageWriter::AppendVariantOfUint64(uint64_t value) {
-  AppendVariantOfBasic(DBUS_TYPE_UINT64, &value);
 }
 
 void MessageWriter::AppendVariantOfDouble(double value) {
-  AppendVariantOfBasic(DBUS_TYPE_DOUBLE, &value);
 }
 
 void MessageWriter::AppendVariantOfString(const std::string& value) {
-  const char* pointer = value.c_str();
-  AppendVariantOfBasic(DBUS_TYPE_STRING, &pointer);
 }
 
 void MessageWriter::AppendVariantOfObjectPath(const ObjectPath& value) {
-  const char* pointer = value.value().c_str();
-  AppendVariantOfBasic(DBUS_TYPE_OBJECT_PATH, &pointer);
 }
 
 void MessageWriter::AppendBasic(int dbus_type, const void* value) {
-  DCHECK(!container_is_open_);
-
-  const bool success =
-      dbus_message_iter_append_basic(&raw_message_iter_, dbus_type, value);
-  // dbus_message_iter_append_basic() fails only when there is not enough
-  // memory. We don't return this error as there is nothing we can do when
-  // it fails to allocate memory for a byte etc.
-  CHECK(success) << "Unable to allocate memory";
 }
 
 void MessageWriter::AppendVariantOfBasic(int dbus_type, const void* value) {
-  const std::string signature(1u,  // length
-                              base::checked_cast<char>(dbus_type));
-  MessageWriter variant_writer(message_);
-  OpenVariant(signature, &variant_writer);
-  variant_writer.AppendBasic(dbus_type, value);
-  CloseContainer(&variant_writer);
 }
 
 void MessageWriter::AppendFileDescriptor(int value) {
-  CHECK(IsDBusTypeUnixFdSupported());
-  AppendBasic(DBUS_TYPE_UNIX_FD, &value);  // This duplicates the FD.
 }
 
 //
@@ -746,333 +340,176 @@
 //
 
 MessageReader::MessageReader(Message* message) : message_(message) {
-  memset(&raw_message_iter_, 0, sizeof(raw_message_iter_));
-  if (message)
-    dbus_message_iter_init(message_->raw_message(), &raw_message_iter_);
 }
 
 MessageReader::~MessageReader() = default;
 
 bool MessageReader::HasMoreData() {
-  const int dbus_type = dbus_message_iter_get_arg_type(&raw_message_iter_);
-  return dbus_type != DBUS_TYPE_INVALID;
+  return false;
 }
 
 bool MessageReader::PopByte(uint8_t* value) {
-  return PopBasic(DBUS_TYPE_BYTE, value);
+  return true;
 }
 
 bool MessageReader::PopBool(bool* value) {
-  // Like MessageWriter::AppendBool(), we should copy |value| to
-  // dbus_bool_t, as dbus_message_iter_get_basic() used in PopBasic()
-  // expects four bytes for DBUS_TYPE_BOOLEAN.
-  dbus_bool_t dbus_value = FALSE;
-  const bool success = PopBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
-  *value = static_cast<bool>(dbus_value);
-  return success;
+  return true;
 }
 
 bool MessageReader::PopInt16(int16_t* value) {
-  return PopBasic(DBUS_TYPE_INT16, value);
+  return true;
 }
 
 bool MessageReader::PopUint16(uint16_t* value) {
-  return PopBasic(DBUS_TYPE_UINT16, value);
+  return true;
 }
 
 bool MessageReader::PopInt32(int32_t* value) {
-  return PopBasic(DBUS_TYPE_INT32, value);
+  return true;
 }
 
 bool MessageReader::PopUint32(uint32_t* value) {
-  return PopBasic(DBUS_TYPE_UINT32, value);
+  return true;
 }
 
 bool MessageReader::PopInt64(int64_t* value) {
-  return PopBasic(DBUS_TYPE_INT64, value);
+  return true;
 }
 
 bool MessageReader::PopUint64(uint64_t* value) {
-  return PopBasic(DBUS_TYPE_UINT64, value);
+  return true;
 }
 
 bool MessageReader::PopDouble(double* value) {
-  return PopBasic(DBUS_TYPE_DOUBLE, value);
+  return true;
 }
 
 bool MessageReader::PopString(std::string* value) {
-  char* tmp_value = nullptr;
-  const bool success = PopBasic(DBUS_TYPE_STRING, &tmp_value);
-  if (success)
-    value->assign(tmp_value);
-  return success;
+  return true;
 }
 
 bool MessageReader::PopObjectPath(ObjectPath* value) {
-  char* tmp_value = nullptr;
-  const bool success = PopBasic(DBUS_TYPE_OBJECT_PATH, &tmp_value);
-  if (success)
-    *value = ObjectPath(tmp_value);
-  return success;
+  return true;
 }
 
 bool MessageReader::PopArray(MessageReader* sub_reader) {
-  return PopContainer(DBUS_TYPE_ARRAY, sub_reader);
+  return true;
 }
 
 bool MessageReader::PopStruct(MessageReader* sub_reader) {
-  return PopContainer(DBUS_TYPE_STRUCT, sub_reader);
+  return true;
 }
 
 bool MessageReader::PopDictEntry(MessageReader* sub_reader) {
-  return PopContainer(DBUS_TYPE_DICT_ENTRY, sub_reader);
+  return true;
 }
 
 bool MessageReader::PopVariant(MessageReader* sub_reader) {
-  return PopContainer(DBUS_TYPE_VARIANT, sub_reader);
+  return true;
 }
 
 bool MessageReader::PopArrayOfBytes(const uint8_t** bytes, size_t* length) {
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  // An empty array is allowed.
-  if (!array_reader.HasMoreData()) {
-    *length = 0;
-    *bytes = nullptr;
-    return true;
-  }
-  if (!array_reader.CheckDataType(DBUS_TYPE_BYTE))
-    return false;
-  int int_length = 0;
-  dbus_message_iter_get_fixed_array(&array_reader.raw_message_iter_, bytes,
-                                    &int_length);
-  *length = static_cast<size_t>(int_length);
   return true;
 }
 
 bool MessageReader::PopArrayOfInt32s(const int32_t** signed_ints,
                                      size_t* length) {
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  // An empty array is allowed.
-  if (!array_reader.HasMoreData()) {
-    *length = 0;
-    *signed_ints = nullptr;
-    return true;
-  }
-  if (!array_reader.CheckDataType(DBUS_TYPE_INT32))
-    return false;
-  int int_length = 0;
-  dbus_message_iter_get_fixed_array(&array_reader.raw_message_iter_,
-                                    signed_ints, &int_length);
-  *length = static_cast<size_t>(int_length);
   return true;
 }
 
 bool MessageReader::PopArrayOfUint32s(const uint32_t** unsigned_ints,
                                       size_t* length) {
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  // An empty array is allowed.
-  if (!array_reader.HasMoreData()) {
-    *length = 0;
-    *unsigned_ints = nullptr;
-    return true;
-  }
-  if (!array_reader.CheckDataType(DBUS_TYPE_UINT32))
-    return false;
-  int int_length = 0;
-  dbus_message_iter_get_fixed_array(&array_reader.raw_message_iter_,
-                                    unsigned_ints, &int_length);
-  *length = static_cast<size_t>(int_length);
   return true;
 }
 
 bool MessageReader::PopArrayOfDoubles(const double** doubles, size_t* length) {
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  if (!array_reader.HasMoreData()) {
-    *length = 0;
-    *doubles = nullptr;
-    return true;
-  }
-  if (!array_reader.CheckDataType(DBUS_TYPE_DOUBLE))
-    return false;
-  int int_length = 0;
-  dbus_message_iter_get_fixed_array(&array_reader.raw_message_iter_, doubles,
-                                    &int_length);
-  *length = static_cast<size_t>(int_length);
   return true;
 }
 
 bool MessageReader::PopArrayOfStrings(std::vector<std::string>* strings) {
-  strings->clear();
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  while (array_reader.HasMoreData()) {
-    std::string string;
-    if (!array_reader.PopString(&string))
-      return false;
-    strings->push_back(string);
-  }
   return true;
 }
 
 bool MessageReader::PopArrayOfObjectPaths(
     std::vector<ObjectPath>* object_paths) {
-  object_paths->clear();
-  MessageReader array_reader(message_);
-  if (!PopArray(&array_reader))
-    return false;
-  while (array_reader.HasMoreData()) {
-    ObjectPath object_path;
-    if (!array_reader.PopObjectPath(&object_path))
-      return false;
-    object_paths->push_back(object_path);
-  }
   return true;
 }
 
 bool MessageReader::PopArrayOfBytesAsProto(
     google::protobuf::MessageLite* protobuf) {
-  DCHECK(protobuf);
-  const char* serialized_buf = nullptr;
-  size_t buf_size = 0;
-  if (!PopArrayOfBytes(reinterpret_cast<const uint8_t**>(&serialized_buf),
-                       &buf_size)) {
-    LOG(ERROR) << "Error reading array of bytes";
-    return false;
-  }
-  if (!protobuf->ParseFromArray(serialized_buf, buf_size)) {
-    LOG(ERROR) << "Failed to parse protocol buffer from array";
-    return false;
-  }
   return true;
 }
 
 bool MessageReader::PopVariantOfByte(uint8_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_BYTE, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfBool(bool* value) {
-  // See the comment at MessageReader::PopBool().
-  dbus_bool_t dbus_value = FALSE;
-  const bool success = PopVariantOfBasic(DBUS_TYPE_BOOLEAN, &dbus_value);
-  *value = static_cast<bool>(dbus_value);
-  return success;
+  return true;
 }
 
 bool MessageReader::PopVariantOfInt16(int16_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_INT16, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfUint16(uint16_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_UINT16, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfInt32(int32_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_INT32, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfUint32(uint32_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_UINT32, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfInt64(int64_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_INT64, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfUint64(uint64_t* value) {
-  return PopVariantOfBasic(DBUS_TYPE_UINT64, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfDouble(double* value) {
-  return PopVariantOfBasic(DBUS_TYPE_DOUBLE, value);
+  return true;
 }
 
 bool MessageReader::PopVariantOfString(std::string* value) {
-  char* tmp_value = nullptr;
-  const bool success = PopVariantOfBasic(DBUS_TYPE_STRING, &tmp_value);
-  if (success)
-    value->assign(tmp_value);
-  return success;
+  return true;
 }
 
 bool MessageReader::PopVariantOfObjectPath(ObjectPath* value) {
-  char* tmp_value = nullptr;
-  const bool success = PopVariantOfBasic(DBUS_TYPE_OBJECT_PATH, &tmp_value);
-  if (success)
-    *value = ObjectPath(tmp_value);
-  return success;
+  return true;
 }
 
 Message::DataType MessageReader::GetDataType() {
-  const int dbus_type = dbus_message_iter_get_arg_type(&raw_message_iter_);
+  const int dbus_type = 0;
   return static_cast<Message::DataType>(dbus_type);
 }
 
 std::string MessageReader::GetDataSignature() {
-  std::string signature;
-  char* raw_signature = dbus_message_iter_get_signature(&raw_message_iter_);
-  if (raw_signature) {
-    signature = raw_signature;
-    dbus_free(raw_signature);
-  }
-  return signature;
+  return "";
 }
 
 bool MessageReader::CheckDataType(int dbus_type) {
-  const int actual_type = dbus_message_iter_get_arg_type(&raw_message_iter_);
-  if (actual_type != dbus_type) {
-    VLOG(1) << "Type " << dbus_type << " is expected but got " << actual_type;
-    return false;
-  }
   return true;
 }
 
 bool MessageReader::PopBasic(int dbus_type, void* value) {
-  if (!CheckDataType(dbus_type))
-    return false;
-  // dbus_message_iter_get_basic() here should always work, as we have
-  // already checked the next item's data type in CheckDataType(). Note
-  // that dbus_message_iter_get_basic() is a void function.
-  dbus_message_iter_get_basic(&raw_message_iter_, value);
-  DCHECK(value);
-  dbus_message_iter_next(&raw_message_iter_);
   return true;
 }
 
 bool MessageReader::PopContainer(int dbus_type, MessageReader* sub_reader) {
-  DCHECK_NE(this, sub_reader);
-
-  if (!CheckDataType(dbus_type))
-    return false;
-  dbus_message_iter_recurse(&raw_message_iter_, &sub_reader->raw_message_iter_);
-  dbus_message_iter_next(&raw_message_iter_);
   return true;
 }
 
 bool MessageReader::PopVariantOfBasic(int dbus_type, void* value) {
-  MessageReader variant_reader(message_);
-  if (!PopVariant(&variant_reader))
-    return false;
-  return variant_reader.PopBasic(dbus_type, value);
+  return true;
 }
 
 bool MessageReader::PopFileDescriptor(base::ScopedFD* value) {
-  CHECK(IsDBusTypeUnixFdSupported());
-
-  int fd = -1;
-  const bool success = PopBasic(DBUS_TYPE_UNIX_FD, &fd);
-  if (!success)
-    return false;
-
-  *value = base::ScopedFD(fd);
   return true;
 }
 
diff -u a/dbus/message.h b/dbus/message.h
--- a/dbus/message.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/message.h	2020-06-09 21:04:00.080162854 +0200
@@ -5,7 +5,6 @@
 #ifndef DBUS_MESSAGE_H_
 #define DBUS_MESSAGE_H_
 
-#include <dbus/dbus.h>
 #include <stddef.h>
 #include <stdint.h>
 
@@ -55,33 +54,33 @@
   // etc. are #define macros. Having an enum type here makes code a bit
   // more type-safe.
   enum MessageType {
-    MESSAGE_INVALID = DBUS_MESSAGE_TYPE_INVALID,
-    MESSAGE_METHOD_CALL = DBUS_MESSAGE_TYPE_METHOD_CALL,
-    MESSAGE_METHOD_RETURN = DBUS_MESSAGE_TYPE_METHOD_RETURN,
-    MESSAGE_SIGNAL = DBUS_MESSAGE_TYPE_SIGNAL,
-    MESSAGE_ERROR = DBUS_MESSAGE_TYPE_ERROR,
+    MESSAGE_INVALID = 0,
+    MESSAGE_METHOD_CALL = 1,
+    MESSAGE_METHOD_RETURN = 2,
+    MESSAGE_SIGNAL = 3,
+    MESSAGE_ERROR = 4,
   };
 
   // The data type used in the D-Bus type system.  See the comment at
   // MessageType for why we are redefining data types here.
   enum DataType {
-    INVALID_DATA = DBUS_TYPE_INVALID,
-    BYTE = DBUS_TYPE_BYTE,
-    BOOL = DBUS_TYPE_BOOLEAN,
-    INT16 = DBUS_TYPE_INT16,
-    UINT16 = DBUS_TYPE_UINT16,
-    INT32 = DBUS_TYPE_INT32,
-    UINT32 = DBUS_TYPE_UINT32,
-    INT64 = DBUS_TYPE_INT64,
-    UINT64 = DBUS_TYPE_UINT64,
-    DOUBLE = DBUS_TYPE_DOUBLE,
-    STRING = DBUS_TYPE_STRING,
-    OBJECT_PATH = DBUS_TYPE_OBJECT_PATH,
-    ARRAY = DBUS_TYPE_ARRAY,
-    STRUCT = DBUS_TYPE_STRUCT,
-    DICT_ENTRY = DBUS_TYPE_DICT_ENTRY,
-    VARIANT = DBUS_TYPE_VARIANT,
-    UNIX_FD = DBUS_TYPE_UNIX_FD,
+    INVALID_DATA = 0,
+    BYTE = 1,
+    BOOL = 2,
+    INT16 = 3,
+    UINT16 = 4,
+    INT32 = 5,
+    UINT32 = 6,
+    INT64 = 7,
+    UINT64 = 8,
+    DOUBLE = 9,
+    STRING = 10,
+    OBJECT_PATH = 11,
+    ARRAY = 12,
+    STRUCT = 13,
+    DICT_ENTRY = 14,
+    VARIANT = 15,
+    UNIX_FD = 16,
   };
 
   // Returns the type of the message. Returns MESSAGE_INVALID if
@@ -92,7 +91,7 @@
   // for instance.
   std::string GetMessageTypeAsString();
 
-  DBusMessage* raw_message() { return raw_message_; }
+  const void* raw_message() { return raw_message_; }
 
   // Sets the destination, the path, the interface, the member, etc.
   bool SetDestination(const std::string& destination);
@@ -129,14 +128,14 @@
   virtual ~Message();
 
   // Initializes the message with the given raw message.
-  void Init(DBusMessage* raw_message);
+  void Init(const void* raw_message);
 
  private:
   // Helper function used in ToString().
   std::string ToStringInternal(const std::string& indent,
                                MessageReader* reader);
 
-  DBusMessage* raw_message_;
+  const void* raw_message_;
   DISALLOW_COPY_AND_ASSIGN(Message);
 };
 
@@ -157,7 +156,7 @@
 
   // Returns a newly created MethodCall from the given raw message of the
   // type DBUS_MESSAGE_TYPE_METHOD_CALL. Takes the ownership of |raw_message|.
-  static std::unique_ptr<MethodCall> FromRawMessage(DBusMessage* raw_message);
+  static std::unique_ptr<MethodCall> FromRawMessage(const void* raw_message);
 
  private:
   // Creates a method call message. The internal raw message is NULL.
@@ -184,7 +183,7 @@
 
   // Returns a newly created SIGNAL from the given raw message of the type
   // DBUS_MESSAGE_TYPE_SIGNAL. Takes the ownership of |raw_message|.
-  static std::unique_ptr<Signal> FromRawMessage(DBusMessage* raw_message);
+  static std::unique_ptr<Signal> FromRawMessage(const void* raw_message);
 
  private:
   // Creates a signal message. The internal raw message is NULL.
@@ -200,7 +199,7 @@
  public:
   // Returns a newly created Response from the given raw message of the
   // type DBUS_MESSAGE_TYPE_METHOD_RETURN. Takes the ownership of |raw_message|.
-  static std::unique_ptr<Response> FromRawMessage(DBusMessage* raw_message);
+  static std::unique_ptr<Response> FromRawMessage(const void* raw_message);
 
   // Returns a newly created Response from the given method call.
   // Used for implementing exported methods. Does NOT take the ownership of
@@ -226,7 +225,7 @@
   // Returns a newly created Response from the given raw message of the
   // type DBUS_MESSAGE_TYPE_METHOD_RETURN. Takes the ownership of |raw_message|.
   static std::unique_ptr<ErrorResponse> FromRawMessage(
-      DBusMessage* raw_message);
+      const void* raw_message);
 
   // Returns a newly created ErrorResponse from the given method call, the
   // error name, and the error message.  The error name looks like
@@ -363,7 +362,6 @@
   void AppendVariantOfBasic(int dbus_type, const void* value);
 
   Message* message_;
-  DBusMessageIter raw_message_iter_;
   bool container_is_open_;
 
   DISALLOW_COPY_AND_ASSIGN(MessageWriter);
@@ -503,7 +501,6 @@
   bool PopVariantOfBasic(int dbus_type, void* value);
 
   Message* message_;
-  DBusMessageIter raw_message_iter_;
 
   DISALLOW_COPY_AND_ASSIGN(MessageReader);
 };
diff -u a/dbus/message_unittest.cc b/dbus/message_unittest.cc
--- a/dbus/message_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/message_unittest.cc	2020-06-09 18:48:11.509106554 +0200
@@ -12,716 +12,8 @@
 #include "base/logging.h"
 #include "base/posix/eintr_wrapper.h"
 #include "dbus/object_path.h"
-#include "dbus/test_proto.pb.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace dbus {
 
-// Test that a byte can be properly written and read. We only have this
-// test for byte, as repeating this for other basic types is too redundant.
-TEST(MessageTest, AppendAndPopByte) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  writer.AppendByte(123);  // The input is 123.
-
-  MessageReader reader(message.get());
-  ASSERT_TRUE(reader.HasMoreData());  // Should have data to read.
-  ASSERT_EQ(Message::BYTE, reader.GetDataType());
-  ASSERT_EQ("y", reader.GetDataSignature());
-
-  bool bool_value = false;
-  // Should fail as the type is not bool here.
-  ASSERT_FALSE(reader.PopBool(&bool_value));
-
-  uint8_t byte_value = 0;
-  ASSERT_TRUE(reader.PopByte(&byte_value));
-  EXPECT_EQ(123, byte_value);          // Should match with the input.
-  ASSERT_FALSE(reader.HasMoreData());  // Should not have more data to read.
-
-  // Try to get another byte. Should fail.
-  ASSERT_FALSE(reader.PopByte(&byte_value));
-}
-
-// Check all basic types can be properly written and read.
-TEST(MessageTest, AppendAndPopBasicDataTypes) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  // Append 0, 1, 2, 3, 4, 5, 6, 7, 8, "string", "/object/path".
-  writer.AppendByte(0);
-  writer.AppendBool(true);
-  writer.AppendInt16(2);
-  writer.AppendUint16(3);
-  writer.AppendInt32(4);
-  writer.AppendUint32(5);
-  writer.AppendInt64(6);
-  writer.AppendUint64(7);
-  writer.AppendDouble(8.0);
-  writer.AppendString("string");
-  writer.AppendObjectPath(ObjectPath("/object/path"));
-
-  uint8_t byte_value = 0;
-  bool bool_value = false;
-  int16_t int16_value = 0;
-  uint16_t uint16_value = 0;
-  int32_t int32_value = 0;
-  uint32_t uint32_value = 0;
-  int64_t int64_value = 0;
-  uint64_t uint64_value = 0;
-  double double_value = 0;
-  std::string string_value;
-  ObjectPath object_path_value;
-
-  MessageReader reader(message.get());
-  ASSERT_TRUE(reader.HasMoreData());
-  ASSERT_EQ("y", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopByte(&byte_value));
-  ASSERT_EQ("b", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopBool(&bool_value));
-  ASSERT_EQ("n", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopInt16(&int16_value));
-  ASSERT_EQ("q", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopUint16(&uint16_value));
-  ASSERT_EQ("i", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopInt32(&int32_value));
-  ASSERT_EQ("u", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopUint32(&uint32_value));
-  ASSERT_EQ("x", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopInt64(&int64_value));
-  ASSERT_EQ("t", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopUint64(&uint64_value));
-  ASSERT_EQ("d", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopDouble(&double_value));
-  ASSERT_EQ("s", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopString(&string_value));
-  ASSERT_EQ("o", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopObjectPath(&object_path_value));
-  ASSERT_EQ("", reader.GetDataSignature());
-  ASSERT_FALSE(reader.HasMoreData());
-
-  // 0, 1, 2, 3, 4, 5, 6, 7, 8, "string", "/object/path" should be returned.
-  EXPECT_EQ(0, byte_value);
-  EXPECT_EQ(true, bool_value);
-  EXPECT_EQ(2, int16_value);
-  EXPECT_EQ(3U, uint16_value);
-  EXPECT_EQ(4, int32_value);
-  EXPECT_EQ(5U, uint32_value);
-  EXPECT_EQ(6, int64_value);
-  EXPECT_EQ(7U, uint64_value);
-  EXPECT_DOUBLE_EQ(8.0, double_value);
-  EXPECT_EQ("string", string_value);
-  EXPECT_EQ(ObjectPath("/object/path"), object_path_value);
-}
-
-// Check all basic types can be properly written and read.
-TEST(MessageTest, AppendAndPopFileDescriptor) {
-  if (!IsDBusTypeUnixFdSupported()) {
-    LOG(WARNING) << "FD passing is not supported";
-    return;
-  }
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  // Append stdout.
-  const int fd_in = 1;
-  writer.AppendFileDescriptor(fd_in);
-
-  base::ScopedFD fd_out;
-
-  MessageReader reader(message.get());
-  ASSERT_TRUE(reader.HasMoreData());
-  ASSERT_EQ(Message::UNIX_FD, reader.GetDataType());
-  ASSERT_EQ("h", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopFileDescriptor(&fd_out));
-  ASSERT_FALSE(reader.HasMoreData());
-
-  // Stdout should be returned but we cannot check the descriptor
-  // value because stdout will be dup'd.  Instead check st_rdev
-  // which should be identical.
-  struct stat sb_stdout;
-  int status_stdout = HANDLE_EINTR(fstat(fd_in, &sb_stdout));
-  ASSERT_GE(status_stdout, 0);
-  struct stat sb_fd;
-  int status_fd = HANDLE_EINTR(fstat(fd_out.get(), &sb_fd));
-  ASSERT_GE(status_fd, 0);
-  EXPECT_EQ(sb_stdout.st_rdev, sb_fd.st_rdev);
-}
-
-// Check all variant types can be properly written and read.
-TEST(MessageTest, AppendAndPopVariantDataTypes) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  // Append 0, 1, 2, 3, 4, 5, 6, 7, 8, "string", "/object/path".
-  writer.AppendVariantOfByte(0);
-  writer.AppendVariantOfBool(true);
-  writer.AppendVariantOfInt16(2);
-  writer.AppendVariantOfUint16(3);
-  writer.AppendVariantOfInt32(4);
-  writer.AppendVariantOfUint32(5);
-  writer.AppendVariantOfInt64(6);
-  writer.AppendVariantOfUint64(7);
-  writer.AppendVariantOfDouble(8.0);
-  writer.AppendVariantOfString("string");
-  writer.AppendVariantOfObjectPath(ObjectPath("/object/path"));
-
-  uint8_t byte_value = 0;
-  bool bool_value = false;
-  int16_t int16_value = 0;
-  uint16_t uint16_value = 0;
-  int32_t int32_value = 0;
-  uint32_t uint32_value = 0;
-  int64_t int64_value = 0;
-  uint64_t uint64_value = 0;
-  double double_value = 0;
-  std::string string_value;
-  ObjectPath object_path_value;
-
-  MessageReader reader(message.get());
-  ASSERT_TRUE(reader.HasMoreData());
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfByte(&byte_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfBool(&bool_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfInt16(&int16_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfUint16(&uint16_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfInt32(&int32_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfUint32(&uint32_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfInt64(&int64_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfUint64(&uint64_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfDouble(&double_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfString(&string_value));
-  ASSERT_EQ("v", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopVariantOfObjectPath(&object_path_value));
-  ASSERT_EQ("", reader.GetDataSignature());
-  ASSERT_FALSE(reader.HasMoreData());
-
-  // 0, 1, 2, 3, 4, 5, 6, 7, 8, "string", "/object/path" should be returned.
-  EXPECT_EQ(0, byte_value);
-  EXPECT_EQ(true, bool_value);
-  EXPECT_EQ(2, int16_value);
-  EXPECT_EQ(3U, uint16_value);
-  EXPECT_EQ(4, int32_value);
-  EXPECT_EQ(5U, uint32_value);
-  EXPECT_EQ(6, int64_value);
-  EXPECT_EQ(7U, uint64_value);
-  EXPECT_DOUBLE_EQ(8.0, double_value);
-  EXPECT_EQ("string", string_value);
-  EXPECT_EQ(ObjectPath("/object/path"), object_path_value);
-}
-
-TEST(MessageTest, ArrayOfBytes) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<uint8_t> bytes;
-  bytes.push_back(1);
-  bytes.push_back(2);
-  bytes.push_back(3);
-  writer.AppendArrayOfBytes(bytes.data(), bytes.size());
-
-  MessageReader reader(message.get());
-  const uint8_t* output_bytes = nullptr;
-  size_t length = 0;
-  ASSERT_EQ("ay", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfBytes(&output_bytes, &length));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(3U, length);
-  EXPECT_EQ(1, output_bytes[0]);
-  EXPECT_EQ(2, output_bytes[1]);
-  EXPECT_EQ(3, output_bytes[2]);
-}
-
-TEST(MessageTest, ArrayOfInt32s) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<int32_t> int32s;
-  int32s.push_back(1);
-  int32s.push_back(2);
-  int32s.push_back(3);
-  writer.AppendArrayOfInt32s(int32s.data(), int32s.size());
-
-  MessageReader reader(message.get());
-  const int32_t* output_int32s = nullptr;
-  size_t length = 0;
-  ASSERT_EQ("ai", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfInt32s(&output_int32s, &length));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(3U, length);
-  EXPECT_EQ(1, output_int32s[0]);
-  EXPECT_EQ(2, output_int32s[1]);
-  EXPECT_EQ(3, output_int32s[2]);
-}
-
-TEST(MessageTest, ArrayOfUint32s) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<uint32_t> uint32s;
-  uint32s.push_back(1);
-  uint32s.push_back(2);
-  uint32s.push_back(3);
-  writer.AppendArrayOfUint32s(uint32s.data(), uint32s.size());
-
-  MessageReader reader(message.get());
-  const uint32_t* output_uint32s = nullptr;
-  size_t length = 0;
-  ASSERT_EQ("au", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfUint32s(&output_uint32s, &length));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(3U, length);
-  EXPECT_EQ(1U, output_uint32s[0]);
-  EXPECT_EQ(2U, output_uint32s[1]);
-  EXPECT_EQ(3U, output_uint32s[2]);
-}
-
-TEST(MessageTest, ArrayOfDoubles) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<double> doubles;
-  doubles.push_back(0.2);
-  doubles.push_back(0.5);
-  doubles.push_back(1);
-  writer.AppendArrayOfDoubles(doubles.data(), doubles.size());
-
-  MessageReader reader(message.get());
-  const double* output_doubles = nullptr;
-  size_t length = 0;
-  ASSERT_EQ("ad", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfDoubles(&output_doubles, &length));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(3U, length);
-  EXPECT_EQ(0.2, output_doubles[0]);
-  EXPECT_EQ(0.5, output_doubles[1]);
-  EXPECT_EQ(1, output_doubles[2]);
-}
-
-TEST(MessageTest, ArrayOfBytes_Empty) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<uint8_t> bytes;
-  writer.AppendArrayOfBytes(bytes.data(), bytes.size());
-
-  MessageReader reader(message.get());
-  const uint8_t* output_bytes = nullptr;
-  size_t length = 0;
-  ASSERT_EQ("ay", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfBytes(&output_bytes, &length));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(0U, length);
-  EXPECT_EQ(nullptr, output_bytes);
-}
-
-TEST(MessageTest, ArrayOfStrings) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<std::string> strings;
-  strings.push_back("fee");
-  strings.push_back("fie");
-  strings.push_back("foe");
-  strings.push_back("fum");
-  writer.AppendArrayOfStrings(strings);
-
-  MessageReader reader(message.get());
-  std::vector<std::string> output_strings;
-  ASSERT_EQ("as", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfStrings(&output_strings));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(4U, output_strings.size());
-  EXPECT_EQ("fee", output_strings[0]);
-  EXPECT_EQ("fie", output_strings[1]);
-  EXPECT_EQ("foe", output_strings[2]);
-  EXPECT_EQ("fum", output_strings[3]);
-}
-
-TEST(MessageTest, ArrayOfObjectPaths) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  std::vector<ObjectPath> object_paths;
-  object_paths.push_back(ObjectPath("/object/path/1"));
-  object_paths.push_back(ObjectPath("/object/path/2"));
-  object_paths.push_back(ObjectPath("/object/path/3"));
-  writer.AppendArrayOfObjectPaths(object_paths);
-
-  MessageReader reader(message.get());
-  std::vector<ObjectPath> output_object_paths;
-  ASSERT_EQ("ao", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfObjectPaths(&output_object_paths));
-  ASSERT_FALSE(reader.HasMoreData());
-  ASSERT_EQ(3U, output_object_paths.size());
-  EXPECT_EQ(ObjectPath("/object/path/1"), output_object_paths[0]);
-  EXPECT_EQ(ObjectPath("/object/path/2"), output_object_paths[1]);
-  EXPECT_EQ(ObjectPath("/object/path/3"), output_object_paths[2]);
-}
-
-TEST(MessageTest, ProtoBuf) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  TestProto send_message;
-  send_message.set_text("testing");
-  send_message.set_number(123);
-  writer.AppendProtoAsArrayOfBytes(send_message);
-
-  MessageReader reader(message.get());
-  TestProto receive_message;
-  ASSERT_EQ("ay", reader.GetDataSignature());
-  ASSERT_TRUE(reader.PopArrayOfBytesAsProto(&receive_message));
-  EXPECT_EQ(receive_message.text(), send_message.text());
-  EXPECT_EQ(receive_message.number(), send_message.number());
-}
-
-// Test that an array can be properly written and read. We only have this
-// test for array, as repeating this for other container types is too
-// redundant.
-TEST(MessageTest, OpenArrayAndPopArray) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter array_writer(nullptr);
-  writer.OpenArray("s", &array_writer);  // Open an array of strings.
-  array_writer.AppendString("foo");
-  array_writer.AppendString("bar");
-  array_writer.AppendString("baz");
-  writer.CloseContainer(&array_writer);
-
-  MessageReader reader(message.get());
-  ASSERT_EQ(Message::ARRAY, reader.GetDataType());
-  ASSERT_EQ("as", reader.GetDataSignature());
-  MessageReader array_reader(nullptr);
-  ASSERT_TRUE(reader.PopArray(&array_reader));
-  ASSERT_FALSE(reader.HasMoreData());  // Should not have more data to read.
-
-  std::string string_value;
-  ASSERT_TRUE(array_reader.PopString(&string_value));
-  EXPECT_EQ("foo", string_value);
-  ASSERT_TRUE(array_reader.PopString(&string_value));
-  EXPECT_EQ("bar", string_value);
-  ASSERT_TRUE(array_reader.PopString(&string_value));
-  EXPECT_EQ("baz", string_value);
-  // Should not have more data to read.
-  ASSERT_FALSE(array_reader.HasMoreData());
-}
-
-// Create a complex message using array, struct, variant, dict entry, and
-// make sure it can be read properly.
-TEST(MessageTest, CreateComplexMessageAndReadIt) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  {
-    MessageWriter array_writer(nullptr);
-    // Open an array of variants.
-    writer.OpenArray("v", &array_writer);
-    {
-      // The first value in the array.
-      {
-        MessageWriter variant_writer(nullptr);
-        // Open a variant of a boolean.
-        array_writer.OpenVariant("b", &variant_writer);
-        variant_writer.AppendBool(true);
-        array_writer.CloseContainer(&variant_writer);
-      }
-
-      // The second value in the array.
-      {
-        MessageWriter variant_writer(nullptr);
-        // Open a variant of a struct that contains a string and an int32_t.
-        array_writer.OpenVariant("(si)", &variant_writer);
-        {
-          MessageWriter struct_writer(nullptr);
-          variant_writer.OpenStruct(&struct_writer);
-          struct_writer.AppendString("string");
-          struct_writer.AppendInt32(123);
-          variant_writer.CloseContainer(&struct_writer);
-        }
-        array_writer.CloseContainer(&variant_writer);
-      }
-
-      // The third value in the array.
-      {
-        MessageWriter variant_writer(nullptr);
-        // Open a variant of an array of string-to-int64_t dict entries.
-        array_writer.OpenVariant("a{sx}", &variant_writer);
-        {
-          // Opens an array of string-to-int64_t dict entries.
-          MessageWriter dict_array_writer(nullptr);
-          variant_writer.OpenArray("{sx}", &dict_array_writer);
-          {
-            // Opens a string-to-int64_t dict entries.
-            MessageWriter dict_entry_writer(nullptr);
-            dict_array_writer.OpenDictEntry(&dict_entry_writer);
-            dict_entry_writer.AppendString("foo");
-            dict_entry_writer.AppendInt64(INT64_C(1234567890123456789));
-            dict_array_writer.CloseContainer(&dict_entry_writer);
-          }
-          variant_writer.CloseContainer(&dict_array_writer);
-        }
-        array_writer.CloseContainer(&variant_writer);
-      }
-    }
-    writer.CloseContainer(&array_writer);
-  }
-  // What we have created looks like this:
-  EXPECT_EQ(
-      "message_type: MESSAGE_METHOD_RETURN\n"
-      "signature: av\n"
-      "\n"
-      "array [\n"
-      "  variant     bool true\n"
-      "  variant     struct {\n"
-      "      string \"string\"\n"
-      "      int32_t 123\n"
-      "    }\n"
-      "  variant     array [\n"
-      "      dict entry {\n"
-      "        string \"foo\"\n"
-      "        int64_t 1234567890123456789\n"
-      "      }\n"
-      "    ]\n"
-      "]\n",
-      message->ToString());
-
-  MessageReader reader(message.get());
-  ASSERT_EQ("av", reader.GetDataSignature());
-  MessageReader array_reader(nullptr);
-  ASSERT_TRUE(reader.PopArray(&array_reader));
-
-  // The first value in the array.
-  bool bool_value = false;
-  ASSERT_EQ("v", array_reader.GetDataSignature());
-  ASSERT_TRUE(array_reader.PopVariantOfBool(&bool_value));
-  EXPECT_EQ(true, bool_value);
-
-  // The second value in the array.
-  {
-    MessageReader variant_reader(nullptr);
-    ASSERT_TRUE(array_reader.PopVariant(&variant_reader));
-    {
-      MessageReader struct_reader(nullptr);
-      ASSERT_EQ("(si)", variant_reader.GetDataSignature());
-      ASSERT_TRUE(variant_reader.PopStruct(&struct_reader));
-      std::string string_value;
-      ASSERT_TRUE(struct_reader.PopString(&string_value));
-      EXPECT_EQ("string", string_value);
-      int32_t int32_value = 0;
-      ASSERT_TRUE(struct_reader.PopInt32(&int32_value));
-      EXPECT_EQ(123, int32_value);
-      ASSERT_FALSE(struct_reader.HasMoreData());
-    }
-    ASSERT_FALSE(variant_reader.HasMoreData());
-  }
-
-  // The third value in the array.
-  {
-    MessageReader variant_reader(nullptr);
-    ASSERT_TRUE(array_reader.PopVariant(&variant_reader));
-    {
-      MessageReader dict_array_reader(nullptr);
-      ASSERT_EQ("a{sx}", variant_reader.GetDataSignature());
-      ASSERT_TRUE(variant_reader.PopArray(&dict_array_reader));
-      {
-        MessageReader dict_entry_reader(nullptr);
-        ASSERT_TRUE(dict_array_reader.PopDictEntry(&dict_entry_reader));
-        std::string string_value;
-        ASSERT_TRUE(dict_entry_reader.PopString(&string_value));
-        EXPECT_EQ("foo", string_value);
-        int64_t int64_value = 0;
-        ASSERT_TRUE(dict_entry_reader.PopInt64(&int64_value));
-        EXPECT_EQ(INT64_C(1234567890123456789), int64_value);
-      }
-      ASSERT_FALSE(dict_array_reader.HasMoreData());
-    }
-    ASSERT_FALSE(variant_reader.HasMoreData());
-  }
-  ASSERT_FALSE(array_reader.HasMoreData());
-  ASSERT_FALSE(reader.HasMoreData());
-}
-
-TEST(MessageTest, MethodCall) {
-  MethodCall method_call("com.example.Interface", "SomeMethod");
-  EXPECT_NE(nullptr, method_call.raw_message());
-  EXPECT_EQ(Message::MESSAGE_METHOD_CALL, method_call.GetMessageType());
-  EXPECT_EQ("MESSAGE_METHOD_CALL", method_call.GetMessageTypeAsString());
-  method_call.SetDestination("com.example.Service");
-  method_call.SetPath(ObjectPath("/com/example/Object"));
-
-  MessageWriter writer(&method_call);
-  writer.AppendString("payload");
-
-  EXPECT_EQ(
-      "message_type: MESSAGE_METHOD_CALL\n"
-      "destination: com.example.Service\n"
-      "path: /com/example/Object\n"
-      "interface: com.example.Interface\n"
-      "member: SomeMethod\n"
-      "signature: s\n"
-      "\n"
-      "string \"payload\"\n",
-      method_call.ToString());
-}
-
-TEST(MessageTest, MethodCall_FromRawMessage) {
-  DBusMessage* raw_message = dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_CALL);
-  dbus_message_set_interface(raw_message, "com.example.Interface");
-  dbus_message_set_member(raw_message, "SomeMethod");
-
-  std::unique_ptr<MethodCall> method_call(
-      MethodCall::FromRawMessage(raw_message));
-  EXPECT_EQ("com.example.Interface", method_call->GetInterface());
-  EXPECT_EQ("SomeMethod", method_call->GetMember());
-}
-
-TEST(MessageTest, Signal) {
-  Signal signal("com.example.Interface", "SomeSignal");
-  EXPECT_NE(nullptr, signal.raw_message());
-  EXPECT_EQ(Message::MESSAGE_SIGNAL, signal.GetMessageType());
-  EXPECT_EQ("MESSAGE_SIGNAL", signal.GetMessageTypeAsString());
-  signal.SetPath(ObjectPath("/com/example/Object"));
-
-  MessageWriter writer(&signal);
-  writer.AppendString("payload");
-
-  EXPECT_EQ(
-      "message_type: MESSAGE_SIGNAL\n"
-      "path: /com/example/Object\n"
-      "interface: com.example.Interface\n"
-      "member: SomeSignal\n"
-      "signature: s\n"
-      "\n"
-      "string \"payload\"\n",
-      signal.ToString());
-}
-
-TEST(MessageTest, Signal_FromRawMessage) {
-  DBusMessage* raw_message = dbus_message_new(DBUS_MESSAGE_TYPE_SIGNAL);
-  dbus_message_set_interface(raw_message, "com.example.Interface");
-  dbus_message_set_member(raw_message, "SomeSignal");
-
-  std::unique_ptr<Signal> signal(Signal::FromRawMessage(raw_message));
-  EXPECT_EQ("com.example.Interface", signal->GetInterface());
-  EXPECT_EQ("SomeSignal", signal->GetMember());
-}
-
-TEST(MessageTest, Response) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  EXPECT_TRUE(response->raw_message());
-  EXPECT_EQ(Message::MESSAGE_METHOD_RETURN, response->GetMessageType());
-  EXPECT_EQ("MESSAGE_METHOD_RETURN", response->GetMessageTypeAsString());
-}
-
-TEST(MessageTest, Response_FromMethodCall) {
-  const uint32_t kSerial = 123;
-  MethodCall method_call("com.example.Interface", "SomeMethod");
-  method_call.SetSerial(kSerial);
-
-  std::unique_ptr<Response> response(Response::FromMethodCall(&method_call));
-  EXPECT_EQ(Message::MESSAGE_METHOD_RETURN, response->GetMessageType());
-  EXPECT_EQ("MESSAGE_METHOD_RETURN", response->GetMessageTypeAsString());
-  // The serial should be copied to the reply serial.
-  EXPECT_EQ(kSerial, response->GetReplySerial());
-}
-
-TEST(MessageTest, ErrorResponse_FromMethodCall) {
-  const uint32_t kSerial = 123;
-  const char kErrorMessage[] = "error message";
-
-  MethodCall method_call("com.example.Interface", "SomeMethod");
-  method_call.SetSerial(kSerial);
-
-  std::unique_ptr<ErrorResponse> error_response(ErrorResponse::FromMethodCall(
-      &method_call, DBUS_ERROR_FAILED, kErrorMessage));
-  EXPECT_EQ(Message::MESSAGE_ERROR, error_response->GetMessageType());
-  EXPECT_EQ("MESSAGE_ERROR", error_response->GetMessageTypeAsString());
-  // The serial should be copied to the reply serial.
-  EXPECT_EQ(kSerial, error_response->GetReplySerial());
-
-  // Error message should be added to the payload.
-  MessageReader reader(error_response.get());
-  std::string error_message;
-  ASSERT_TRUE(reader.PopString(&error_message));
-  EXPECT_EQ(kErrorMessage, error_message);
-}
-
-TEST(MessageTest, GetAndSetHeaders) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-
-  EXPECT_EQ("", message->GetDestination());
-  EXPECT_EQ(ObjectPath(std::string()), message->GetPath());
-  EXPECT_EQ("", message->GetInterface());
-  EXPECT_EQ("", message->GetMember());
-  EXPECT_EQ("", message->GetErrorName());
-  EXPECT_EQ("", message->GetSender());
-  EXPECT_EQ(0U, message->GetSerial());
-  EXPECT_EQ(0U, message->GetReplySerial());
-
-  EXPECT_TRUE(message->SetDestination("org.chromium.destination"));
-  EXPECT_TRUE(message->SetPath(ObjectPath("/org/chromium/path")));
-  EXPECT_TRUE(message->SetInterface("org.chromium.interface"));
-  EXPECT_TRUE(message->SetMember("member"));
-  EXPECT_TRUE(message->SetErrorName("org.chromium.error"));
-  EXPECT_TRUE(message->SetSender(":1.2"));
-  message->SetSerial(123);
-  message->SetReplySerial(456);
-
-  EXPECT_EQ("org.chromium.destination", message->GetDestination());
-  EXPECT_EQ(ObjectPath("/org/chromium/path"), message->GetPath());
-  EXPECT_EQ("org.chromium.interface", message->GetInterface());
-  EXPECT_EQ("member", message->GetMember());
-  EXPECT_EQ("org.chromium.error", message->GetErrorName());
-  EXPECT_EQ(":1.2", message->GetSender());
-  EXPECT_EQ(123U, message->GetSerial());
-  EXPECT_EQ(456U, message->GetReplySerial());
-}
-
-TEST(MessageTest, SetInvalidHeaders) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  EXPECT_EQ("", message->GetDestination());
-  EXPECT_EQ(ObjectPath(std::string()), message->GetPath());
-  EXPECT_EQ("", message->GetInterface());
-  EXPECT_EQ("", message->GetMember());
-  EXPECT_EQ("", message->GetErrorName());
-  EXPECT_EQ("", message->GetSender());
-
-  // Empty element between periods.
-  EXPECT_FALSE(message->SetDestination("org..chromium"));
-  // Trailing '/' is only allowed for the root path.
-  EXPECT_FALSE(message->SetPath(ObjectPath("/org/chromium/")));
-  // Interface name cannot contain '/'.
-  EXPECT_FALSE(message->SetInterface("org/chromium/interface"));
-  // Member name cannot begin with a digit.
-  EXPECT_FALSE(message->SetMember("1member"));
-  // Error name cannot begin with a period.
-  EXPECT_FALSE(message->SetErrorName(".org.chromium.error"));
-  // Disallowed characters.
-  EXPECT_FALSE(message->SetSender("?!#*"));
-
-  EXPECT_EQ("", message->GetDestination());
-  EXPECT_EQ(ObjectPath(std::string()), message->GetPath());
-  EXPECT_EQ("", message->GetInterface());
-  EXPECT_EQ("", message->GetMember());
-  EXPECT_EQ("", message->GetErrorName());
-  EXPECT_EQ("", message->GetSender());
-}
-
-TEST(MessageTest, ToString_LongString) {
-  const std::string kLongString(1000, 'o');
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  writer.AppendString(kLongString);
-
-  ASSERT_EQ(
-      "message_type: MESSAGE_METHOD_RETURN\n"
-      "signature: s\n\n"
-      "string \"oooooooooooooooooooooooooooooooooooooooooooooooo"
-      "oooooooooooooooooooooooooooooooooooooooooooooooooooo... "
-      "(1000 bytes in total)\"\n",
-      message->ToString());
-}
-
 }  // namespace dbus
diff -u a/dbus/mock_bus.h b/dbus/mock_bus.h
--- a/dbus/mock_bus.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/mock_bus.h	2020-06-09 18:54:50.251832339 +0200
@@ -20,61 +20,6 @@
  public:
   MockBus(const Bus::Options& options);
 
-  MOCK_METHOD2(GetObjectProxy, ObjectProxy*(const std::string& service_name,
-                                            const ObjectPath& object_path));
-  MOCK_METHOD3(GetObjectProxyWithOptions,
-               ObjectProxy*(const std::string& service_name,
-                            const ObjectPath& object_path,
-                            int options));
-  MOCK_METHOD1(GetExportedObject, ExportedObject*(
-      const ObjectPath& object_path));
-  MOCK_METHOD2(GetObjectManager, ObjectManager*(const std::string&,
-                                                const ObjectPath&));
-  MOCK_METHOD0(ShutdownAndBlock, void());
-  MOCK_METHOD0(ShutdownOnDBusThreadAndBlock, void());
-  MOCK_METHOD0(Connect, bool());
-  MOCK_METHOD3(RequestOwnership, void(
-      const std::string& service_name,
-      ServiceOwnershipOptions options,
-      OnOwnershipCallback on_ownership_callback));
-  MOCK_METHOD2(RequestOwnershipAndBlock, bool(const std::string& service_name,
-                                              ServiceOwnershipOptions options));
-  MOCK_METHOD1(ReleaseOwnership, bool(const std::string& service_name));
-  MOCK_METHOD0(SetUpAsyncOperations, bool());
-  MOCK_METHOD3(SendWithReplyAndBlock, DBusMessage*(DBusMessage* request,
-                                                   int timeout_ms,
-                                                   DBusError* error));
-  MOCK_METHOD3(SendWithReply, void(DBusMessage* request,
-                                   DBusPendingCall** pending_call,
-                                   int timeout_ms));
-  MOCK_METHOD2(Send, void(DBusMessage* request, uint32_t* serial));
-  MOCK_METHOD2(AddFilterFunction,
-               void(DBusHandleMessageFunction filter_function,
-                    void* user_data));
-  MOCK_METHOD2(RemoveFilterFunction,
-               void(DBusHandleMessageFunction filter_function,
-                    void* user_data));
-  MOCK_METHOD2(AddMatch, void(const std::string& match_rule,
-                              DBusError* error));
-  MOCK_METHOD2(RemoveMatch, bool(const std::string& match_rule,
-                                 DBusError* error));
-  MOCK_METHOD4(TryRegisterObjectPath, bool(const ObjectPath& object_path,
-                                           const DBusObjectPathVTable* vtable,
-                                           void* user_data,
-                                           DBusError* error));
-  MOCK_METHOD4(TryRegisterFallback,
-               bool(const ObjectPath& object_path,
-                    const DBusObjectPathVTable* vtable,
-                    void* user_data,
-                    DBusError* error));
-  MOCK_METHOD1(UnregisterObjectPath, void(const ObjectPath& object_path));
-  MOCK_METHOD0(GetDBusTaskRunner, base::SequencedTaskRunner*());
-  MOCK_METHOD0(GetOriginTaskRunner, base::SequencedTaskRunner*());
-  MOCK_METHOD0(HasDBusThread, bool());
-  MOCK_METHOD0(AssertOnOriginThread, void());
-  MOCK_METHOD0(AssertOnDBusThread, void());
-  MOCK_METHOD0(IsConnected, bool());
-
  protected:
   ~MockBus() override;
 };
diff -u a/dbus/mock_exported_object.h b/dbus/mock_exported_object.h
--- a/dbus/mock_exported_object.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/mock_exported_object.h	2020-06-09 18:55:31.704801426 +0200
@@ -19,25 +19,6 @@
   MockExportedObject(Bus* bus,
                      const ObjectPath& object_path);
 
-  MOCK_METHOD3(ExportMethodAndBlock,
-               bool(const std::string& interface_name,
-                    const std::string& method_name,
-                    const MethodCallCallback& method_call_callback));
-  MOCK_METHOD4(ExportMethod,
-               void(const std::string& interface_name,
-                    const std::string& method_name,
-                    const MethodCallCallback& method_call_callback,
-                    OnExportedCallback on_exported_callback));
-  MOCK_METHOD2(UnexportMethodAndBlock,
-               bool(const std::string& interface_name,
-                    const std::string& method_name));
-  MOCK_METHOD3(UnexportMethod,
-               void(const std::string& interface_name,
-                    const std::string& method_name,
-                    OnUnexportedCallback on_unexported_callback));
-  MOCK_METHOD1(SendSignal, void(Signal* signal));
-  MOCK_METHOD0(Unregister, void());
-
  protected:
   ~MockExportedObject() override;
 };
diff -u a/dbus/mock_object_proxy.cc b/dbus/mock_object_proxy.cc
--- a/dbus/mock_object_proxy.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/mock_object_proxy.cc	2020-06-09 18:56:36.120914071 +0200
@@ -17,14 +17,12 @@
 void MockObjectProxy::CallMethod(MethodCall* method_call,
                                  int timeout_ms,
                                  ResponseCallback callback) {
-  DoCallMethod(method_call, timeout_ms, &callback);
 }
 
 void MockObjectProxy::CallMethodWithErrorResponse(
     MethodCall* method_call,
     int timeout_ms,
     ResponseOrErrorCallback callback) {
-  DoCallMethodWithErrorResponse(method_call, timeout_ms, &callback);
 }
 
 void MockObjectProxy::CallMethodWithErrorCallback(
@@ -32,8 +30,6 @@
     int timeout_ms,
     ResponseCallback callback,
     ErrorCallback error_callback) {
-  DoCallMethodWithErrorCallback(method_call, timeout_ms, &callback,
-                                &error_callback);
 }
 
 void MockObjectProxy::ConnectToSignal(
@@ -41,8 +37,6 @@
     const std::string& signal_name,
     SignalCallback signal_callback,
     OnConnectedCallback on_connected_callback) {
-  DoConnectToSignal(interface_name, signal_name, signal_callback,
-                    &on_connected_callback);
 }
 
 }  // namespace dbus
diff -u a/dbus/mock_object_proxy.h b/dbus/mock_object_proxy.h
--- a/dbus/mock_object_proxy.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/mock_object_proxy.h	2020-06-09 18:56:12.441116125 +0200
@@ -22,24 +22,12 @@
                   const std::string& service_name,
                   const ObjectPath& object_path);
 
-  MOCK_METHOD3(CallMethodAndBlockWithErrorDetails,
-               std::unique_ptr<Response>(MethodCall* method_call,
-                                         int timeout_ms,
-                                         ScopedDBusError* error));
-  MOCK_METHOD2(CallMethodAndBlock,
-               std::unique_ptr<Response>(MethodCall* method_call,
-                                         int timeout_ms));
-
   // This method is not mockable because it takes a move-only argument. To work
   // around this, CallMethod() implementation here calls DoCallMethod() which is
   // mockable.
   void CallMethod(MethodCall* method_call,
                   int timeout_ms,
                   ResponseCallback callback) override;
-  MOCK_METHOD3(DoCallMethod,
-               void(MethodCall* method_call,
-                    int timeout_ms,
-                    ResponseCallback* callback));
 
   // This method is not mockable because it takes a move-only argument. To work
   // around this, CallMethodWithErrorResponse() implementation here calls
@@ -47,10 +35,6 @@
   void CallMethodWithErrorResponse(MethodCall* method_call,
                                    int timeout_ms,
                                    ResponseOrErrorCallback callback) override;
-  MOCK_METHOD3(DoCallMethodWithErrorResponse,
-               void(MethodCall* method_call,
-                    int timeout_ms,
-                    ResponseOrErrorCallback* callback));
 
   // This method is not mockable because it takes a move-only argument. To work
   // around this, CallMethodWithErrorCallback() implementation here calls
@@ -59,11 +43,6 @@
                                    int timeout_ms,
                                    ResponseCallback callback,
                                    ErrorCallback error_callback) override;
-  MOCK_METHOD4(DoCallMethodWithErrorCallback,
-               void(MethodCall* method_call,
-                    int timeout_ms,
-                    ResponseCallback* callback,
-                    ErrorCallback* error_callback));
 
   // This method is not mockable because it takes a move-only argument. To work
   // around this, ConnectToSignal() implementation here calls
@@ -72,14 +51,6 @@
                        const std::string& signal_name,
                        SignalCallback signal_callback,
                        OnConnectedCallback on_connected_callback) override;
-  MOCK_METHOD4(DoConnectToSignal,
-               void(const std::string& interface_name,
-                    const std::string& signal_name,
-                    SignalCallback signal_callback,
-                    OnConnectedCallback* on_connected_callback));
-  MOCK_METHOD1(SetNameOwnerChangedCallback,
-               void(NameOwnerChangedCallback callback));
-  MOCK_METHOD0(Detach, void());
 
  protected:
   ~MockObjectProxy() override;
diff -u a/dbus/mock_unittest.cc b/dbus/mock_unittest.cc
--- a/dbus/mock_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/mock_unittest.cc	2020-06-09 19:00:03.202547476 +0200
@@ -31,54 +31,12 @@
   MockTest() = default;
 
   void SetUp() override {
-    // Create a mock bus.
-    Bus::Options options;
-    options.bus_type = Bus::SYSTEM;
-    mock_bus_ = new MockBus(options);
-
-    // Create a mock proxy.
-    mock_proxy_ = new MockObjectProxy(
-        mock_bus_.get(),
-        "org.chromium.TestService",
-        ObjectPath("/org/chromium/TestObject"));
-
-    // Set an expectation so mock_proxy's CallMethodAndBlock() will use
-    // CreateMockProxyResponse() to return responses.
-    EXPECT_CALL(*mock_proxy_.get(), CallMethodAndBlock(_, _))
-        .WillRepeatedly(Invoke(this, &MockTest::CreateMockProxyResponse));
-    EXPECT_CALL(*mock_proxy_.get(),
-                CallMethodAndBlockWithErrorDetails(_, _, _))
-        .WillRepeatedly(
-            Invoke(this, &MockTest::CreateMockProxyResponseWithErrorDetails));
-
-    // Set an expectation so mock_proxy's CallMethod() will use
-    // HandleMockProxyResponseWithMessageLoop() to return responses.
-    EXPECT_CALL(*mock_proxy_.get(), DoCallMethod(_, _, _))
-        .WillRepeatedly(
-            Invoke(this, &MockTest::HandleMockProxyResponseWithMessageLoop));
-
-    // Set an expectation so mock_bus's GetObjectProxy() for the given
-    // service name and the object path will return mock_proxy_.
-    EXPECT_CALL(*mock_bus_.get(),
-                GetObjectProxy("org.chromium.TestService",
-                               ObjectPath("/org/chromium/TestObject")))
-        .WillOnce(Return(mock_proxy_.get()));
-
-    // ShutdownAndBlock() will be called in TearDown().
-    EXPECT_CALL(*mock_bus_.get(), ShutdownAndBlock()).WillOnce(Return());
   }
 
-  void TearDown() override { mock_bus_->ShutdownAndBlock(); }
+  void TearDown() override { }
 
   // Called when the response is received.
   void OnResponse(Response* response) {
-    // |response| will be deleted on exit of the function. Copy the
-    // payload to |response_string_|.
-    if (response) {
-      MessageReader reader(response);
-      ASSERT_TRUE(reader.PopString(&response_string_));
-    }
-    run_loop_->Quit();
   }
 
  protected:
@@ -93,25 +51,11 @@
   // CallMethodAndBlock() for |mock_proxy_|.
   std::unique_ptr<Response> CreateMockProxyResponse(MethodCall* method_call,
                                                     int timeout_ms) {
-    if (method_call->GetInterface() == "org.chromium.TestInterface" &&
-        method_call->GetMember() == "Echo") {
-      MessageReader reader(method_call);
-      std::string text_message;
-      if (reader.PopString(&text_message)) {
-        std::unique_ptr<Response> response = Response::CreateEmpty();
-        MessageWriter writer(response.get());
-        writer.AppendString(text_message);
-        return response;
-      }
-    }
-
-    LOG(ERROR) << "Unexpected method call: " << method_call->ToString();
     return nullptr;
   }
 
   std::unique_ptr<Response> CreateMockProxyResponseWithErrorDetails(
       MethodCall* method_call, int timeout_ms, ScopedDBusError* error) {
-    dbus_set_error(error->get(), DBUS_ERROR_NOT_SUPPORTED, "Not implemented");
     return nullptr;
   }
 
@@ -121,94 +65,13 @@
       MethodCall* method_call,
       int timeout_ms,
       ObjectProxy::ResponseCallback* response_callback) {
-    std::unique_ptr<Response> response =
-        CreateMockProxyResponse(method_call, timeout_ms);
-    task_environment_.GetMainThreadTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&MockTest::RunResponseCallback, base::Unretained(this),
-                       std::move(*response_callback), std::move(response)));
   }
 
   // Runs the given response callback with the given response.
   void RunResponseCallback(
       ObjectProxy::ResponseCallback response_callback,
       std::unique_ptr<Response> response) {
-    std::move(response_callback).Run(response.get());
   }
 };
 
-// This test demonstrates how to mock a synchronous method call using the
-// mock classes.
-TEST_F(MockTest, CallMethodAndBlock) {
-  const char kHello[] = "Hello";
-  // Get an object proxy from the mock bus.
-  ObjectProxy* proxy = mock_bus_->GetObjectProxy(
-      "org.chromium.TestService",
-      ObjectPath("/org/chromium/TestObject"));
-
-  // Create a method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  std::unique_ptr<Response> response(proxy->CallMethodAndBlock(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT));
-
-  // Check the response.
-  ASSERT_TRUE(response.get());
-  MessageReader reader(response.get());
-  std::string text_message;
-  ASSERT_TRUE(reader.PopString(&text_message));
-  // The text message should be echo'ed back.
-  EXPECT_EQ(kHello, text_message);
-}
-
-TEST_F(MockTest, CallMethodAndBlockWithErrorDetails) {
-  // Get an object proxy from the mock bus.
-  ObjectProxy* proxy = mock_bus_->GetObjectProxy(
-      "org.chromium.TestService",
-      ObjectPath("/org/chromium/TestObject"));
-
-  // Create a method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-
-  ScopedDBusError error;
-  // Call the method.
-  std::unique_ptr<Response> response(proxy->CallMethodAndBlockWithErrorDetails(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT, &error));
-
-  // Check the response.
-  ASSERT_FALSE(response.get());
-  ASSERT_TRUE(error.is_set());
-  EXPECT_STREQ(DBUS_ERROR_NOT_SUPPORTED, error.name());
-  EXPECT_STREQ("Not implemented", error.message());
-}
-
-// This test demonstrates how to mock an asynchronous method call using the
-// mock classes.
-TEST_F(MockTest, CallMethod) {
-  const char kHello[] = "hello";
-
-  // Get an object proxy from the mock bus.
-  ObjectProxy* proxy = mock_bus_->GetObjectProxy(
-      "org.chromium.TestService",
-      ObjectPath("/org/chromium/TestObject"));
-
-  // Create a method call.
-  MethodCall method_call("org.chromium.TestInterface", "Echo");
-  MessageWriter writer(&method_call);
-  writer.AppendString(kHello);
-
-  // Call the method.
-  run_loop_.reset(new base::RunLoop);
-  proxy->CallMethod(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-      base::BindOnce(&MockTest::OnResponse, base::Unretained(this)));
-  // Run the message loop to let OnResponse be called.
-  run_loop_->Run();
-
-  EXPECT_EQ(kHello, response_string_);
-}
-
 }  // namespace dbus
diff -u a/dbus/object_manager.cc b/dbus/object_manager.cc
--- a/dbus/object_manager.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/object_manager.cc	2020-06-09 19:09:15.625047808 +0200
@@ -35,16 +35,6 @@
     const ObjectPath& object_path) {
   auto object_manager =
       base::WrapRefCounted(new ObjectManager(bus, service_name, object_path));
-
-  // Set up a match rule and a filter function to handle PropertiesChanged
-  // signals from the service. This is important to avoid any race conditions
-  // that might cause us to miss PropertiesChanged signals once all objects are
-  // initialized via GetManagedObjects.
-  base::PostTaskAndReplyWithResult(
-      bus->GetDBusTaskRunner(), FROM_HERE,
-      base::BindOnce(&ObjectManager::SetupMatchRuleAndFilter, object_manager),
-      base::BindOnce(&ObjectManager::OnSetupMatchRuleAndFilterComplete,
-                     object_manager));
   return object_manager;
 }
 
@@ -56,50 +46,21 @@
       object_path_(object_path),
       setup_success_(false),
       cleanup_called_(false) {
-  LOG_IF(FATAL, !object_path_.IsValid()) << object_path_.value();
-  DVLOG(1) << "Creating ObjectManager for " << service_name_
-           << " " << object_path_.value();
-  DCHECK(bus_);
-  bus_->AssertOnOriginThread();
-  object_proxy_ = bus_->GetObjectProxy(service_name_, object_path_);
-  object_proxy_->SetNameOwnerChangedCallback(base::BindRepeating(
-      &ObjectManager::NameOwnerChanged, weak_ptr_factory_.GetWeakPtr()));
 }
 
 ObjectManager::~ObjectManager() {
-  // Clean up Object structures
-  for (ObjectMap::iterator iter = object_map_.begin();
-       iter != object_map_.end(); ++iter) {
-    Object* object = iter->second;
-
-    for (Object::PropertiesMap::iterator piter = object->properties_map.begin();
-         piter != object->properties_map.end(); ++piter) {
-      PropertySet* properties = piter->second;
-      delete properties;
-    }
-
-    delete object;
-  }
 }
 
 void ObjectManager::RegisterInterface(const std::string& interface_name,
                                       Interface* interface) {
-  interface_map_[interface_name] = interface;
 }
 
 void ObjectManager::UnregisterInterface(const std::string& interface_name) {
-  InterfaceMap::iterator iter = interface_map_.find(interface_name);
-  if (iter != interface_map_.end())
-    interface_map_.erase(iter);
 }
 
 std::vector<ObjectPath> ObjectManager::GetObjects() {
   std::vector<ObjectPath> object_paths;
 
-  for (ObjectMap::iterator iter = object_map_.begin();
-       iter != object_map_.end(); ++iter)
-    object_paths.push_back(iter->first);
-
   return object_paths;
 }
 
@@ -107,444 +68,80 @@
       const std::string& interface_name) {
   std::vector<ObjectPath> object_paths;
 
-  for (ObjectMap::iterator oiter = object_map_.begin();
-       oiter != object_map_.end(); ++oiter) {
-    Object* object = oiter->second;
-
-    Object::PropertiesMap::iterator piter =
-        object->properties_map.find(interface_name);
-    if (piter != object->properties_map.end())
-      object_paths.push_back(oiter->first);
-  }
-
   return object_paths;
 }
 
 ObjectProxy* ObjectManager::GetObjectProxy(const ObjectPath& object_path) {
-  ObjectMap::iterator iter = object_map_.find(object_path);
-  if (iter == object_map_.end())
-    return nullptr;
-
-  Object* object = iter->second;
-  return object->object_proxy;
+  return nullptr;
 }
 
 PropertySet* ObjectManager::GetProperties(const ObjectPath& object_path,
                                           const std::string& interface_name) {
-  ObjectMap::iterator iter = object_map_.find(object_path);
-  if (iter == object_map_.end())
-    return nullptr;
-
-  Object* object = iter->second;
-  Object::PropertiesMap::iterator piter =
-      object->properties_map.find(interface_name);
-  if (piter == object->properties_map.end())
-    return nullptr;
-
-  return piter->second;
+  return nullptr;
 }
 
 void ObjectManager::GetManagedObjects() {
-  MethodCall method_call(kObjectManagerInterface,
-                         kObjectManagerGetManagedObjects);
-
-  object_proxy_->CallMethod(&method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-                            base::BindOnce(&ObjectManager::OnGetManagedObjects,
-                                           weak_ptr_factory_.GetWeakPtr()));
 }
 
 void ObjectManager::CleanUp() {
-  DCHECK(bus_);
-  bus_->AssertOnDBusThread();
-  DCHECK(!cleanup_called_);
-
-  cleanup_called_ = true;
-
-  if (!setup_success_)
-    return;
-
-  bus_->RemoveFilterFunction(&ObjectManager::HandleMessageThunk, this);
-
-  ScopedDBusError error;
-  bus_->RemoveMatch(match_rule_, error.get());
-  if (error.is_set())
-    LOG(ERROR) << "Failed to remove match rule: " << match_rule_;
-
-  match_rule_.clear();
 }
 
 bool ObjectManager::SetupMatchRuleAndFilter() {
-  DCHECK(bus_);
-  DCHECK(!setup_success_);
-  bus_->AssertOnDBusThread();
-
-  if (cleanup_called_)
-    return false;
-
-  if (!bus_->Connect() || !bus_->SetUpAsyncOperations())
-    return false;
-
-  // Try to get |service_name_owner_| from dbus if we haven't received any
-  // NameOwnerChanged signals.
-  if (service_name_owner_.empty()) {
-    service_name_owner_ =
-        bus_->GetServiceOwnerAndBlock(service_name_, Bus::SUPPRESS_ERRORS);
-  }
-
-  const std::string match_rule =
-      base::StringPrintf(
-          "type='signal', sender='%s', interface='%s', member='%s'",
-          service_name_.c_str(),
-          kPropertiesInterface,
-          kPropertiesChanged);
-
-  bus_->AddFilterFunction(&ObjectManager::HandleMessageThunk, this);
-
-  ScopedDBusError error;
-  bus_->AddMatch(match_rule, error.get());
-  if (error.is_set()) {
-    LOG(ERROR) << "ObjectManager failed to add match rule \"" << match_rule
-               << "\". Got " << error.name() << ": " << error.message();
-    bus_->RemoveFilterFunction(&ObjectManager::HandleMessageThunk, this);
-    return false;
-  }
-
-  match_rule_ = match_rule;
-  setup_success_ = true;
-
   return true;
 }
 
 void ObjectManager::OnSetupMatchRuleAndFilterComplete(bool success) {
-  if (!success) {
-    LOG(WARNING) << service_name_ << " " << object_path_.value()
-                 << ": Failed to set up match rule.";
-    return;
-  }
-
-  DCHECK(bus_);
-  DCHECK(object_proxy_);
-  DCHECK(setup_success_);
-  bus_->AssertOnOriginThread();
-
-  // |object_proxy_| is no longer valid if the Bus was shut down before this
-  // call. Don't initiate any other action from the origin thread.
-  if (cleanup_called_)
-    return;
-
-  object_proxy_->ConnectToSignal(
-      kObjectManagerInterface, kObjectManagerInterfacesAdded,
-      base::BindRepeating(&ObjectManager::InterfacesAddedReceived,
-                          weak_ptr_factory_.GetWeakPtr()),
-      base::BindOnce(&ObjectManager::InterfacesAddedConnected,
-                     weak_ptr_factory_.GetWeakPtr()));
-
-  object_proxy_->ConnectToSignal(
-      kObjectManagerInterface, kObjectManagerInterfacesRemoved,
-      base::BindRepeating(&ObjectManager::InterfacesRemovedReceived,
-                          weak_ptr_factory_.GetWeakPtr()),
-      base::BindOnce(&ObjectManager::InterfacesRemovedConnected,
-                     weak_ptr_factory_.GetWeakPtr()));
-
-  if (!service_name_owner_.empty())
-    GetManagedObjects();
-}
-
-// static
-DBusHandlerResult ObjectManager::HandleMessageThunk(DBusConnection* connection,
-                                                    DBusMessage* raw_message,
-                                                    void* user_data) {
-  ObjectManager* self = reinterpret_cast<ObjectManager*>(user_data);
-  return self->HandleMessage(connection, raw_message);
-}
-
-DBusHandlerResult ObjectManager::HandleMessage(DBusConnection* connection,
-                                               DBusMessage* raw_message) {
-  DCHECK(bus_);
-  bus_->AssertOnDBusThread();
-
-  // Handle the message only if it is a signal.
-  // Note that the match rule in SetupMatchRuleAndFilter() is configured to
-  // only accept signals, but we check here just in case.
-  if (dbus_message_get_type(raw_message) != DBUS_MESSAGE_TYPE_SIGNAL)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  // raw_message will be unrefed on exit of the function. Increment the
-  // reference so we can use it in Signal.
-  dbus_message_ref(raw_message);
-  std::unique_ptr<Signal> signal(Signal::FromRawMessage(raw_message));
-
-  const std::string interface = signal->GetInterface();
-  const std::string member = signal->GetMember();
-
-  statistics::AddReceivedSignal(service_name_, interface, member);
-
-  // Handle the signal only if it is PropertiesChanged.
-  // Note that the match rule in SetupMatchRuleAndFilter() is configured to
-  // only accept PropertiesChanged signals, but we check here just in case.
-  const std::string absolute_signal_name =
-      GetAbsoluteMemberName(interface, member);
-  const std::string properties_changed_signal_name =
-      GetAbsoluteMemberName(kPropertiesInterface, kPropertiesChanged);
-  if (absolute_signal_name != properties_changed_signal_name)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  VLOG(1) << "Signal received: " << signal->ToString();
-
-  // Handle the signal only if it is from the service that the ObjectManager
-  // instance is interested in.
-  // Note that the match rule in SetupMatchRuleAndFilter() is configured to
-  // only accept messages from the service name of our interest. However, the
-  // service='...' filter does not work as intended. See crbug.com/507206#14
-  // and #15 for details, hence it's necessary to check the sender here.
-  std::string sender = signal->GetSender();
-  if (service_name_owner_ != sender)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  const ObjectPath path = signal->GetPath();
-
-  if (bus_->HasDBusThread()) {
-    // Post a task to run the method in the origin thread. Transfer ownership of
-    // |signal| to NotifyPropertiesChanged, which will handle the clean up.
-    Signal* released_signal = signal.release();
-    bus_->GetOriginTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ObjectManager::NotifyPropertiesChanged, this,
-                                  path, released_signal));
-  } else {
-    // If the D-Bus thread is not used, just call the callback on the
-    // current thread. Transfer the ownership of |signal| to
-    // NotifyPropertiesChanged.
-    NotifyPropertiesChanged(path, signal.release());
-  }
-
-  // We don't return DBUS_HANDLER_RESULT_HANDLED for signals because other
-  // objects may be interested in them. (e.g. Signals from org.freedesktop.DBus)
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 void ObjectManager::NotifyPropertiesChanged(
     const dbus::ObjectPath object_path,
     Signal* signal) {
-  DCHECK(bus_);
-  bus_->AssertOnOriginThread();
-
-  NotifyPropertiesChangedHelper(object_path, signal);
-
-  // Delete the message on the D-Bus thread. See comments in HandleMessage.
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&base::DeletePointer<Signal>, signal));
 }
 
 void ObjectManager::NotifyPropertiesChangedHelper(
     const dbus::ObjectPath object_path,
     Signal* signal) {
-  DCHECK(bus_);
-  bus_->AssertOnOriginThread();
-
-  MessageReader reader(signal);
-  std::string interface;
-  if (!reader.PopString(&interface)) {
-    LOG(WARNING) << "Property changed signal has wrong parameters: "
-                 << "expected interface name: " << signal->ToString();
-    return;
-  }
-
-  PropertySet* properties = GetProperties(object_path, interface);
-  if (properties)
-    properties->ChangedReceived(signal);
 }
 
 void ObjectManager::OnGetManagedObjects(Response* response) {
-  if (response != nullptr) {
-    MessageReader reader(response);
-    MessageReader array_reader(nullptr);
-    if (!reader.PopArray(&array_reader))
-      return;
-
-    while (array_reader.HasMoreData()) {
-      MessageReader dict_entry_reader(nullptr);
-      ObjectPath object_path;
-      if (!array_reader.PopDictEntry(&dict_entry_reader) ||
-          !dict_entry_reader.PopObjectPath(&object_path))
-        continue;
-
-      UpdateObject(object_path, &dict_entry_reader);
-    }
-
-  } else {
-    LOG(WARNING) << service_name_ << " " << object_path_.value()
-                 << ": Failed to get managed objects";
-  }
 }
 
 void ObjectManager::InterfacesAddedReceived(Signal* signal) {
-  DCHECK(signal);
-  MessageReader reader(signal);
-  ObjectPath object_path;
-  if (!reader.PopObjectPath(&object_path)) {
-    LOG(WARNING) << service_name_ << " " << object_path_.value()
-                 << ": InterfacesAdded signal has incorrect parameters: "
-                 << signal->ToString();
-    return;
-  }
-
-  UpdateObject(object_path, &reader);
 }
 
 void ObjectManager::InterfacesAddedConnected(const std::string& interface_name,
                                              const std::string& signal_name,
                                              bool success) {
-  LOG_IF(WARNING, !success) << service_name_ << " " << object_path_.value()
-                            << ": Failed to connect to InterfacesAdded signal.";
 }
 
 void ObjectManager::InterfacesRemovedReceived(Signal* signal) {
-  DCHECK(signal);
-  MessageReader reader(signal);
-  ObjectPath object_path;
-  std::vector<std::string> interface_names;
-  if (!reader.PopObjectPath(&object_path) ||
-      !reader.PopArrayOfStrings(&interface_names)) {
-    LOG(WARNING) << service_name_ << " " << object_path_.value()
-                 << ": InterfacesRemoved signal has incorrect parameters: "
-                 << signal->ToString();
-    return;
-  }
-
-  for (size_t i = 0; i < interface_names.size(); ++i)
-    RemoveInterface(object_path, interface_names[i]);
 }
 
 void ObjectManager::InterfacesRemovedConnected(
     const std::string& interface_name,
     const std::string& signal_name,
     bool success) {
-  LOG_IF(WARNING, !success) << service_name_ << " " << object_path_.value()
-                            << ": Failed to connect to "
-                            << "InterfacesRemoved signal.";
 }
 
 void ObjectManager::UpdateObject(const ObjectPath& object_path,
                                  MessageReader* reader) {
-  DCHECK(reader);
-  MessageReader array_reader(nullptr);
-  if (!reader->PopArray(&array_reader))
-    return;
-
-  while (array_reader.HasMoreData()) {
-    MessageReader dict_entry_reader(nullptr);
-    std::string interface_name;
-    if (!array_reader.PopDictEntry(&dict_entry_reader) ||
-        !dict_entry_reader.PopString(&interface_name))
-      continue;
-
-    AddInterface(object_path, interface_name, &dict_entry_reader);
-  }
 }
 
 
 void ObjectManager::AddInterface(const ObjectPath& object_path,
                                  const std::string& interface_name,
                                  MessageReader* reader) {
-  InterfaceMap::iterator iiter = interface_map_.find(interface_name);
-  if (iiter == interface_map_.end())
-    return;
-  Interface* interface = iiter->second;
-
-  ObjectMap::iterator oiter = object_map_.find(object_path);
-  Object* object;
-  if (oiter == object_map_.end()) {
-    object = object_map_[object_path] = new Object;
-    object->object_proxy = bus_->GetObjectProxy(service_name_, object_path);
-  } else
-    object = oiter->second;
-
-  Object::PropertiesMap::iterator piter =
-      object->properties_map.find(interface_name);
-  PropertySet* property_set;
-  const bool interface_added = (piter == object->properties_map.end());
-  if (interface_added) {
-    property_set = object->properties_map[interface_name] =
-        interface->CreateProperties(object->object_proxy,
-                                    object_path, interface_name);
-  } else
-    property_set = piter->second;
-
-  property_set->UpdatePropertiesFromReader(reader);
-
-  if (interface_added)
-    interface->ObjectAdded(object_path, interface_name);
 }
 
 void ObjectManager::RemoveInterface(const ObjectPath& object_path,
                                     const std::string& interface_name) {
-  ObjectMap::iterator oiter = object_map_.find(object_path);
-  if (oiter == object_map_.end())
-    return;
-  Object* object = oiter->second;
-
-  Object::PropertiesMap::iterator piter =
-      object->properties_map.find(interface_name);
-  if (piter == object->properties_map.end())
-    return;
-
-  // Inform the interface before removing the properties structure or object
-  // in case it needs details from them to make its own decisions.
-  InterfaceMap::iterator iiter = interface_map_.find(interface_name);
-  if (iiter != interface_map_.end()) {
-    Interface* interface = iiter->second;
-    interface->ObjectRemoved(object_path, interface_name);
-  }
-
-  delete piter->second;
-  object->properties_map.erase(piter);
-
-  if (object->properties_map.empty()) {
-    object_map_.erase(oiter);
-    delete object;
-  }
 }
 
 void ObjectManager::UpdateServiceNameOwner(const std::string& new_owner) {
-  bus_->AssertOnDBusThread();
-  service_name_owner_ = new_owner;
 }
 
 void ObjectManager::NameOwnerChanged(const std::string& old_owner,
                                      const std::string& new_owner) {
-  bus_->AssertOnOriginThread();
-
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&ObjectManager::UpdateServiceNameOwner, this, new_owner));
-
-  if (!old_owner.empty()) {
-    ObjectMap::iterator iter = object_map_.begin();
-    while (iter != object_map_.end()) {
-      ObjectMap::iterator tmp = iter;
-      ++iter;
-
-      // PropertiesMap is mutated by RemoveInterface, and also Object is
-      // destroyed; easier to collect the object path and interface names
-      // and remove them safely.
-      const dbus::ObjectPath object_path = tmp->first;
-      Object* object = tmp->second;
-      std::vector<std::string> interfaces;
-
-      for (Object::PropertiesMap::iterator piter =
-              object->properties_map.begin();
-           piter != object->properties_map.end(); ++piter)
-        interfaces.push_back(piter->first);
-
-      for (std::vector<std::string>::iterator iiter = interfaces.begin();
-           iiter != interfaces.end(); ++iiter)
-        RemoveInterface(object_path, *iiter);
-    }
-
-  }
-
-  if (!new_owner.empty())
-    GetManagedObjects();
 }
 
 }  // namespace dbus
diff -u a/dbus/object_manager.h b/dbus/object_manager.h
--- a/dbus/object_manager.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/object_manager.h	2020-06-09 19:07:43.842383091 +0200
@@ -251,15 +251,6 @@
   // error occurred during setup and true otherwise.
   void OnSetupMatchRuleAndFilterComplete(bool success);
 
-  // Called by dbus:: when a message is received. This is used to filter
-  // PropertiesChanged signals from the correct sender and relay the event to
-  // the correct PropertySet.
-  static DBusHandlerResult HandleMessageThunk(DBusConnection* connection,
-                                              DBusMessage* raw_message,
-                                              void* user_data);
-  DBusHandlerResult HandleMessage(DBusConnection* connection,
-                                  DBusMessage* raw_message);
-
   // Called when a PropertiesChanged signal is received from the sender.
   // This method notifies the relevant PropertySet that it should update its
   // properties based on the received signal. Called from HandleMessage.
diff -u a/dbus/object_manager_unittest.cc b/dbus/object_manager_unittest.cc
--- a/dbus/object_manager_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/object_manager_unittest.cc	2020-06-09 19:01:43.378426712 +0200
@@ -63,146 +63,49 @@
   }
 
   void SetUp() override {
-    // Make the main thread not to allow IO.
-    base::ThreadRestrictions::SetIOAllowed(false);
-
-    // Start the D-Bus thread.
-    dbus_thread_.reset(new base::Thread("D-Bus Thread"));
-    base::Thread::Options thread_options;
-    thread_options.message_pump_type = base::MessagePumpType::IO;
-    ASSERT_TRUE(dbus_thread_->StartWithOptions(thread_options));
-
-    // Start the test service, using the D-Bus thread.
-    TestService::Options options;
-    options.dbus_task_runner = dbus_thread_->task_runner();
-    test_service_.reset(new TestService(options));
-    ASSERT_TRUE(test_service_->StartService());
-    test_service_->WaitUntilServiceIsStarted();
-    ASSERT_TRUE(test_service_->HasDBusThread());
-
-    // Create the client, using the D-Bus thread.
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::SESSION;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_options.dbus_task_runner = dbus_thread_->task_runner();
-    bus_ = new Bus(bus_options);
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    object_manager_ = bus_->GetObjectManager(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestService"));
-    object_manager_->RegisterInterface("org.chromium.TestInterface", this);
-
-    WaitForObject();
   }
 
   void TearDown() override {
-    bus_->ShutdownOnDBusThreadAndBlock();
-
-    // Shut down the service.
-    test_service_->ShutdownAndBlock();
-
-    // Reset to the default.
-    base::ThreadRestrictions::SetIOAllowed(true);
-
-    // Stopping a thread is considered an IO operation, so do this after
-    // allowing IO.
-    test_service_->Stop();
-
-    base::RunLoop().RunUntilIdle();
   }
 
   void MethodCallback(Response* response) {
-    method_callback_called_ = true;
-    run_loop_->Quit();
   }
 
   // Called from the PropertiesChangedAsObjectsReceived test case. The test will
   // not run the message loop if it receives the expected PropertiesChanged
   // signal before the timeout. This method immediately fails the test.
   void PropertiesChangedTestTimeout() {
-    timeout_expired_ = true;
-    run_loop_->Quit();
-
-    FAIL() << "Never received PropertiesChanged";
   }
 
  protected:
   // Called when an object is added.
   void ObjectAdded(const ObjectPath& object_path,
                    const std::string& interface_name) override {
-    added_objects_.push_back(std::make_pair(object_path, interface_name));
-    run_loop_->Quit();
   }
 
   // Called when an object is removed.
   void ObjectRemoved(const ObjectPath& object_path,
                      const std::string& interface_name) override {
-    removed_objects_.push_back(std::make_pair(object_path, interface_name));
-    run_loop_->Quit();
   }
 
   // Called when a property value is updated.
   void OnPropertyChanged(const ObjectPath& object_path,
                          const std::string& name) {
-    // Store the value of the "Name" property if that's the one that
-    // changed.
-    Properties* properties = static_cast<Properties*>(
-        object_manager_->GetProperties(
-            object_path,
-            "org.chromium.TestInterface"));
-    if (name == properties->name.name())
-      last_name_value_ = properties->name.value();
-
-    // Store the updated property.
-    updated_properties_.push_back(name);
-    run_loop_->Quit();
   }
 
   static const size_t kExpectedObjects = 1;
   static const size_t kExpectedProperties = 4;
 
   void WaitForObject() {
-    while (added_objects_.size() < kExpectedObjects ||
-           updated_properties_.size() < kExpectedProperties) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
-    for (size_t i = 0; i < kExpectedObjects; ++i)
-      added_objects_.erase(added_objects_.begin());
-    for (size_t i = 0; i < kExpectedProperties; ++i)
-      updated_properties_.erase(updated_properties_.begin());
   }
 
   void WaitForRemoveObject() {
-    while (removed_objects_.size() < kExpectedObjects) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
-    for (size_t i = 0; i < kExpectedObjects; ++i)
-      removed_objects_.erase(removed_objects_.begin());
   }
 
   void WaitForMethodCallback() {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-    method_callback_called_ = false;
   }
 
   void PerformAction(const std::string& action, const ObjectPath& object_path) {
-    ObjectProxy* object_proxy = bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
-
-    MethodCall method_call("org.chromium.TestInterface", "PerformAction");
-    MessageWriter writer(&method_call);
-    writer.AppendString(action);
-    writer.AppendObjectPath(object_path);
-
-    object_proxy->CallMethod(&method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-                             base::BindOnce(&ObjectManagerTest::MethodCallback,
-                                            base::Unretained(this)));
-    WaitForMethodCallback();
   }
 
   base::test::SingleThreadTaskEnvironment task_environment_;
@@ -222,199 +125,4 @@
   bool method_callback_called_;
 };
 
-
-TEST_F(ObjectManagerTest, InitialObject) {
-  ObjectProxy* object_proxy = object_manager_->GetObjectProxy(
-      ObjectPath("/org/chromium/TestObject"));
-  EXPECT_NE(nullptr, object_proxy);
-
-  Properties* properties = static_cast<Properties*>(
-      object_manager_->GetProperties(ObjectPath("/org/chromium/TestObject"),
-                                     "org.chromium.TestInterface"));
-  EXPECT_NE(nullptr, properties);
-
-  EXPECT_EQ("TestService", properties->name.value());
-  EXPECT_EQ(10, properties->version.value());
-
-  std::vector<std::string> methods = properties->methods.value();
-  ASSERT_EQ(4U, methods.size());
-  EXPECT_EQ("Echo", methods[0]);
-  EXPECT_EQ("SlowEcho", methods[1]);
-  EXPECT_EQ("AsyncEcho", methods[2]);
-  EXPECT_EQ("BrokenMethod", methods[3]);
-
-  std::vector<ObjectPath> objects = properties->objects.value();
-  ASSERT_EQ(1U, objects.size());
-  EXPECT_EQ(ObjectPath("/TestObjectPath"), objects[0]);
-}
-
-TEST_F(ObjectManagerTest, UnknownObjectProxy) {
-  ObjectProxy* object_proxy = object_manager_->GetObjectProxy(
-      ObjectPath("/org/chromium/UnknownObject"));
-  EXPECT_EQ(nullptr, object_proxy);
-}
-
-TEST_F(ObjectManagerTest, UnknownObjectProperties) {
-  Properties* properties = static_cast<Properties*>(
-      object_manager_->GetProperties(ObjectPath("/org/chromium/UnknownObject"),
-                                     "org.chromium.TestInterface"));
-  EXPECT_EQ(nullptr, properties);
-}
-
-TEST_F(ObjectManagerTest, UnknownInterfaceProperties) {
-  Properties* properties = static_cast<Properties*>(
-      object_manager_->GetProperties(ObjectPath("/org/chromium/TestObject"),
-                                     "org.chromium.UnknownService"));
-  EXPECT_EQ(nullptr, properties);
-}
-
-TEST_F(ObjectManagerTest, GetObjects) {
-  std::vector<ObjectPath> object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(1U, object_paths.size());
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[0]);
-}
-
-TEST_F(ObjectManagerTest, GetObjectsWithInterface) {
-  std::vector<ObjectPath> object_paths =
-      object_manager_->GetObjectsWithInterface("org.chromium.TestInterface");
-  ASSERT_EQ(1U, object_paths.size());
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[0]);
-}
-
-TEST_F(ObjectManagerTest, GetObjectsWithUnknownInterface) {
-  std::vector<ObjectPath> object_paths =
-      object_manager_->GetObjectsWithInterface("org.chromium.UnknownService");
-  EXPECT_EQ(0U, object_paths.size());
-}
-
-TEST_F(ObjectManagerTest, SameObject) {
-  ObjectManager* object_manager = bus_->GetObjectManager(
-      test_service_->service_name(),
-      ObjectPath("/org/chromium/TestService"));
-  EXPECT_EQ(object_manager_, object_manager);
-}
-
-TEST_F(ObjectManagerTest, DifferentObjectForService) {
-  ObjectManager* object_manager = bus_->GetObjectManager(
-      "org.chromium.DifferentService",
-      ObjectPath("/org/chromium/TestService"));
-  EXPECT_NE(object_manager_, object_manager);
-}
-
-TEST_F(ObjectManagerTest, DifferentObjectForPath) {
-  ObjectManager* object_manager = bus_->GetObjectManager(
-      test_service_->service_name(),
-      ObjectPath("/org/chromium/DifferentService"));
-  EXPECT_NE(object_manager_, object_manager);
-}
-
-TEST_F(ObjectManagerTest, SecondObject) {
-  PerformAction("AddObject", ObjectPath("/org/chromium/SecondObject"));
-  WaitForObject();
-
-  ObjectProxy* object_proxy = object_manager_->GetObjectProxy(
-      ObjectPath("/org/chromium/SecondObject"));
-  EXPECT_NE(nullptr, object_proxy);
-
-  Properties* properties = static_cast<Properties*>(
-      object_manager_->GetProperties(ObjectPath("/org/chromium/SecondObject"),
-                                     "org.chromium.TestInterface"));
-  EXPECT_NE(nullptr, properties);
-
-  std::vector<ObjectPath> object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(2U, object_paths.size());
-
-  std::sort(object_paths.begin(), object_paths.end());
-  EXPECT_EQ(ObjectPath("/org/chromium/SecondObject"), object_paths[0]);
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[1]);
-
-  object_paths =
-      object_manager_->GetObjectsWithInterface("org.chromium.TestInterface");
-  ASSERT_EQ(2U, object_paths.size());
-
-  std::sort(object_paths.begin(), object_paths.end());
-  EXPECT_EQ(ObjectPath("/org/chromium/SecondObject"), object_paths[0]);
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[1]);
-}
-
-TEST_F(ObjectManagerTest, RemoveSecondObject) {
-  PerformAction("AddObject", ObjectPath("/org/chromium/SecondObject"));
-  WaitForObject();
-
-  std::vector<ObjectPath> object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(2U, object_paths.size());
-
-  PerformAction("RemoveObject", ObjectPath("/org/chromium/SecondObject"));
-  WaitForRemoveObject();
-
-  ObjectProxy* object_proxy = object_manager_->GetObjectProxy(
-      ObjectPath("/org/chromium/SecondObject"));
-  EXPECT_EQ(nullptr, object_proxy);
-
-  Properties* properties = static_cast<Properties*>(
-      object_manager_->GetProperties(ObjectPath("/org/chromium/SecondObject"),
-                                     "org.chromium.TestInterface"));
-  EXPECT_EQ(nullptr, properties);
-
-  object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(1U, object_paths.size());
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[0]);
-
-  object_paths =
-      object_manager_->GetObjectsWithInterface("org.chromium.TestInterface");
-  ASSERT_EQ(1U, object_paths.size());
-  EXPECT_EQ(ObjectPath("/org/chromium/TestObject"), object_paths[0]);
-}
-
-TEST_F(ObjectManagerTest, OwnershipLost) {
-  PerformAction("ReleaseOwnership", ObjectPath("/org/chromium/TestService"));
-  WaitForRemoveObject();
-
-  std::vector<ObjectPath> object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(0U, object_paths.size());
-}
-
-TEST_F(ObjectManagerTest, OwnershipLostAndRegained) {
-  PerformAction("Ownership", ObjectPath("/org/chromium/TestService"));
-  WaitForRemoveObject();
-  WaitForObject();
-
-  std::vector<ObjectPath> object_paths = object_manager_->GetObjects();
-  ASSERT_EQ(1U, object_paths.size());
-}
-
-TEST_F(ObjectManagerTest, PropertiesChangedAsObjectsReceived) {
-  // Remove the existing object manager.
-  object_manager_->UnregisterInterface("org.chromium.TestInterface");
-  run_loop_.reset(new base::RunLoop);
-  EXPECT_TRUE(bus_->RemoveObjectManager(
-      test_service_->service_name(),
-      ObjectPath("/org/chromium/TestService"),
-      run_loop_->QuitClosure()));
-  run_loop_->Run();
-
-  PerformAction("SetSendImmediatePropertiesChanged",
-                ObjectPath("/org/chromium/TestService"));
-
-  object_manager_ = bus_->GetObjectManager(
-      test_service_->service_name(),
-      ObjectPath("/org/chromium/TestService"));
-  object_manager_->RegisterInterface("org.chromium.TestInterface", this);
-
-  // The newly created object manager should call GetManagedObjects immediately
-  // after setting up the match rule for PropertiesChanged. We should process
-  // the PropertiesChanged event right after that. If we don't receive it within
-  // 2 seconds, then fail the test.
-  task_environment_.GetMainThreadTaskRunner()->PostDelayedTask(
-      FROM_HERE,
-      base::BindOnce(&ObjectManagerTest::PropertiesChangedTestTimeout,
-                     base::Unretained(this)),
-      base::TimeDelta::FromSeconds(2));
-
-  while (last_name_value_ != "ChangedTestServiceName" && !timeout_expired_) {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-  }
-}
-
 }  // namespace dbus
diff -u a/dbus/object_proxy.cc b/dbus/object_proxy.cc
--- a/dbus/object_proxy.cc	2020-05-18 20:40:23.000000000 +0200
+++ b/dbus/object_proxy.cc	2020-06-09 19:21:42.686427427 +0200
@@ -56,59 +56,16 @@
     ResponseOrErrorCallback callback)
     : origin_task_runner_(std::move(origin_task_runner)),
       callback_(std::move(callback)) {
-  DCHECK(origin_task_runner_.get());
-  DCHECK(!callback_.is_null());
 }
 
 ObjectProxy::ReplyCallbackHolder::ReplyCallbackHolder(
     ReplyCallbackHolder&& other) = default;
 
 ObjectProxy::ReplyCallbackHolder::~ReplyCallbackHolder() {
-  if (callback_.is_null()) {
-    // This is the regular case.
-    // CallMethod and its family creates this object on the origin thread,
-    // PostTask()s to the D-Bus thread for actual D-Bus communication,
-    // then PostTask()s back to the origin thread to invoke the |callback_|.
-    // At that timing, the ownership of callback should be released via
-    // ReleaseCallback().
-    // Otherwise, this instance was moved to another one. Do nothing in
-    // either case.
-    return;
-  }
-
-  // The only case where |origin_task_runner_| becomes nullptr is that
-  // this is moved. In such a case, |callback_| should be nullptr, too, so it
-  // should be handled above. Thus, here |origin_task_runner_| must not be
-  // nullptr.
-  DCHECK(origin_task_runner_.get());
-
-  if (origin_task_runner_->RunsTasksInCurrentSequence()) {
-    // Destroyed on the origin thread. This happens when PostTask()ing to
-    // the D-Bus thread fails. The |callback_| can be destroyed on the
-    // current thread safely. Do nothing here, and let member destruction
-    // destroy the callback.
-    return;
-  }
-
-  // Here is on D-Bus thread, so try to PostTask() to destroy the callback.
-  // to the origin thread.
-  // The |origin_task_runner_| may already have stopped. E.g., on Chrome's
-  // shutdown the message loop of the UI thread (= the origin thread) stops
-  // before D-Bus threaed's. In such a case, PostTask() fails. Because we
-  // cannot do much thing here, instead, simply leak the callback rather than
-  // destroying it on the D-Bus thread, which could be unexpected from the
-  // direct or indirect caller of CallMethod.
-  auto* callback_to_be_deleted =
-      new ResponseOrErrorCallback(std::move(callback_));
-  ANNOTATE_LEAKING_OBJECT_PTR(callback_to_be_deleted);
-  origin_task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&base::DeletePointer<ResponseOrErrorCallback>,
-                                callback_to_be_deleted));
 }
 
 ObjectProxy::ResponseOrErrorCallback
 ObjectProxy::ReplyCallbackHolder::ReleaseCallback() {
-  DCHECK(origin_task_runner_->RunsTasksInCurrentSequence());
   return std::move(callback_);
 }
 
@@ -121,11 +78,9 @@
       object_path_(object_path),
       ignore_service_unknown_errors_(
           options & IGNORE_SERVICE_UNKNOWN_ERRORS) {
-  LOG_IF(FATAL, !object_path_.IsValid()) << object_path_.value();
 }
 
 ObjectProxy::~ObjectProxy() {
-  DCHECK(pending_calls_.empty());
 }
 
 // Originally we tried to make |method_call| a const reference, but we
@@ -135,283 +90,58 @@
     MethodCall* method_call,
     int timeout_ms,
     ScopedDBusError* error) {
-  bus_->AssertOnDBusThread();
-
-  if (!bus_->Connect() ||
-      !method_call->SetDestination(service_name_) ||
-      !method_call->SetPath(object_path_))
-    return std::unique_ptr<Response>();
-
-  DBusMessage* request_message = method_call->raw_message();
-
-  // Send the message synchronously.
-  const base::TimeTicks start_time = base::TimeTicks::Now();
-  DBusMessage* response_message =
-      bus_->SendWithReplyAndBlock(request_message, timeout_ms, error->get());
-  // Record if the method call is successful, or not. 1 if successful.
-  UMA_HISTOGRAM_ENUMERATION("DBus.SyncMethodCallSuccess",
-                            response_message ? 1 : 0,
-                            kSuccessRatioHistogramMaxValue);
-  statistics::AddBlockingSentMethodCall(service_name_,
-                                        method_call->GetInterface(),
-                                        method_call->GetMember());
-
-  if (!response_message) {
-    LogMethodCallFailure(method_call->GetInterface(),
-                         method_call->GetMember(),
-                         error->is_set() ? error->name() : "unknown error type",
-                         error->is_set() ? error->message() : "");
-    return std::unique_ptr<Response>();
-  }
-  // Record time spent for the method call. Don't include failures.
-  UMA_HISTOGRAM_TIMES("DBus.SyncMethodCallTime",
-                      base::TimeTicks::Now() - start_time);
-
-  return Response::FromRawMessage(response_message);
+  return std::unique_ptr<Response>();
 }
 
 std::unique_ptr<Response> ObjectProxy::CallMethodAndBlock(
     MethodCall* method_call,
     int timeout_ms) {
-  ScopedDBusError error;
-  return CallMethodAndBlockWithErrorDetails(method_call, timeout_ms, &error);
+  return std::unique_ptr<Response>();
 }
 
 void ObjectProxy::CallMethod(MethodCall* method_call,
                              int timeout_ms,
                              ResponseCallback callback) {
-  auto internal_callback = base::BindOnce(
-      &ObjectProxy::OnCallMethod, this, method_call->GetInterface(),
-      method_call->GetMember(), std::move(callback));
-
-  CallMethodWithErrorResponse(method_call, timeout_ms,
-                              std::move(internal_callback));
 }
 
 void ObjectProxy::CallMethodWithErrorResponse(
     MethodCall* method_call,
     int timeout_ms,
     ResponseOrErrorCallback callback) {
-  bus_->AssertOnOriginThread();
-
-  const base::TimeTicks start_time = base::TimeTicks::Now();
-
-  ReplyCallbackHolder callback_holder(bus_->GetOriginTaskRunner(),
-                                      std::move(callback));
-
-  if (!method_call->SetDestination(service_name_) ||
-      !method_call->SetPath(object_path_)) {
-    // In case of a failure, run the error callback with nullptr.
-    base::OnceClosure task =
-        base::BindOnce(&ObjectProxy::RunResponseOrErrorCallback, this,
-                       std::move(callback_holder), start_time,
-                       nullptr /* response */, nullptr /* error_response */);
-    bus_->GetOriginTaskRunner()->PostTask(FROM_HERE, std::move(task));
-    return;
-  }
-
-  // Increment the reference count so we can safely reference the
-  // underlying request message until the method call is complete. This
-  // will be unref'ed in StartAsyncMethodCall().
-  DBusMessage* request_message = method_call->raw_message();
-  dbus_message_ref(request_message);
-
-  statistics::AddSentMethodCall(service_name_,
-                                method_call->GetInterface(),
-                                method_call->GetMember());
-
-  // Wait for the response in the D-Bus thread.
-  base::OnceClosure task =
-      base::BindOnce(&ObjectProxy::StartAsyncMethodCall, this, timeout_ms,
-                     request_message, std::move(callback_holder), start_time);
-  bus_->GetDBusTaskRunner()->PostTask(FROM_HERE, std::move(task));
 }
 
 void ObjectProxy::CallMethodWithErrorCallback(MethodCall* method_call,
                                               int timeout_ms,
                                               ResponseCallback callback,
                                               ErrorCallback error_callback) {
-  auto internal_callback = base::BindOnce(
-      [](ResponseCallback callback, ErrorCallback error_callback,
-         Response* response, ErrorResponse* error_response) {
-        if (response) {
-          std::move(callback).Run(response);
-        } else {
-          std::move(error_callback).Run(error_response);
-        }
-      },
-      std::move(callback), std::move(error_callback));
-
-  CallMethodWithErrorResponse(method_call, timeout_ms,
-                              std::move(internal_callback));
 }
 
 void ObjectProxy::ConnectToSignal(const std::string& interface_name,
                                   const std::string& signal_name,
                                   SignalCallback signal_callback,
                                   OnConnectedCallback on_connected_callback) {
-  bus_->AssertOnOriginThread();
-
-  if (bus_->HasDBusThread()) {
-    base::PostTaskAndReplyWithResult(
-        bus_->GetDBusTaskRunner(), FROM_HERE,
-        base::BindOnce(&ObjectProxy::ConnectToSignalInternal, this,
-                       interface_name, signal_name, signal_callback),
-        base::BindOnce(std::move(on_connected_callback), interface_name,
-                       signal_name));
-  } else {
-    // If the bus doesn't have a dedicated dbus thread we need to call
-    // ConnectToSignalInternal directly otherwise we might miss a signal
-    // that is currently queued if we do a PostTask.
-    const bool success =
-        ConnectToSignalInternal(interface_name, signal_name, signal_callback);
-    std::move(on_connected_callback).Run(interface_name, signal_name, success);
-  }
 }
 
 void ObjectProxy::SetNameOwnerChangedCallback(
     NameOwnerChangedCallback callback) {
-  bus_->AssertOnOriginThread();
-
-  name_owner_changed_callback_ = callback;
-
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&ObjectProxy::TryConnectToNameOwnerChangedSignal, this));
 }
 
 void ObjectProxy::WaitForServiceToBeAvailable(
     WaitForServiceToBeAvailableCallback callback) {
-  bus_->AssertOnOriginThread();
-
-  wait_for_service_to_be_available_callbacks_.push_back(std::move(callback));
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&ObjectProxy::WaitForServiceToBeAvailableInternal, this));
 }
 
 void ObjectProxy::Detach() {
-  bus_->AssertOnDBusThread();
-
-  if (bus_->IsConnected())
-    bus_->RemoveFilterFunction(&ObjectProxy::HandleMessageThunk, this);
-
-  for (const auto& match_rule : match_rules_) {
-    ScopedDBusError error;
-    bus_->RemoveMatch(match_rule, error.get());
-    if (error.is_set()) {
-      // There is nothing we can do to recover, so just print the error.
-      LOG(ERROR) << "Failed to remove match rule: " << match_rule;
-    }
-  }
-  match_rules_.clear();
-
-  for (auto* pending_call : pending_calls_) {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-
-    dbus_pending_call_cancel(pending_call);
-    dbus_pending_call_unref(pending_call);
-  }
-  pending_calls_.clear();
 }
 
 void ObjectProxy::StartAsyncMethodCall(int timeout_ms,
-                                       DBusMessage* request_message,
+                                       const void* request_message,
                                        ReplyCallbackHolder callback_holder,
                                        base::TimeTicks start_time) {
-  bus_->AssertOnDBusThread();
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  if (!bus_->Connect() || !bus_->SetUpAsyncOperations()) {
-    // In case of a failure, run the error callback with nullptr.
-    base::OnceClosure task =
-        base::BindOnce(&ObjectProxy::RunResponseOrErrorCallback, this,
-                       std::move(callback_holder), start_time,
-                       nullptr /* response */, nullptr /* error_response */);
-    bus_->GetOriginTaskRunner()->PostTask(FROM_HERE, std::move(task));
-
-    dbus_message_unref(request_message);
-    return;
-  }
-
-  DBusPendingCall* dbus_pending_call = nullptr;
-  bus_->SendWithReply(request_message, &dbus_pending_call, timeout_ms);
-
-  using PendingCallback =
-      base::OnceCallback<void(DBusPendingCall * pending_call)>;
-  // This returns false only when unable to allocate memory.
-  const bool success = dbus_pending_call_set_notify(
-      dbus_pending_call,
-      [](DBusPendingCall* pending_call, void* user_data) {
-        std::move(*static_cast<PendingCallback*>(user_data)).Run(pending_call);
-      },
-      // PendingCallback instance is owned by libdbus.
-      new PendingCallback(base::BindOnce(&ObjectProxy::OnPendingCallIsComplete,
-                                         this, std::move(callback_holder),
-                                         start_time)),
-      [](void* user_data) { delete static_cast<PendingCallback*>(user_data); });
-  CHECK(success) << "Unable to allocate memory";
-  pending_calls_.insert(dbus_pending_call);
-
-  // It's now safe to unref the request message.
-  dbus_message_unref(request_message);
 }
 
 void ObjectProxy::OnPendingCallIsComplete(ReplyCallbackHolder callback_holder,
                                           base::TimeTicks start_time,
-                                          DBusPendingCall* pending_call) {
-  bus_->AssertOnDBusThread();
-  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
-                                                base::BlockingType::MAY_BLOCK);
-
-  DBusMessage* response_message = dbus_pending_call_steal_reply(pending_call);
-
-  // Either |response| or |error_response| takes ownership of the
-  // |response_message|.
-  std::unique_ptr<Response> response;
-  std::unique_ptr<ErrorResponse> error_response;
-  if (dbus_message_get_type(response_message) == DBUS_MESSAGE_TYPE_ERROR) {
-    error_response = ErrorResponse::FromRawMessage(response_message);
-  } else {
-    response = Response::FromRawMessage(response_message);
-  }
-
-  base::OnceClosure task =
-      base::BindOnce(&ObjectProxy::RunResponseOrErrorCallback, this,
-                     std::move(callback_holder), start_time, response.get(),
-                     error_response.get());
-
-  // The message should be deleted on the D-Bus thread for a complicated
-  // reason:
-  //
-  // libdbus keeps track of the number of bytes in the incoming message
-  // queue to ensure that the data size in the queue is manageable. The
-  // bookkeeping is partly done via dbus_message_unref(), and immediately
-  // asks the client code (Chrome) to stop monitoring the underlying
-  // socket, if the number of bytes exceeds a certian number, which is set
-  // to 63MB, per dbus-transport.cc:
-  //
-  //   /* Try to default to something that won't totally hose the system,
-  //    * but doesn't impose too much of a limitation.
-  //    */
-  //   transport->max_live_messages_size = _DBUS_ONE_MEGABYTE * 63;
-  //
-  // The monitoring of the socket is done on the D-Bus thread (see Watch
-  // class in bus.cc), hence we should stop the monitoring on D-Bus thread.
-  bus_->GetOriginTaskRunner()->PostTaskAndReply(
-      FROM_HERE, std::move(task),
-      base::BindOnce(
-          [](Response* response, ErrorResponse* error_response) {
-            // Do nothing.
-          },
-          base::Owned(response.release()),
-          base::Owned(error_response.release())));
-
-  // Remove the pending call from the set.
-  pending_calls_.erase(pending_call);
-  dbus_pending_call_unref(pending_call);
+                                          const void* pending_call) {
 }
 
 void ObjectProxy::RunResponseOrErrorCallback(
@@ -419,194 +149,27 @@
     base::TimeTicks start_time,
     Response* response,
     ErrorResponse* error_response) {
-  bus_->AssertOnOriginThread();
-  callback_holder.ReleaseCallback().Run(response, error_response);
-
-  if (response) {
-    // Record time spent for the method call. Don't include failures.
-    UMA_HISTOGRAM_TIMES("DBus.AsyncMethodCallTime",
-                        base::TimeTicks::Now() - start_time);
-  }
-  // Record if the method call is successful, or not. 1 if successful.
-  UMA_HISTOGRAM_ENUMERATION("DBus.AsyncMethodCallSuccess", response ? 1 : 0,
-                            kSuccessRatioHistogramMaxValue);
 }
 
 bool ObjectProxy::ConnectToNameOwnerChangedSignal() {
-  bus_->AssertOnDBusThread();
-
-  if (!bus_->Connect() || !bus_->SetUpAsyncOperations())
-    return false;
-
-  bus_->AddFilterFunction(&ObjectProxy::HandleMessageThunk, this);
-
-  // Add a match_rule listening NameOwnerChanged for the well-known name
-  // |service_name_|.
-  const std::string name_owner_changed_match_rule =
-      base::StringPrintf(
-          "type='signal',interface='org.freedesktop.DBus',"
-          "member='NameOwnerChanged',path='/org/freedesktop/DBus',"
-          "sender='org.freedesktop.DBus',arg0='%s'",
-          service_name_.c_str());
-
-  const bool success =
-      AddMatchRuleWithoutCallback(name_owner_changed_match_rule,
-                                  "org.freedesktop.DBus.NameOwnerChanged");
-
-  // Try getting the current name owner. It's not guaranteed that we can get
-  // the name owner at this moment, as the service may not yet be started. If
-  // that's the case, we'll get the name owner via NameOwnerChanged signal,
-  // as soon as the service is started.
-  UpdateNameOwnerAndBlock();
-
-  return success;
+  return true;
 }
 
 void ObjectProxy::TryConnectToNameOwnerChangedSignal() {
-  bus_->AssertOnDBusThread();
-
-  bool success = ConnectToNameOwnerChangedSignal();
-  LOG_IF(WARNING, !success)
-      << "Failed to connect to NameOwnerChanged signal for object: "
-      << object_path_.value();
 }
 
 bool ObjectProxy::ConnectToSignalInternal(const std::string& interface_name,
                                           const std::string& signal_name,
                                           SignalCallback signal_callback) {
-  bus_->AssertOnDBusThread();
-
-  if (!ConnectToNameOwnerChangedSignal())
-    return false;
-
-  const std::string absolute_signal_name =
-      GetAbsoluteMemberName(interface_name, signal_name);
-
-  // Add a match rule so the signal goes through HandleMessage().
-  const std::string match_rule = base::StringPrintf(
-      "type='signal', sender='%s', interface='%s', path='%s'",
-      service_name_.c_str(), interface_name.c_str(),
-      object_path_.value().c_str());
-  return AddMatchRuleWithCallback(match_rule,
-                                  absolute_signal_name,
-                                  signal_callback);
+  return true;
 }
 
 void ObjectProxy::WaitForServiceToBeAvailableInternal() {
-  bus_->AssertOnDBusThread();
-
-  if (!ConnectToNameOwnerChangedSignal()) {  // Failed to connect to the signal.
-    const bool service_is_ready = false;
-    bus_->GetOriginTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&ObjectProxy::RunWaitForServiceToBeAvailableCallbacks,
-                       this, service_is_ready));
-    return;
-  }
-
-  const bool service_is_available = !service_name_owner_.empty();
-  if (service_is_available) {  // Service is already available.
-    bus_->GetOriginTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&ObjectProxy::RunWaitForServiceToBeAvailableCallbacks,
-                       this, service_is_available));
-    return;
-  }
-}
-
-DBusHandlerResult ObjectProxy::HandleMessage(
-    DBusConnection* connection,
-    DBusMessage* raw_message) {
-  bus_->AssertOnDBusThread();
-
-  if (dbus_message_get_type(raw_message) != DBUS_MESSAGE_TYPE_SIGNAL)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  // raw_message will be unrefed on exit of the function. Increment the
-  // reference so we can use it in Signal.
-  dbus_message_ref(raw_message);
-  std::unique_ptr<Signal> signal(Signal::FromRawMessage(raw_message));
-
-  // Verify the signal comes from the object we're proxying for, this is
-  // our last chance to return DBUS_HANDLER_RESULT_NOT_YET_HANDLED and
-  // allow other object proxies to handle instead.
-  const ObjectPath path = signal->GetPath();
-  if (path != object_path_) {
-    if (path.value() == kDBusSystemObjectPath &&
-        signal->GetMember() == kNameOwnerChangedMember) {
-      // Handle NameOwnerChanged separately
-      return HandleNameOwnerChanged(std::move(signal));
-    }
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
-
-  std::string sender = signal->GetSender();
-  // Ignore message from sender we are not interested in.
-  if (service_name_owner_ != sender)
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-  const std::string interface = signal->GetInterface();
-  const std::string member = signal->GetMember();
-
-  statistics::AddReceivedSignal(service_name_, interface, member);
-
-  // Check if we know about the signal.
-  const std::string absolute_signal_name = GetAbsoluteMemberName(
-      interface, member);
-  MethodTable::const_iterator iter = method_table_.find(absolute_signal_name);
-  if (iter == method_table_.end()) {
-    // Don't know about the signal.
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-  }
-  VLOG(1) << "Signal received: " << signal->ToString();
-
-  const base::TimeTicks start_time = base::TimeTicks::Now();
-  if (bus_->HasDBusThread()) {
-    // Post a task to run the method in the origin thread.
-    // Transfer the ownership of |signal| to RunMethod().
-    // |released_signal| will be deleted in RunMethod().
-    Signal* released_signal = signal.release();
-    bus_->GetOriginTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ObjectProxy::RunMethod, this, start_time,
-                                  iter->second, released_signal));
-  } else {
-    const base::TimeTicks start_time = base::TimeTicks::Now();
-    // If the D-Bus thread is not used, just call the callback on the
-    // current thread. Transfer the ownership of |signal| to RunMethod().
-    Signal* released_signal = signal.release();
-    RunMethod(start_time, iter->second, released_signal);
-  }
-
-  // We don't return DBUS_HANDLER_RESULT_HANDLED for signals because other
-  // objects may be interested in them. (e.g. Signals from org.freedesktop.DBus)
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 void ObjectProxy::RunMethod(base::TimeTicks start_time,
                             std::vector<SignalCallback> signal_callbacks,
                             Signal* signal) {
-  bus_->AssertOnOriginThread();
-
-  for (std::vector<SignalCallback>::iterator iter = signal_callbacks.begin();
-       iter != signal_callbacks.end(); ++iter)
-    iter->Run(signal);
-
-  // Delete the message on the D-Bus thread. See comments in
-  // RunResponseOrErrorCallback().
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&base::DeletePointer<Signal>, signal));
-
-  // Record time spent for handling the signal.
-  UMA_HISTOGRAM_TIMES("DBus.SignalHandleTime",
-                      base::TimeTicks::Now() - start_time);
-}
-
-DBusHandlerResult ObjectProxy::HandleMessageThunk(
-    DBusConnection* connection,
-    DBusMessage* raw_message,
-    void* user_data) {
-  ObjectProxy* self = reinterpret_cast<ObjectProxy*>(user_data);
-  return self->HandleMessage(connection, raw_message);
 }
 
 void ObjectProxy::LogMethodCallFailure(
@@ -614,22 +177,6 @@
     const base::StringPiece& method_name,
     const base::StringPiece& error_name,
     const base::StringPiece& error_message) const {
-  if (ignore_service_unknown_errors_ &&
-      (error_name == kErrorServiceUnknown || error_name == kErrorObjectUnknown))
-    return;
-
-  std::ostringstream msg;
-  msg << "Failed to call method: " << interface_name << "." << method_name
-      << ": object_path= " << object_path_.value()
-      << ": " << error_name << ": " << error_message;
-
-  // "UnknownObject" indicates that an object or service is no longer available,
-  // e.g. a Shill network service has gone out of range. Treat these as warnings
-  // not errors.
-  if (error_name == kErrorObjectUnknown)
-    LOG(WARNING) << msg.str();
-  else
-    LOG(ERROR) << msg.str();
 }
 
 void ObjectProxy::OnCallMethod(const std::string& interface_name,
@@ -637,139 +184,30 @@
                                ResponseCallback response_callback,
                                Response* response,
                                ErrorResponse* error_response) {
-  if (response) {
-    // Method call was successful.
-    std::move(response_callback).Run(response);
-    return;
-  }
-  // Method call failed.
-  std::string error_name;
-  std::string error_message;
-  if (error_response) {
-    // Error message may contain the error message as string.
-    error_name = error_response->GetErrorName();
-    MessageReader reader(error_response);
-    reader.PopString(&error_message);
-  } else {
-    error_name = "unknown error type";
-  }
-  LogMethodCallFailure(interface_name, method_name, error_name, error_message);
-
-  std::move(response_callback).Run(nullptr);
 }
 
 bool ObjectProxy::AddMatchRuleWithCallback(
     const std::string& match_rule,
     const std::string& absolute_signal_name,
     SignalCallback signal_callback) {
-  DCHECK(!match_rule.empty());
-  DCHECK(!absolute_signal_name.empty());
-  bus_->AssertOnDBusThread();
-
-  if (match_rules_.find(match_rule) == match_rules_.end()) {
-    ScopedDBusError error;
-    bus_->AddMatch(match_rule, error.get());
-    if (error.is_set()) {
-      LOG(ERROR) << "Failed to add match rule \"" << match_rule << "\". Got "
-                 << error.name() << ": " << error.message();
-      return false;
-    } else {
-      // Store the match rule, so that we can remove this in Detach().
-      match_rules_.insert(match_rule);
-      // Add the signal callback to the method table.
-      method_table_[absolute_signal_name].push_back(signal_callback);
-      return true;
-    }
-  } else {
-    // We already have the match rule.
-    method_table_[absolute_signal_name].push_back(signal_callback);
-    return true;
-  }
+  return true;
 }
 
 bool ObjectProxy::AddMatchRuleWithoutCallback(
     const std::string& match_rule,
     const std::string& absolute_signal_name) {
-  DCHECK(!match_rule.empty());
-  DCHECK(!absolute_signal_name.empty());
-  bus_->AssertOnDBusThread();
-
-  if (match_rules_.find(match_rule) != match_rules_.end())
-    return true;
-
-  ScopedDBusError error;
-  bus_->AddMatch(match_rule, error.get());
-  if (error.is_set()) {
-    LOG(ERROR) << "Failed to add match rule \"" << match_rule << "\". Got "
-               << error.name() << ": " << error.message();
-    return false;
-  }
-  // Store the match rule, so that we can remove this in Detach().
-  match_rules_.insert(match_rule);
   return true;
 }
 
 void ObjectProxy::UpdateNameOwnerAndBlock() {
-  bus_->AssertOnDBusThread();
-  // Errors should be suppressed here, as the service may not be yet running
-  // when connecting to signals of the service, which is just fine.
-  // The ObjectProxy will be notified when the service is launched via
-  // NameOwnerChanged signal. See also comments in ConnectToSignalInternal().
-  service_name_owner_ =
-      bus_->GetServiceOwnerAndBlock(service_name_, Bus::SUPPRESS_ERRORS);
-}
-
-DBusHandlerResult ObjectProxy::HandleNameOwnerChanged(
-    std::unique_ptr<Signal> signal) {
-  DCHECK(signal);
-  bus_->AssertOnDBusThread();
-
-  // Confirm the validity of the NameOwnerChanged signal.
-  if (signal->GetMember() == kNameOwnerChangedMember &&
-      signal->GetInterface() == kDBusSystemObjectInterface &&
-      signal->GetSender() == kDBusSystemObjectAddress) {
-    MessageReader reader(signal.get());
-    std::string name, old_owner, new_owner;
-    if (reader.PopString(&name) &&
-        reader.PopString(&old_owner) &&
-        reader.PopString(&new_owner) &&
-        name == service_name_) {
-      service_name_owner_ = new_owner;
-      bus_->GetOriginTaskRunner()->PostTask(
-          FROM_HERE, base::BindOnce(&ObjectProxy::RunNameOwnerChangedCallback,
-                                    this, old_owner, new_owner));
-
-      const bool service_is_available = !service_name_owner_.empty();
-      if (service_is_available) {
-        bus_->GetOriginTaskRunner()->PostTask(
-            FROM_HERE,
-            base::BindOnce(
-                &ObjectProxy::RunWaitForServiceToBeAvailableCallbacks, this,
-                service_is_available));
-      }
-    }
-  }
-
-  // Always return unhandled to let other object proxies handle the same
-  // signal.
-  return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
 void ObjectProxy::RunNameOwnerChangedCallback(const std::string& old_owner,
                                               const std::string& new_owner) {
-  bus_->AssertOnOriginThread();
-  if (!name_owner_changed_callback_.is_null())
-    name_owner_changed_callback_.Run(old_owner, new_owner);
 }
 
 void ObjectProxy::RunWaitForServiceToBeAvailableCallbacks(
     bool service_is_available) {
-  bus_->AssertOnOriginThread();
-
-  std::vector<WaitForServiceToBeAvailableCallback> callbacks;
-  callbacks.swap(wait_for_service_to_be_available_callbacks_);
-  for (size_t i = 0; i < callbacks.size(); ++i)
-    std::move(callbacks[i]).Run(service_is_available);
 }
 
 }  // namespace dbus
diff -u a/dbus/object_proxy.h b/dbus/object_proxy.h
--- a/dbus/object_proxy.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/object_proxy.h	2020-06-09 19:25:30.594842616 +0200
@@ -5,8 +5,6 @@
 #ifndef DBUS_OBJECT_PROXY_H_
 #define DBUS_OBJECT_PROXY_H_
 
-#include <dbus/dbus.h>
-
 #include <map>
 #include <memory>
 #include <set>
@@ -247,14 +245,14 @@
   // Starts the async method call. This is a helper function to implement
   // CallMethod().
   void StartAsyncMethodCall(int timeout_ms,
-                            DBusMessage* request_message,
+                            const void* request_message,
                             ReplyCallbackHolder callback_holder,
                             base::TimeTicks start_time);
 
   // Called when the pending call is complete.
   void OnPendingCallIsComplete(ReplyCallbackHolder callback_holder,
                                base::TimeTicks start_time,
-                               DBusPendingCall* pending_call);
+                               const void* pending_call);
 
   // Runs the ResponseOrErrorCallback with the given response object.
   void RunResponseOrErrorCallback(ReplyCallbackHolder callback_holderk,
@@ -276,21 +274,11 @@
   // Helper function for WaitForServiceToBeAvailable().
   void WaitForServiceToBeAvailableInternal();
 
-  // Handles the incoming request messages and dispatches to the signal
-  // callbacks.
-  DBusHandlerResult HandleMessage(DBusConnection* connection,
-                                  DBusMessage* raw_message);
-
   // Runs the method. Helper function for HandleMessage().
   void RunMethod(base::TimeTicks start_time,
                  std::vector<SignalCallback> signal_callbacks,
                  Signal* signal);
 
-  // Redirects the function call to HandleMessage().
-  static DBusHandlerResult HandleMessageThunk(DBusConnection* connection,
-                                              DBusMessage* raw_message,
-                                              void* user_data);
-
   // Helper method for logging response errors appropriately.
   void LogMethodCallFailure(const base::StringPiece& interface_name,
                             const base::StringPiece& method_name,
@@ -321,10 +309,6 @@
   // BLOCKING CALL.
   void UpdateNameOwnerAndBlock();
 
-  // Handles NameOwnerChanged signal from D-Bus's special message bus.
-  DBusHandlerResult HandleNameOwnerChanged(
-      std::unique_ptr<dbus::Signal> signal);
-
   // Runs |name_owner_changed_callback_|.
   void RunNameOwnerChangedCallback(const std::string& old_owner,
                                    const std::string& new_owner);
@@ -355,7 +339,7 @@
   // Known name owner of the well-known bus name represented by |service_name_|.
   std::string service_name_owner_;
 
-  std::set<DBusPendingCall*> pending_calls_;
+  std::set<void*> pending_calls_;
 
   DISALLOW_COPY_AND_ASSIGN(ObjectProxy);
 };
diff -u a/dbus/object_proxy_unittest.cc b/dbus/object_proxy_unittest.cc
--- a/dbus/object_proxy_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/object_proxy_unittest.cc	2020-06-09 19:12:02.787178170 +0200
@@ -20,13 +20,9 @@
   ObjectProxyTest() {}
 
   void SetUp() override {
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::SESSION;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_ = new Bus(bus_options);
   }
 
-  void TearDown() override { bus_->ShutdownAndBlock(); }
+  void TearDown() override { }
 
   base::test::TaskEnvironment task_environment_{
       base::test::TaskEnvironment::MainThreadType::IO};
@@ -38,108 +34,14 @@
 void OnServiceIsAvailable(bool* dest_service_is_available,
                           int* num_calls,
                           bool src_service_is_available) {
-  *dest_service_is_available = src_service_is_available;
-  (*num_calls)++;
 }
 
 // Used as a callback for TestService::RequestOwnership().
 void OnOwnershipRequestDone(bool success) {
-  ASSERT_TRUE(success);
 }
 
 // Used as a callback for TestService::ReleaseOwnership().
 void OnOwnershipReleased() {}
 
-TEST_F(ObjectProxyTest, WaitForServiceToBeAvailableRunOnce) {
-  TestService::Options options;
-  TestService test_service(options);
-  ObjectProxy* object_proxy = bus_->GetObjectProxy(
-      test_service.service_name(), ObjectPath("/org/chromium/TestObject"));
-
-  // The callback is not yet called because the service is not available.
-  int num_calls = 0;
-  bool service_is_available = false;
-  object_proxy->WaitForServiceToBeAvailable(
-      base::BindOnce(&OnServiceIsAvailable, &service_is_available, &num_calls));
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(0, num_calls);
-
-  // Start the service. The callback should be called asynchronously.
-  ASSERT_TRUE(test_service.StartService());
-  test_service.WaitUntilServiceIsStarted();
-  ASSERT_TRUE(test_service.has_ownership());
-  num_calls = 0;
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(1, num_calls);
-  EXPECT_TRUE(service_is_available);
-
-  // Release the service's ownership of its name. The callback should not be
-  // invoked again.
-  test_service.ReleaseOwnership(base::BindOnce(&OnOwnershipReleased));
-  num_calls = 0;
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(0, num_calls);
-
-  // Take ownership of the name and check that the callback is not called.
-  test_service.RequestOwnership(base::BindOnce(&OnOwnershipRequestDone));
-  num_calls = 0;
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(0, num_calls);
-}
-
-TEST_F(ObjectProxyTest, WaitForServiceToBeAvailableAlreadyRunning) {
-  TestService::Options options;
-  TestService test_service(options);
-  ObjectProxy* object_proxy = bus_->GetObjectProxy(
-      test_service.service_name(), ObjectPath("/org/chromium/TestObject"));
-
-  ASSERT_TRUE(test_service.StartService());
-  test_service.WaitUntilServiceIsStarted();
-  ASSERT_TRUE(test_service.has_ownership());
-
-  // Since the service is already running, the callback should be invoked
-  // immediately (but asynchronously, rather than the callback being invoked
-  // directly within WaitForServiceToBeAvailable()).
-  int num_calls = 0;
-  bool service_is_available = false;
-  object_proxy->WaitForServiceToBeAvailable(
-      base::BindOnce(&OnServiceIsAvailable, &service_is_available, &num_calls));
-  EXPECT_EQ(0, num_calls);
-
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(1, num_calls);
-  EXPECT_TRUE(service_is_available);
-}
-
-TEST_F(ObjectProxyTest, WaitForServiceToBeAvailableMultipleCallbacks) {
-  TestService::Options options;
-  TestService test_service(options);
-  ObjectProxy* object_proxy = bus_->GetObjectProxy(
-      test_service.service_name(), ObjectPath("/org/chromium/TestObject"));
-
-  // Register two callbacks.
-  int num_calls_1 = 0, num_calls_2 = 0;
-  bool service_is_available_1 = false, service_is_available_2 = false;
-  object_proxy->WaitForServiceToBeAvailable(base::BindOnce(
-      &OnServiceIsAvailable, &service_is_available_1, &num_calls_1));
-  object_proxy->WaitForServiceToBeAvailable(base::BindOnce(
-      &OnServiceIsAvailable, &service_is_available_2, &num_calls_2));
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(0, num_calls_1);
-  EXPECT_EQ(0, num_calls_2);
-
-  // Start the service and confirm that both callbacks are invoked.
-  ASSERT_TRUE(test_service.StartService());
-  test_service.WaitUntilServiceIsStarted();
-  ASSERT_TRUE(test_service.has_ownership());
-  num_calls_1 = 0;
-  num_calls_2 = 0;
-  base::RunLoop().RunUntilIdle();
-  EXPECT_EQ(1, num_calls_1);
-  EXPECT_EQ(1, num_calls_2);
-  EXPECT_TRUE(service_is_available_1);
-  EXPECT_TRUE(service_is_available_2);
-}
-
 }  // namespace
 }  // namespace dbus
diff -u a/dbus/property.cc b/dbus/property.cc
--- a/dbus/property.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/property.cc	2020-06-09 19:33:18.101607057 +0200
@@ -26,9 +26,6 @@
 PropertyBase::~PropertyBase() = default;
 
 void PropertyBase::Init(PropertySet* property_set, const std::string& name) {
-  DCHECK(!property_set_);
-  property_set_ = property_set;
-  is_valid_ = false;
   name_ = name;
 }
 
@@ -48,244 +45,63 @@
 
 void PropertySet::RegisterProperty(const std::string& name,
                                    PropertyBase* property) {
-  property->Init(this, name);
-  properties_map_[name] = property;
 }
 
 void PropertySet::ConnectSignals() {
-  DCHECK(object_proxy_);
-  object_proxy_->ConnectToSignal(
-      kPropertiesInterface, kPropertiesChanged,
-      base::BindRepeating(&PropertySet::ChangedReceived,
-                          weak_ptr_factory_.GetWeakPtr()),
-      base::BindOnce(&PropertySet::ChangedConnected,
-                     weak_ptr_factory_.GetWeakPtr()));
 }
 
 
 void PropertySet::ChangedReceived(Signal* signal) {
-  DCHECK(signal);
-  MessageReader reader(signal);
-
-  std::string interface;
-  if (!reader.PopString(&interface)) {
-    LOG(WARNING) << "Property changed signal has wrong parameters: "
-                 << "expected interface name: " << signal->ToString();
-    return;
-  }
-
-  if (interface != this->interface())
-    return;
-
-  if (!UpdatePropertiesFromReader(&reader)) {
-    LOG(WARNING) << "Property changed signal has wrong parameters: "
-                 << "expected dictionary: " << signal->ToString();
-  }
-
-  if (!InvalidatePropertiesFromReader(&reader)) {
-    LOG(WARNING) << "Property changed signal has wrong parameters: "
-                 << "expected array to invalidate: " << signal->ToString();
-  }
 }
 
 void PropertySet::ChangedConnected(const std::string& interface_name,
                                    const std::string& signal_name,
                                    bool success) {
-  LOG_IF(WARNING, !success) << "Failed to connect to " << signal_name
-                            << "signal.";
 }
 
 
 void PropertySet::Get(PropertyBase* property, GetCallback callback) {
-  MethodCall method_call(kPropertiesInterface, kPropertiesGet);
-  MessageWriter writer(&method_call);
-  writer.AppendString(interface());
-  writer.AppendString(property->name());
-
-  DCHECK(object_proxy_);
-  object_proxy_->CallMethod(&method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-                            base::BindOnce(&PropertySet::OnGet, GetWeakPtr(),
-                                           property, std::move(callback)));
 }
 
 void PropertySet::OnGet(PropertyBase* property, GetCallback callback,
                         Response* response) {
-  if (!response) {
-    LOG(WARNING) << property->name() << ": Get: failed.";
-    return;
-  }
-
-  MessageReader reader(response);
-  if (property->PopValueFromReader(&reader)) {
-    property->set_valid(true);
-    NotifyPropertyChanged(property->name());
-  } else {
-    if (property->is_valid()) {
-      property->set_valid(false);
-      NotifyPropertyChanged(property->name());
-    }
-  }
-
-  if (!callback.is_null())
-    std::move(callback).Run(response);
 }
 
 bool PropertySet::GetAndBlock(PropertyBase* property) {
-  MethodCall method_call(kPropertiesInterface, kPropertiesGet);
-  MessageWriter writer(&method_call);
-  writer.AppendString(interface());
-  writer.AppendString(property->name());
-
-  DCHECK(object_proxy_);
-  std::unique_ptr<dbus::Response> response(object_proxy_->CallMethodAndBlock(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT));
-
-  if (!response.get()) {
-    LOG(WARNING) << property->name() << ": GetAndBlock: failed.";
-    return false;
-  }
-
-  MessageReader reader(response.get());
-  if (property->PopValueFromReader(&reader)) {
-    property->set_valid(true);
-    NotifyPropertyChanged(property->name());
-  } else {
-    if (property->is_valid()) {
-      property->set_valid(false);
-      NotifyPropertyChanged(property->name());
-    }
-  }
   return true;
 }
 
 void PropertySet::GetAll() {
-  MethodCall method_call(kPropertiesInterface, kPropertiesGetAll);
-  MessageWriter writer(&method_call);
-  writer.AppendString(interface());
-
-  DCHECK(object_proxy_);
-  object_proxy_->CallMethod(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-      base::BindOnce(&PropertySet::OnGetAll, weak_ptr_factory_.GetWeakPtr()));
 }
 
 void PropertySet::OnGetAll(Response* response) {
-  if (!response) {
-    LOG(WARNING) << "GetAll request failed for: " << interface_;
-    return;
-  }
-
-  MessageReader reader(response);
-  if (!UpdatePropertiesFromReader(&reader)) {
-    LOG(WARNING) << "GetAll response has wrong parameters: "
-                 << "expected dictionary: " << response->ToString();
-  }
 }
 
 void PropertySet::Set(PropertyBase* property, SetCallback callback) {
-  MethodCall method_call(kPropertiesInterface, kPropertiesSet);
-  MessageWriter writer(&method_call);
-  writer.AppendString(interface());
-  writer.AppendString(property->name());
-  property->AppendSetValueToWriter(&writer);
-
-  DCHECK(object_proxy_);
-  object_proxy_->CallMethod(&method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-                            base::BindOnce(&PropertySet::OnSet, GetWeakPtr(),
-                                           property, std::move(callback)));
 }
 
 bool PropertySet::SetAndBlock(PropertyBase* property) {
-  MethodCall method_call(kPropertiesInterface, kPropertiesSet);
-  MessageWriter writer(&method_call);
-  writer.AppendString(interface());
-  writer.AppendString(property->name());
-  property->AppendSetValueToWriter(&writer);
-
-  DCHECK(object_proxy_);
-  std::unique_ptr<dbus::Response> response(object_proxy_->CallMethodAndBlock(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT));
-  if (response.get())
-    return true;
-  return false;
+  return true;
 }
 
 void PropertySet::OnSet(PropertyBase* property,
                         SetCallback callback,
                         Response* response) {
-  LOG_IF(WARNING, !response) << property->name() << ": Set: failed.";
-  if (!callback.is_null())
-    std::move(callback).Run(response);
 }
 
 bool PropertySet::UpdatePropertiesFromReader(MessageReader* reader) {
-  DCHECK(reader);
-  MessageReader array_reader(nullptr);
-  if (!reader->PopArray(&array_reader))
-    return false;
-
-  while (array_reader.HasMoreData()) {
-    MessageReader dict_entry_reader(nullptr);
-    if (array_reader.PopDictEntry(&dict_entry_reader))
-      UpdatePropertyFromReader(&dict_entry_reader);
-  }
-
   return true;
 }
 
 bool PropertySet::UpdatePropertyFromReader(MessageReader* reader) {
-  DCHECK(reader);
-
-  std::string name;
-  if (!reader->PopString(&name))
-    return false;
-
-  PropertiesMap::iterator it = properties_map_.find(name);
-  if (it == properties_map_.end())
-    return false;
-
-  PropertyBase* property = it->second;
-  if (property->PopValueFromReader(reader)) {
-    property->set_valid(true);
-    NotifyPropertyChanged(name);
-    return true;
-  } else {
-    if (property->is_valid()) {
-      property->set_valid(false);
-      NotifyPropertyChanged(property->name());
-    }
-    return false;
-  }
+  return true;
 }
 
 bool PropertySet::InvalidatePropertiesFromReader(MessageReader* reader) {
-  DCHECK(reader);
-  MessageReader array_reader(nullptr);
-  if (!reader->PopArray(&array_reader))
-    return false;
-
-  while (array_reader.HasMoreData()) {
-    std::string name;
-    if (!array_reader.PopString(&name))
-      return false;
-
-    PropertiesMap::iterator it = properties_map_.find(name);
-    if (it == properties_map_.end())
-      continue;
-
-    PropertyBase* property = it->second;
-    if (property->is_valid()) {
-      property->set_valid(false);
-      NotifyPropertyChanged(property->name());
-    }
-  }
-
   return true;
 }
 
 void PropertySet::NotifyPropertyChanged(const std::string& name) {
-  if (!property_changed_callback_.is_null())
-    property_changed_callback_.Run(name);
 }
 
 //
@@ -298,12 +114,11 @@
 
 template <>
 bool Property<uint8_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfByte(&value_);
+  return true;
 }
 
 template <>
 void Property<uint8_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfByte(set_value_);
 }
 
 //
@@ -316,12 +131,11 @@
 
 template <>
 bool Property<bool>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfBool(&value_);
+  return true;
 }
 
 template <>
 void Property<bool>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfBool(set_value_);
 }
 
 //
@@ -334,12 +148,11 @@
 
 template <>
 bool Property<int16_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfInt16(&value_);
+  return true;
 }
 
 template <>
 void Property<int16_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfInt16(set_value_);
 }
 
 //
@@ -352,12 +165,11 @@
 
 template <>
 bool Property<uint16_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfUint16(&value_);
+  return true;
 }
 
 template <>
 void Property<uint16_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfUint16(set_value_);
 }
 
 //
@@ -370,12 +182,11 @@
 
 template <>
 bool Property<int32_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfInt32(&value_);
+  return true;
 }
 
 template <>
 void Property<int32_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfInt32(set_value_);
 }
 
 //
@@ -388,12 +199,11 @@
 
 template <>
 bool Property<uint32_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfUint32(&value_);
+  return true;
 }
 
 template <>
 void Property<uint32_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfUint32(set_value_);
 }
 
 //
@@ -406,12 +216,11 @@
 
 template <>
 bool Property<int64_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfInt64(&value_);
+  return true;
 }
 
 template <>
 void Property<int64_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfInt64(set_value_);
 }
 
 //
@@ -424,12 +233,11 @@
 
 template <>
 bool Property<uint64_t>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfUint64(&value_);
+  return true;
 }
 
 template <>
 void Property<uint64_t>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfUint64(set_value_);
 }
 
 //
@@ -442,12 +250,11 @@
 
 template <>
 bool Property<double>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfDouble(&value_);
+  return true;
 }
 
 template <>
 void Property<double>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfDouble(set_value_);
 }
 
 //
@@ -456,12 +263,11 @@
 
 template <>
 bool Property<std::string>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfString(&value_);
+  return true;
 }
 
 template <>
 void Property<std::string>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfString(set_value_);
 }
 
 //
@@ -470,12 +276,11 @@
 
 template <>
 bool Property<ObjectPath>::PopValueFromReader(MessageReader* reader) {
-  return reader->PopVariantOfObjectPath(&value_);
+  return true;
 }
 
 template <>
 void Property<ObjectPath>::AppendSetValueToWriter(MessageWriter* writer) {
-  writer->AppendVariantOfObjectPath(set_value_);
 }
 
 //
@@ -485,21 +290,12 @@
 template <>
 bool Property<std::vector<std::string>>::PopValueFromReader(
     MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader))
-    return false;
-
-  value_.clear();
-  return variant_reader.PopArrayOfStrings(&value_);
+  return true;
 }
 
 template <>
 void Property<std::vector<std::string>>::AppendSetValueToWriter(
     MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  writer->OpenVariant("as", &variant_writer);
-  variant_writer.AppendArrayOfStrings(set_value_);
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -509,21 +305,12 @@
 template <>
 bool Property<std::vector<ObjectPath>>::PopValueFromReader(
     MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader))
-    return false;
-
-  value_.clear();
-  return variant_reader.PopArrayOfObjectPaths(&value_);
+  return true;
 }
 
 template <>
 void Property<std::vector<ObjectPath>>::AppendSetValueToWriter(
     MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  writer->OpenVariant("ao", &variant_writer);
-  variant_writer.AppendArrayOfObjectPaths(set_value_);
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -532,26 +319,12 @@
 
 template <>
 bool Property<std::vector<uint8_t>>::PopValueFromReader(MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader))
-    return false;
-
-  value_.clear();
-  const uint8_t* bytes = nullptr;
-  size_t length = 0;
-  if (!variant_reader.PopArrayOfBytes(&bytes, &length))
-    return false;
-  value_.assign(bytes, bytes + length);
   return true;
 }
 
 template <>
 void Property<std::vector<uint8_t>>::AppendSetValueToWriter(
     MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  writer->OpenVariant("ay", &variant_writer);
-  variant_writer.AppendArrayOfBytes(set_value_.data(), set_value_.size());
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -561,42 +334,12 @@
 template <>
 bool Property<std::map<std::string, std::string>>::PopValueFromReader(
     MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  MessageReader array_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader) ||
-      !variant_reader.PopArray(&array_reader))
-    return false;
-  value_.clear();
-  while (array_reader.HasMoreData()) {
-    dbus::MessageReader dict_entry_reader(nullptr);
-    if (!array_reader.PopDictEntry(&dict_entry_reader))
-      return false;
-    std::string key;
-    std::string value;
-    if (!dict_entry_reader.PopString(&key) ||
-        !dict_entry_reader.PopString(&value))
-      return false;
-    value_[key] = value;
-  }
   return true;
 }
 
 template <>
 void Property<std::map<std::string, std::string>>::AppendSetValueToWriter(
     MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-  writer->OpenVariant("a{ss}", &variant_writer);
-  variant_writer.OpenArray("{ss}", &dict_writer);
-  for (const auto& pair : set_value_) {
-    dbus::MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-    entry_writer.AppendString(pair.first);
-    entry_writer.AppendString(pair.second);
-    dict_writer.CloseContainer(&entry_writer);
-  }
-  variant_writer.CloseContainer(&dict_writer);
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -607,48 +350,12 @@
 template <>
 bool Property<std::vector<std::pair<std::vector<uint8_t>, uint16_t>>>::
     PopValueFromReader(MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  MessageReader array_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader) ||
-      !variant_reader.PopArray(&array_reader))
-    return false;
-
-  value_.clear();
-  while (array_reader.HasMoreData()) {
-    dbus::MessageReader struct_reader(nullptr);
-    if (!array_reader.PopStruct(&struct_reader))
-      return false;
-
-    std::pair<std::vector<uint8_t>, uint16_t> entry;
-    const uint8_t* bytes = nullptr;
-    size_t length = 0;
-    if (!struct_reader.PopArrayOfBytes(&bytes, &length))
-      return false;
-    entry.first.assign(bytes, bytes + length);
-    if (!struct_reader.PopUint16(&entry.second))
-      return false;
-    value_.push_back(entry);
-  }
   return true;
 }
 
 template <>
 void Property<std::vector<std::pair<std::vector<uint8_t>, uint16_t>>>::
     AppendSetValueToWriter(MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  MessageWriter array_writer(nullptr);
-  writer->OpenVariant("a(ayq)", &variant_writer);
-  variant_writer.OpenArray("(ayq)", &array_writer);
-  for (const auto& pair : set_value_) {
-    dbus::MessageWriter struct_writer(nullptr);
-    array_writer.OpenStruct(&struct_writer);
-    struct_writer.AppendArrayOfBytes(std::get<0>(pair).data(),
-                                     std::get<0>(pair).size());
-    struct_writer.AppendUint16(std::get<1>(pair));
-    array_writer.CloseContainer(&struct_writer);
-  }
-  variant_writer.CloseContainer(&array_writer);
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -659,68 +366,12 @@
 template <>
 bool Property<std::map<std::string, std::vector<uint8_t>>>::PopValueFromReader(
     MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  MessageReader dict_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader) ||
-      !variant_reader.PopArray(&dict_reader))
-    return false;
-
-  value_.clear();
-  while (dict_reader.HasMoreData()) {
-    MessageReader entry_reader(nullptr);
-    if (!dict_reader.PopDictEntry(&entry_reader))
-      return false;
-
-    std::string key;
-    if (!entry_reader.PopString(&key))
-      return false;
-
-    const uint8_t* bytes = nullptr;
-    size_t length = 0;
-
-    if (entry_reader.GetDataType() == Message::VARIANT) {
-      // Make BlueZ happy since it wraps the array of bytes with a variant.
-      MessageReader value_variant_reader(nullptr);
-      if (!entry_reader.PopVariant(&value_variant_reader))
-        return false;
-      if (!value_variant_reader.PopArrayOfBytes(&bytes, &length))
-        return false;
-    } else {
-      if (!entry_reader.PopArrayOfBytes(&bytes, &length))
-        return false;
-    }
-
-    value_[key].assign(bytes, bytes + length);
-  }
   return true;
 }
 
 template <>
 void Property<std::map<std::string, std::vector<uint8_t>>>::
     AppendSetValueToWriter(MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer->OpenVariant("a{sv}", &variant_writer);
-  variant_writer.OpenArray("{sv}", &dict_writer);
-
-  for (const auto& pair : set_value_) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendString(pair.first);
-
-    MessageWriter value_varient_writer(nullptr);
-    entry_writer.OpenVariant("ay", &value_varient_writer);
-    value_varient_writer.AppendArrayOfBytes(pair.second.data(),
-                                            pair.second.size());
-    entry_writer.CloseContainer(&value_varient_writer);
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer->CloseContainer(&variant_writer);
 }
 
 //
@@ -731,68 +382,12 @@
 template <>
 bool Property<std::map<uint16_t, std::vector<uint8_t>>>::PopValueFromReader(
     MessageReader* reader) {
-  MessageReader variant_reader(nullptr);
-  MessageReader dict_reader(nullptr);
-  if (!reader->PopVariant(&variant_reader) ||
-      !variant_reader.PopArray(&dict_reader))
-    return false;
-
-  value_.clear();
-  while (dict_reader.HasMoreData()) {
-    MessageReader entry_reader(nullptr);
-    if (!dict_reader.PopDictEntry(&entry_reader))
-      return false;
-
-    uint16_t key;
-    if (!entry_reader.PopUint16(&key))
-      return false;
-
-    const uint8_t* bytes = nullptr;
-    size_t length = 0;
-
-    if (entry_reader.GetDataType() == Message::VARIANT) {
-      // Make BlueZ happy since it wraps the array of bytes with a variant.
-      MessageReader value_variant_reader(nullptr);
-      if (!entry_reader.PopVariant(&value_variant_reader))
-        return false;
-      if (!value_variant_reader.PopArrayOfBytes(&bytes, &length))
-        return false;
-    } else {
-      if (!entry_reader.PopArrayOfBytes(&bytes, &length))
-        return false;
-    }
-
-    value_[key].assign(bytes, bytes + length);
-  }
   return true;
 }
 
 template <>
 void Property<std::map<uint16_t, std::vector<uint8_t>>>::AppendSetValueToWriter(
     MessageWriter* writer) {
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer->OpenVariant("a{qv}", &variant_writer);
-  variant_writer.OpenArray("{qv}", &dict_writer);
-
-  for (const auto& pair : set_value_) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendUint16(pair.first);
-
-    MessageWriter value_varient_writer(nullptr);
-    entry_writer.OpenVariant("ay", &value_varient_writer);
-    value_varient_writer.AppendArrayOfBytes(pair.second.data(),
-                                            pair.second.size());
-    entry_writer.CloseContainer(&value_varient_writer);
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer->CloseContainer(&variant_writer);
 }
 
 template class Property<uint8_t>;
diff -u a/dbus/property.h b/dbus/property.h
--- a/dbus/property.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/property.h	2020-06-09 19:58:12.504640473 +0200
@@ -388,13 +388,12 @@
   // round-trip. |callback| will be called when the new value is available.
   // This may not be implemented by some interfaces.
   virtual void Get(dbus::PropertySet::GetCallback callback) {
-    property_set()->Get(this, std::move(callback));
   }
 
   // The synchronous version of Get().
   // This should never be used on an interactive thread.
   virtual bool GetAndBlock() {
-    return property_set()->GetAndBlock(this);
+    return true;
   }
 
   // Requests that the remote object change the property value to |value|,
@@ -402,15 +401,12 @@
   // request, however the new value may not be available depending on the
   // remote object.
   virtual void Set(const T& value, dbus::PropertySet::SetCallback callback) {
-    set_value_ = value;
-    property_set()->Set(this, std::move(callback));
   }
 
   // The synchronous version of Set().
   // This should never be used on an interactive thread.
   virtual bool SetAndBlock(const T& value) {
-    set_value_ = value;
-    return property_set()->SetAndBlock(this);
+    return true;
   }
 
   // Method used by PropertySet to retrieve the value from a MessageReader,
@@ -427,15 +423,11 @@
   // to replace the property value with the set value without using a
   // dbus::MessageReader.
   void ReplaceValueWithSetValue() override {
-    value_ = set_value_;
-    property_set()->NotifyPropertyChanged(name());
   }
 
   // Method used by test and stub implementations to directly set the
   // value of a property.
   void ReplaceValue(const T& value) {
-    value_ = value;
-    property_set()->NotifyPropertyChanged(name());
   }
 
   // Method used by test and stub implementations to directly set the
diff -u a/dbus/property_unittest.cc b/dbus/property_unittest.cc
--- a/dbus/property_unittest.cc	2020-05-18 20:40:23.000000000 +0200
+++ b/dbus/property_unittest.cc	2020-06-09 19:26:45.757654641 +0200
@@ -55,83 +55,28 @@
   };
 
   void SetUp() override {
-    // Make the main thread not to allow IO.
-    base::ThreadRestrictions::SetIOAllowed(false);
-
-    // Start the D-Bus thread.
-    dbus_thread_.reset(new base::Thread("D-Bus Thread"));
-    base::Thread::Options thread_options;
-    thread_options.message_pump_type = base::MessagePumpType::IO;
-    ASSERT_TRUE(dbus_thread_->StartWithOptions(thread_options));
-
-    // Start the test service, using the D-Bus thread.
-    TestService::Options options;
-    options.dbus_task_runner = dbus_thread_->task_runner();
-    test_service_.reset(new TestService(options));
-    ASSERT_TRUE(test_service_->StartService());
-    test_service_->WaitUntilServiceIsStarted();
-    ASSERT_TRUE(test_service_->HasDBusThread());
-
-    // Create the client, using the D-Bus thread.
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::SESSION;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_options.dbus_task_runner = dbus_thread_->task_runner();
-    bus_ = new Bus(bus_options);
-    object_proxy_ = bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    // Create the properties structure
-    properties_.reset(new Properties(
-        object_proxy_, base::BindRepeating(&PropertyTest::OnPropertyChanged,
-                                           base::Unretained(this))));
-    properties_->ConnectSignals();
-    properties_->GetAll();
   }
 
   void TearDown() override {
-    bus_->ShutdownOnDBusThreadAndBlock();
-
-    // Shut down the service.
-    test_service_->ShutdownAndBlock();
-
-    // Reset to the default.
-    base::ThreadRestrictions::SetIOAllowed(true);
-
-    // Stopping a thread is considered an IO operation, so do this after
-    // allowing IO.
-    test_service_->Stop();
   }
 
   // Generic callback, bind with a string |id| for passing to
   // WaitForCallback() to ensure the callback for the right method is
   // waited for.
   void PropertyCallback(const std::string& id, bool success) {
-    last_callback_ = id;
-    run_loop_->Quit();
   }
 
   // Generic method callback, that might be used together with
   // WaitForMethodCallback to test wether method was succesfully called.
-  void MethodCallback(Response* response) { run_loop_->Quit(); }
+  void MethodCallback(Response* response) { }
 
  protected:
   // Called when a property value is updated.
   void OnPropertyChanged(const std::string& name) {
-    updated_properties_.push_back(name);
-    run_loop_->Quit();
   }
 
   // Waits for the given number of updates.
   void WaitForUpdates(size_t num_updates) {
-    while (updated_properties_.size() < num_updates) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
-    for (size_t i = 0; i < num_updates; ++i)
-      updated_properties_.erase(updated_properties_.begin());
   }
 
   // Name, Version, Methods, Objects
@@ -139,23 +84,16 @@
 
   // Waits for initial values to be set.
   void WaitForGetAll() {
-    WaitForUpdates(kExpectedSignalUpdates);
   }
 
   // Waits until MethodCallback is called.
   void WaitForMethodCallback() {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
   }
 
   // Waits for the callback. |id| is the string bound to the callback when
   // the method call is made that identifies it and distinguishes from any
   // other; you can set this to whatever you wish.
   void WaitForCallback(const std::string& id) {
-    while (last_callback_ != id) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
   }
 
   base::test::SingleThreadTaskEnvironment task_environment_;
@@ -171,434 +109,4 @@
   std::string last_callback_;
 };
 
-TEST_F(PropertyTest, InitialValues) {
-  EXPECT_FALSE(properties_->name.is_valid());
-  EXPECT_FALSE(properties_->version.is_valid());
-
-  WaitForGetAll();
-
-  EXPECT_TRUE(properties_->name.is_valid());
-  EXPECT_EQ("TestService", properties_->name.value());
-  EXPECT_TRUE(properties_->version.is_valid());
-  EXPECT_EQ(10, properties_->version.value());
-
-  std::vector<std::string> methods = properties_->methods.value();
-  ASSERT_EQ(4U, methods.size());
-  EXPECT_EQ("Echo", methods[0]);
-  EXPECT_EQ("SlowEcho", methods[1]);
-  EXPECT_EQ("AsyncEcho", methods[2]);
-  EXPECT_EQ("BrokenMethod", methods[3]);
-
-  std::vector<ObjectPath> objects = properties_->objects.value();
-  ASSERT_EQ(1U, objects.size());
-  EXPECT_EQ(ObjectPath("/TestObjectPath"), objects[0]);
-
-  std::vector<uint8_t> bytes = properties_->bytes.value();
-  ASSERT_EQ(4U, bytes.size());
-  EXPECT_EQ('T', bytes[0]);
-  EXPECT_EQ('e', bytes[1]);
-  EXPECT_EQ('s', bytes[2]);
-  EXPECT_EQ('t', bytes[3]);
-}
-
-TEST_F(PropertyTest, UpdatedValues) {
-  WaitForGetAll();
-
-  // Update the value of the "Name" property, this value should not change.
-  properties_->name.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                       base::Unretained(this), "Name"));
-  WaitForCallback("Name");
-  WaitForUpdates(1);
-
-  EXPECT_EQ("TestService", properties_->name.value());
-
-  // Update the value of the "Version" property, this value should be changed.
-  properties_->version.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                          base::Unretained(this), "Version"));
-  WaitForCallback("Version");
-  WaitForUpdates(1);
-
-  EXPECT_EQ(20, properties_->version.value());
-
-  // Update the value of the "Methods" property, this value should not change
-  // and should not grow to contain duplicate entries.
-  properties_->methods.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                          base::Unretained(this), "Methods"));
-  WaitForCallback("Methods");
-  WaitForUpdates(1);
-
-  std::vector<std::string> methods = properties_->methods.value();
-  ASSERT_EQ(4U, methods.size());
-  EXPECT_EQ("Echo", methods[0]);
-  EXPECT_EQ("SlowEcho", methods[1]);
-  EXPECT_EQ("AsyncEcho", methods[2]);
-  EXPECT_EQ("BrokenMethod", methods[3]);
-
-  // Update the value of the "Objects" property, this value should not change
-  // and should not grow to contain duplicate entries.
-  properties_->objects.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                          base::Unretained(this), "Objects"));
-  WaitForCallback("Objects");
-  WaitForUpdates(1);
-
-  std::vector<ObjectPath> objects = properties_->objects.value();
-  ASSERT_EQ(1U, objects.size());
-  EXPECT_EQ(ObjectPath("/TestObjectPath"), objects[0]);
-
-  // Update the value of the "Bytes" property, this value should not change
-  // and should not grow to contain duplicate entries.
-  properties_->bytes.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                        base::Unretained(this), "Bytes"));
-  WaitForCallback("Bytes");
-  WaitForUpdates(1);
-
-  std::vector<uint8_t> bytes = properties_->bytes.value();
-  ASSERT_EQ(4U, bytes.size());
-  EXPECT_EQ('T', bytes[0]);
-  EXPECT_EQ('e', bytes[1]);
-  EXPECT_EQ('s', bytes[2]);
-  EXPECT_EQ('t', bytes[3]);
-}
-
-TEST_F(PropertyTest, Get) {
-  WaitForGetAll();
-
-  // Ask for the new Version property.
-  properties_->version.Get(base::BindOnce(&PropertyTest::PropertyCallback,
-                                          base::Unretained(this), "Get"));
-  WaitForCallback("Get");
-
-  // Make sure we got a property update too.
-  WaitForUpdates(1);
-
-  EXPECT_EQ(20, properties_->version.value());
-}
-
-TEST_F(PropertyTest, Set) {
-  WaitForGetAll();
-
-  // Set a new name.
-  properties_->name.Set("NewService",
-                        base::BindOnce(&PropertyTest::PropertyCallback,
-                                       base::Unretained(this), "Set"));
-  WaitForCallback("Set");
-
-  // TestService sends a property update.
-  WaitForUpdates(1);
-
-  EXPECT_EQ("NewService", properties_->name.value());
-}
-
-TEST_F(PropertyTest, Invalidate) {
-  WaitForGetAll();
-
-  EXPECT_TRUE(properties_->name.is_valid());
-
-  // Invalidate name.
-  MethodCall method_call("org.chromium.TestInterface", "PerformAction");
-  MessageWriter writer(&method_call);
-  writer.AppendString("InvalidateProperty");
-  writer.AppendObjectPath(ObjectPath("/org/chromium/TestService"));
-  object_proxy_->CallMethod(
-      &method_call, ObjectProxy::TIMEOUT_USE_DEFAULT,
-      base::BindOnce(&PropertyTest::MethodCallback, base::Unretained(this)));
-  WaitForMethodCallback();
-
-  // TestService sends a property update.
-  WaitForUpdates(1);
-
-  EXPECT_FALSE(properties_->name.is_valid());
-
-  // Set name to something valid.
-  properties_->name.Set("NewService",
-                        base::BindOnce(&PropertyTest::PropertyCallback,
-                                       base::Unretained(this), "Set"));
-  WaitForCallback("Set");
-
-  // TestService sends a property update.
-  WaitForUpdates(1);
-
-  EXPECT_TRUE(properties_->name.is_valid());
-}
-
-TEST(PropertyTestStatic, ReadWriteStringMap) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter variant_array_writer(nullptr);
-  MessageWriter struct_entry_writer(nullptr);
-
-  writer.OpenVariant("a{ss}", &variant_writer);
-  variant_writer.OpenArray("{ss}", &variant_array_writer);
-  const char* items[] = {"One", "Two", "Three", "Four"};
-  for (unsigned i = 0; i < base::size(items); ++i) {
-    variant_array_writer.OpenDictEntry(&struct_entry_writer);
-    struct_entry_writer.AppendString(items[i]);
-    struct_entry_writer.AppendString(base::NumberToString(i + 1));
-    variant_array_writer.CloseContainer(&struct_entry_writer);
-  }
-  variant_writer.CloseContainer(&variant_array_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::map<std::string, std::string>> string_map;
-  EXPECT_TRUE(string_map.PopValueFromReader(&reader));
-  ASSERT_EQ(4U, string_map.value().size());
-  EXPECT_EQ("1", string_map.value().at("One"));
-  EXPECT_EQ("2", string_map.value().at("Two"));
-  EXPECT_EQ("3", string_map.value().at("Three"));
-  EXPECT_EQ("4", string_map.value().at("Four"));
-}
-
-TEST(PropertyTestStatic, SerializeStringMap) {
-  std::map<std::string, std::string> test_map;
-  test_map["Hi"] = "There";
-  test_map["Map"] = "Test";
-  test_map["Random"] = "Text";
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  Property<std::map<std::string, std::string>> string_map;
-  string_map.ReplaceSetValueForTesting(test_map);
-  string_map.AppendSetValueToWriter(&writer);
-
-  MessageReader reader(message.get());
-  EXPECT_TRUE(string_map.PopValueFromReader(&reader));
-  EXPECT_EQ(test_map, string_map.value());
-}
-
-TEST(PropertyTestStatic, ReadWriteNetAddressArray) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter variant_array_writer(nullptr);
-  MessageWriter struct_entry_writer(nullptr);
-
-  writer.OpenVariant("a(ayq)", &variant_writer);
-  variant_writer.OpenArray("(ayq)", &variant_array_writer);
-  uint8_t ip_bytes[] = {0x54, 0x65, 0x73, 0x74, 0x30};
-  for (uint16_t i = 0; i < 5; ++i) {
-    variant_array_writer.OpenStruct(&struct_entry_writer);
-    ip_bytes[4] = 0x30 + i;
-    struct_entry_writer.AppendArrayOfBytes(ip_bytes, base::size(ip_bytes));
-    struct_entry_writer.AppendUint16(i);
-    variant_array_writer.CloseContainer(&struct_entry_writer);
-  }
-  variant_writer.CloseContainer(&variant_array_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::vector<std::pair<std::vector<uint8_t>, uint16_t>>> ip_list;
-  EXPECT_TRUE(ip_list.PopValueFromReader(&reader));
-
-  ASSERT_EQ(5U, ip_list.value().size());
-  size_t item_index = 0;
-  for (auto& item : ip_list.value()) {
-    ASSERT_EQ(5U, item.first.size());
-    ip_bytes[4] = 0x30 + item_index;
-    EXPECT_EQ(0, memcmp(ip_bytes, item.first.data(), 5U));
-    EXPECT_EQ(item_index, item.second);
-    ++item_index;
-  }
-}
-
-TEST(PropertyTestStatic, SerializeNetAddressArray) {
-  std::vector<std::pair<std::vector<uint8_t>, uint16_t>> test_list;
-
-  uint8_t ip_bytes[] = {0x54, 0x65, 0x73, 0x74, 0x30};
-  for (uint16_t i = 0; i < 5; ++i) {
-    ip_bytes[4] = 0x30 + i;
-    std::vector<uint8_t> bytes(ip_bytes, ip_bytes + base::size(ip_bytes));
-    test_list.push_back(make_pair(bytes, 16));
-  }
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  Property<std::vector<std::pair<std::vector<uint8_t>, uint16_t>>> ip_list;
-  ip_list.ReplaceSetValueForTesting(test_list);
-  ip_list.AppendSetValueToWriter(&writer);
-
-  MessageReader reader(message.get());
-  EXPECT_TRUE(ip_list.PopValueFromReader(&reader));
-  EXPECT_EQ(test_list, ip_list.value());
-}
-
-TEST(PropertyTestStatic, ReadWriteStringToByteVectorMapVariantWrapped) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer.OpenVariant("a{sv}", &variant_writer);
-  variant_writer.OpenArray("{sv}", &dict_writer);
-
-  const char* keys[] = {"One", "Two", "Three", "Four"};
-  const std::vector<uint8_t> values[] = {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}};
-  for (unsigned i = 0; i < base::size(keys); ++i) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendString(keys[i]);
-
-    MessageWriter value_varient_writer(nullptr);
-    entry_writer.OpenVariant("ay", &value_varient_writer);
-    value_varient_writer.AppendArrayOfBytes(values[i].data(), values[i].size());
-    entry_writer.CloseContainer(&value_varient_writer);
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::map<std::string, std::vector<uint8_t>>> test_property;
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-
-  ASSERT_EQ(base::size(keys), test_property.value().size());
-  for (unsigned i = 0; i < base::size(keys); ++i)
-    EXPECT_EQ(values[i], test_property.value().at(keys[i]));
-}
-
-TEST(PropertyTestStatic, ReadWriteStringToByteVectorMap) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer.OpenVariant("a{say}", &variant_writer);
-  variant_writer.OpenArray("{say}", &dict_writer);
-
-  const char* keys[] = {"One", "Two", "Three", "Four"};
-  const std::vector<uint8_t> values[] = {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}};
-  for (unsigned i = 0; i < base::size(keys); ++i) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendString(keys[i]);
-    entry_writer.AppendArrayOfBytes(values[i].data(), values[i].size());
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::map<std::string, std::vector<uint8_t>>> test_property;
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-
-  ASSERT_EQ(base::size(keys), test_property.value().size());
-  for (unsigned i = 0; i < base::size(keys); ++i)
-    EXPECT_EQ(values[i], test_property.value().at(keys[i]));
-}
-
-TEST(PropertyTestStatic, SerializeStringToByteVectorMap) {
-  std::map<std::string, std::vector<uint8_t>> test_map;
-  test_map["Hi"] = {1, 2, 3};
-  test_map["Map"] = {0xab, 0xcd};
-  test_map["Random"] = {0x0};
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  Property<std::map<std::string, std::vector<uint8_t>>> test_property;
-  test_property.ReplaceSetValueForTesting(test_map);
-  test_property.AppendSetValueToWriter(&writer);
-
-  MessageReader reader(message.get());
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-  EXPECT_EQ(test_map, test_property.value());
-}
-
-TEST(PropertyTestStatic, ReadWriteUInt16ToByteVectorMapVariantWrapped) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer.OpenVariant("a{qv}", &variant_writer);
-  variant_writer.OpenArray("{qv}", &dict_writer);
-
-  const uint16_t keys[] = {11, 12, 13, 14};
-  const std::vector<uint8_t> values[] = {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}};
-  for (unsigned i = 0; i < base::size(keys); ++i) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendUint16(keys[i]);
-
-    MessageWriter value_varient_writer(nullptr);
-    entry_writer.OpenVariant("ay", &value_varient_writer);
-    value_varient_writer.AppendArrayOfBytes(values[i].data(), values[i].size());
-    entry_writer.CloseContainer(&value_varient_writer);
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::map<uint16_t, std::vector<uint8_t>>> test_property;
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-
-  ASSERT_EQ(base::size(keys), test_property.value().size());
-  for (unsigned i = 0; i < base::size(keys); ++i)
-    EXPECT_EQ(values[i], test_property.value().at(keys[i]));
-}
-
-TEST(PropertyTestStatic, ReadWriteUInt16ToByteVectorMap) {
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-  MessageWriter variant_writer(nullptr);
-  MessageWriter dict_writer(nullptr);
-
-  writer.OpenVariant("a{qay}", &variant_writer);
-  variant_writer.OpenArray("{qay}", &dict_writer);
-
-  const uint16_t keys[] = {11, 12, 13, 14};
-  const std::vector<uint8_t> values[] = {{1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}};
-  for (unsigned i = 0; i < base::size(keys); ++i) {
-    MessageWriter entry_writer(nullptr);
-    dict_writer.OpenDictEntry(&entry_writer);
-
-    entry_writer.AppendUint16(keys[i]);
-    entry_writer.AppendArrayOfBytes(values[i].data(), values[i].size());
-
-    dict_writer.CloseContainer(&entry_writer);
-  }
-
-  variant_writer.CloseContainer(&dict_writer);
-  writer.CloseContainer(&variant_writer);
-
-  MessageReader reader(message.get());
-  Property<std::map<uint16_t, std::vector<uint8_t>>> test_property;
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-
-  ASSERT_EQ(base::size(keys), test_property.value().size());
-  for (unsigned i = 0; i < base::size(keys); ++i)
-    EXPECT_EQ(values[i], test_property.value().at(keys[i]));
-}
-
-TEST(PropertyTestStatic, SerializeUInt16ToByteVectorMap) {
-  std::map<uint16_t, std::vector<uint8_t>> test_map;
-  test_map[11] = {1, 2, 3};
-  test_map[12] = {0xab, 0xcd};
-  test_map[13] = {0x0};
-
-  std::unique_ptr<Response> message(Response::CreateEmpty());
-  MessageWriter writer(message.get());
-
-  Property<std::map<uint16_t, std::vector<uint8_t>>> test_property;
-  test_property.ReplaceSetValueForTesting(test_map);
-  test_property.AppendSetValueToWriter(&writer);
-
-  MessageReader reader(message.get());
-  EXPECT_TRUE(test_property.PopValueFromReader(&reader));
-  EXPECT_EQ(test_map, test_property.value());
-}
-
 }  // namespace dbus
diff -u a/dbus/scoped_dbus_error.cc b/dbus/scoped_dbus_error.cc
--- a/dbus/scoped_dbus_error.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/scoped_dbus_error.cc	2020-06-09 18:25:34.741176635 +0200
@@ -7,15 +7,13 @@
 namespace dbus {
 
 ScopedDBusError::ScopedDBusError() {
-  dbus_error_init(&error_);
 }
 
 ScopedDBusError::~ScopedDBusError() {
-  dbus_error_free(&error_);
 }
 
 bool ScopedDBusError::is_set() const {
-  return dbus_error_is_set(&error_);
+  return true;
 }
 
 }  // namespace dbus
diff -u a/dbus/scoped_dbus_error.h b/dbus/scoped_dbus_error.h
--- a/dbus/scoped_dbus_error.h	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/scoped_dbus_error.h	2020-06-09 18:24:59.238014013 +0200
@@ -5,8 +5,6 @@
 #ifndef DBUS_SCOPED_DBUS_ERROR_H_
 #define DBUS_SCOPED_DBUS_ERROR_H_
 
-#include <dbus/dbus.h>
-
 #include "dbus/dbus_export.h"
 
 namespace dbus {
@@ -19,13 +17,12 @@
   ScopedDBusError();
   ~ScopedDBusError();
 
-  DBusError* get() { return &error_; }
+  void* get() { return nullptr; }
   bool is_set() const;
-  const char* name() { return error_.name; }
-  const char* message() { return error_.message; }
+  const char* name() { return nullptr; }
+  const char* message() { return nullptr; }
 
  private:
-  DBusError error_;
 };
 
 }  // namespace dbus
diff -u a/dbus/signal_sender_verification_unittest.cc b/dbus/signal_sender_verification_unittest.cc
--- a/dbus/signal_sender_verification_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/signal_sender_verification_unittest.cc	2020-06-09 19:59:32.730754659 +0200
@@ -31,138 +31,41 @@
   }
 
   void SetUp() override {
-    // Make the main thread not to allow IO.
-    base::ThreadRestrictions::SetIOAllowed(false);
-
-    // Start the D-Bus thread.
-    dbus_thread_.reset(new base::Thread("D-Bus Thread"));
-    base::Thread::Options thread_options;
-    thread_options.message_pump_type = base::MessagePumpType::IO;
-    ASSERT_TRUE(dbus_thread_->StartWithOptions(thread_options));
-
-    // Create the test service, using the D-Bus thread.
-    TestService::Options options;
-    options.dbus_task_runner = dbus_thread_->task_runner();
-    test_service_.reset(new TestService(options));
-
-    // Create the client, using the D-Bus thread.
-    Bus::Options bus_options;
-    bus_options.bus_type = Bus::SESSION;
-    bus_options.connection_type = Bus::PRIVATE;
-    bus_options.dbus_task_runner = dbus_thread_->task_runner();
-    bus_ = new Bus(bus_options);
-    object_proxy_ = bus_->GetObjectProxy(
-        test_service_->service_name(),
-        ObjectPath("/org/chromium/TestObject"));
-    ASSERT_TRUE(bus_->HasDBusThread());
-
-    object_proxy_->SetNameOwnerChangedCallback(base::BindRepeating(
-        &SignalSenderVerificationTest::OnNameOwnerChanged,
-        base::Unretained(this), &on_name_owner_changed_called_));
-
-    // Connect to the "Test" signal of "org.chromium.TestInterface" from
-    // the remote object.
-    object_proxy_->ConnectToSignal(
-        "org.chromium.TestInterface", "Test",
-        base::BindRepeating(&SignalSenderVerificationTest::OnTestSignal,
-                            base::Unretained(this)),
-        base::BindOnce(&SignalSenderVerificationTest::OnConnected,
-                       base::Unretained(this)));
-    // Wait until the object proxy is connected to the signal.
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-
-    // Start the test service.
-    ASSERT_TRUE(test_service_->StartService());
-    test_service_->WaitUntilServiceIsStarted();
-    ASSERT_TRUE(test_service_->HasDBusThread());
-    ASSERT_TRUE(test_service_->has_ownership());
-
-    // Same setup for the second TestService. This service should not have the
-    // ownership of the name at this point.
-    options.service_name = test_service_->service_name();
-    test_service2_.reset(new TestService(options));
-    ASSERT_TRUE(test_service2_->StartService());
-    test_service2_->WaitUntilServiceIsStarted();
-    ASSERT_TRUE(test_service2_->HasDBusThread());
-    ASSERT_FALSE(test_service2_->has_ownership());
-
-    // The name should be owned and known at this point.
-    if (!on_name_owner_changed_called_) {
-      run_loop_.reset(new base::RunLoop);
-      run_loop_->Run();
-    }
-    ASSERT_FALSE(latest_name_owner_.empty());
   }
 
   void TearDown() override {
-    bus_->ShutdownOnDBusThreadAndBlock();
-
-    // Shut down the service.
-    test_service_->ShutdownAndBlock();
-    test_service2_->ShutdownAndBlock();
-
-    // Reset to the default.
-    base::ThreadRestrictions::SetIOAllowed(true);
-
-    // Stopping a thread is considered an IO operation, so do this after
-    // allowing IO.
-    test_service_->Stop();
-    test_service2_->Stop();
   }
 
   void OnOwnership(bool expected, bool success) {
-    ASSERT_EQ(expected, success);
-    // PostTask to quit the RunLoop as this is called from D-Bus thread.
-    task_environment_.GetMainThreadTaskRunner()->PostTask(
-        FROM_HERE,
-        base::BindOnce(&SignalSenderVerificationTest::OnOwnershipInternal,
-                       base::Unretained(this)));
   }
 
   void OnOwnershipInternal() {
-    on_ownership_called_ = true;
-    run_loop_->Quit();
   }
 
   void OnNameOwnerChanged(bool* called_flag,
                           const std::string& old_owner,
                           const std::string& new_owner) {
-    latest_name_owner_ = new_owner;
-    *called_flag = true;
-    run_loop_->Quit();
   }
 
   // Called when the "Test" signal is received, in the main thread.
   // Copy the string payload to |test_signal_string_|.
   void OnTestSignal(Signal* signal) {
-    MessageReader reader(signal);
-    ASSERT_TRUE(reader.PopString(&test_signal_string_));
-    run_loop_->Quit();
   }
 
   // Called when connected to the signal.
   void OnConnected(const std::string& interface_name,
                    const std::string& signal_name,
                    bool success) {
-    ASSERT_TRUE(success);
-    run_loop_->Quit();
   }
 
  protected:
   // Wait for the hey signal to be received.
   void WaitForTestSignal() {
-    // OnTestSignal() will quit the message loop.
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
   }
 
   // Stopping a thread is considered an IO operation, so we need to fiddle with
   // thread restrictions before and after calling Stop() on a TestService.
   void SafeServiceStop(TestService* test_service) {
-    base::ThreadRestrictions::SetIOAllowed(true);
-    test_service->Stop();
-    base::ThreadRestrictions::SetIOAllowed(false);
   }
 
   base::test::SingleThreadTaskEnvironment task_environment_;
@@ -183,209 +86,4 @@
   bool on_ownership_called_;
 };
 
-TEST_F(SignalSenderVerificationTest, TestSignalAccepted) {
-  const char kMessage[] = "hello, world";
-  // Send the test signal from the exported object.
-  test_service_->SendTestSignal(kMessage);
-  // Receive the signal with the object proxy. The signal is handled in
-  // SignalSenderVerificationTest::OnTestSignal() in the main thread.
-  WaitForTestSignal();
-  ASSERT_EQ(kMessage, test_signal_string_);
-}
-
-TEST_F(SignalSenderVerificationTest, TestSignalRejected) {
-  const char kNewMessage[] = "hello, new world";
-  test_service2_->SendTestSignal(kNewMessage);
-
-  // This test tests that our callback is NOT called by the ObjectProxy.
-  // Sleep to have message delivered to the client via the D-Bus service.
-  base::PlatformThread::Sleep(TestTimeouts::tiny_timeout());
-
-  ASSERT_EQ("", test_signal_string_);
-}
-
-// Flaky. https://crbug.com/785555
-TEST_F(SignalSenderVerificationTest, DISABLED_TestOwnerChanged) {
-  const char kMessage[] = "hello, world";
-
-  // Send the test signal from the exported object.
-  test_service_->SendTestSignal(kMessage);
-  // Receive the signal with the object proxy. The signal is handled in
-  // SignalSenderVerificationTest::OnTestSignal() in the main thread.
-  WaitForTestSignal();
-  ASSERT_EQ(kMessage, test_signal_string_);
-
-  // Release and acquire the name ownership.
-  // latest_name_owner_ should be non empty as |test_service_| owns the name.
-  ASSERT_FALSE(latest_name_owner_.empty());
-  test_service_->ShutdownAndBlock();
-  // OnNameOwnerChanged will PostTask to quit the message loop.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-  // latest_name_owner_ should be empty as the owner is gone.
-  ASSERT_TRUE(latest_name_owner_.empty());
-
-  // Reset the flag as NameOwnerChanged is already received in setup.
-  on_name_owner_changed_called_ = false;
-  on_ownership_called_ = false;
-  test_service2_->RequestOwnership(
-      base::BindOnce(&SignalSenderVerificationTest::OnOwnership,
-                     base::Unretained(this), true));
-  // Both of OnNameOwnerChanged() and OnOwnership() should quit the MessageLoop,
-  // but there's no expected order of those 2 event.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-  if (!on_name_owner_changed_called_ || !on_ownership_called_) {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-  }
-  ASSERT_TRUE(on_name_owner_changed_called_);
-  ASSERT_TRUE(on_ownership_called_);
-
-  // latest_name_owner_ becomes non empty as the new owner appears.
-  ASSERT_FALSE(latest_name_owner_.empty());
-
-  // Now the second service owns the name.
-  const char kNewMessage[] = "hello, new world";
-
-  test_service2_->SendTestSignal(kNewMessage);
-  WaitForTestSignal();
-  ASSERT_EQ(kNewMessage, test_signal_string_);
-}
-
-// Flaky. https://crbug.com/785555
-TEST_F(SignalSenderVerificationTest, DISABLED_TestOwnerStealing) {
-  // Release and acquire the name ownership.
-  // latest_name_owner_ should be non empty as |test_service_| owns the name.
-  ASSERT_FALSE(latest_name_owner_.empty());
-  test_service_->ShutdownAndBlock();
-  // OnNameOwnerChanged will PostTask to quit the message loop.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-  // latest_name_owner_ should be empty as the owner is gone.
-  ASSERT_TRUE(latest_name_owner_.empty());
-  // Reset the flag as NameOwnerChanged is already received in setup.
-  on_name_owner_changed_called_ = false;
-
-  // Start a test service that allows theft, using the D-Bus thread.
-  TestService::Options options;
-  options.dbus_task_runner = dbus_thread_->task_runner();
-  options.request_ownership_options = Bus::REQUIRE_PRIMARY_ALLOW_REPLACEMENT;
-  options.service_name = test_service_->service_name();
-  TestService stealable_test_service(options);
-  ASSERT_TRUE(stealable_test_service.StartService());
-  stealable_test_service.WaitUntilServiceIsStarted();
-  ASSERT_TRUE(stealable_test_service.HasDBusThread());
-  ASSERT_TRUE(stealable_test_service.has_ownership());
-
-  // OnNameOwnerChanged will PostTask to quit the message loop.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-
-  // Send a signal to check that the service is correctly owned.
-  const char kMessage[] = "hello, world";
-
-  // Send the test signal from the exported object.
-  stealable_test_service.SendTestSignal(kMessage);
-  // Receive the signal with the object proxy. The signal is handled in
-  // SignalSenderVerificationTest::OnTestSignal() in the main thread.
-  WaitForTestSignal();
-  ASSERT_EQ(kMessage, test_signal_string_);
-
-  // Reset the flag as NameOwnerChanged was called above.
-  on_name_owner_changed_called_ = false;
-  test_service2_->RequestOwnership(
-      base::BindOnce(&SignalSenderVerificationTest::OnOwnership,
-                     base::Unretained(this), true));
-  // Both of OnNameOwnerChanged() and OnOwnership() should quit the MessageLoop,
-  // but there's no expected order of those 2 event.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-  if (!on_name_owner_changed_called_ || !on_ownership_called_) {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-  }
-  ASSERT_TRUE(on_name_owner_changed_called_);
-  ASSERT_TRUE(on_ownership_called_);
-
-  // Now the second service owns the name.
-  const char kNewMessage[] = "hello, new world";
-
-  test_service2_->SendTestSignal(kNewMessage);
-  WaitForTestSignal();
-  ASSERT_EQ(kNewMessage, test_signal_string_);
-
-  SafeServiceStop(&stealable_test_service);
-}
-
-// Fails on Linux ChromiumOS Tests
-TEST_F(SignalSenderVerificationTest, DISABLED_TestMultipleObjects) {
-  const char kMessage[] = "hello, world";
-
-  ObjectProxy* object_proxy2 = bus_->GetObjectProxy(
-      test_service_->service_name(),
-      ObjectPath("/org/chromium/DifferentObject"));
-
-  bool second_name_owner_changed_called = false;
-  object_proxy2->SetNameOwnerChangedCallback(base::BindRepeating(
-      &SignalSenderVerificationTest::OnNameOwnerChanged, base::Unretained(this),
-      &second_name_owner_changed_called));
-
-  // Connect to a signal on the additional remote object to trigger the
-  // name owner matching.
-  object_proxy2->ConnectToSignal(
-      "org.chromium.DifferentTestInterface", "Test",
-      base::BindRepeating(&SignalSenderVerificationTest::OnTestSignal,
-                          base::Unretained(this)),
-      base::BindOnce(&SignalSenderVerificationTest::OnConnected,
-                     base::Unretained(this)));
-  // Wait until the object proxy is connected to the signal.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-
-  // Send the test signal from the exported object.
-  test_service_->SendTestSignal(kMessage);
-  // Receive the signal with the object proxy. The signal is handled in
-  // SignalSenderVerificationTest::OnTestSignal() in the main thread.
-  WaitForTestSignal();
-  ASSERT_EQ(kMessage, test_signal_string_);
-
-  // Release and acquire the name ownership.
-  // latest_name_owner_ should be non empty as |test_service_| owns the name.
-  ASSERT_FALSE(latest_name_owner_.empty());
-  test_service_->ShutdownAndBlock();
-  // OnNameOwnerChanged will PostTask to quit the message loop.
-  run_loop_.reset(new base::RunLoop);
-  run_loop_->Run();
-  // latest_name_owner_ should be empty as the owner is gone.
-  ASSERT_TRUE(latest_name_owner_.empty());
-
-  // Reset the flag as NameOwnerChanged is already received in setup.
-  on_name_owner_changed_called_ = false;
-  second_name_owner_changed_called = false;
-  test_service2_->RequestOwnership(
-      base::BindOnce(&SignalSenderVerificationTest::OnOwnership,
-                     base::Unretained(this), true));
-  // Both of OnNameOwnerChanged() and OnOwnership() should quit the MessageLoop,
-  // but there's no expected order of those 2 event.
-  while (!on_name_owner_changed_called_ || !second_name_owner_changed_called ||
-         !on_ownership_called_) {
-    run_loop_.reset(new base::RunLoop);
-    run_loop_->Run();
-  }
-  ASSERT_TRUE(on_name_owner_changed_called_);
-  ASSERT_TRUE(second_name_owner_changed_called);
-  ASSERT_TRUE(on_ownership_called_);
-
-  // latest_name_owner_ becomes non empty as the new owner appears.
-  ASSERT_FALSE(latest_name_owner_.empty());
-
-  // Now the second service owns the name.
-  const char kNewMessage[] = "hello, new world";
-
-  test_service2_->SendTestSignal(kNewMessage);
-  WaitForTestSignal();
-  ASSERT_EQ(kNewMessage, test_signal_string_);
-}
-
 }  // namespace dbus
diff -u a/dbus/string_util_unittest.cc b/dbus/string_util_unittest.cc
--- a/dbus/string_util_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/string_util_unittest.cc	2020-06-09 19:59:41.594026957 +0200
@@ -7,25 +7,4 @@
 
 namespace dbus {
 
-TEST(StringUtilTest, IsValidObjectPath) {
-  EXPECT_TRUE(IsValidObjectPath("/"));
-  EXPECT_TRUE(IsValidObjectPath("/foo/bar"));
-  EXPECT_TRUE(IsValidObjectPath("/hoge_fuga/piyo123"));
-  // Empty string.
-  EXPECT_FALSE(IsValidObjectPath(std::string()));
-  // Empty element.
-  EXPECT_FALSE(IsValidObjectPath("//"));
-  EXPECT_FALSE(IsValidObjectPath("/foo//bar"));
-  EXPECT_FALSE(IsValidObjectPath("/foo///bar"));
-  // Trailing '/'.
-  EXPECT_FALSE(IsValidObjectPath("/foo/"));
-  EXPECT_FALSE(IsValidObjectPath("/foo/bar/"));
-  // Not beginning with '/'.
-  EXPECT_FALSE(IsValidObjectPath("foo/bar"));
-  // Invalid characters.
-  EXPECT_FALSE(IsValidObjectPath("/foo.bar"));
-  EXPECT_FALSE(IsValidObjectPath("/foo/*"));
-  EXPECT_FALSE(IsValidObjectPath("/foo/bar(1)"));
-}
-
 }  // namespace dbus
diff -u a/dbus/test_server.cc b/dbus/test_server.cc
--- a/dbus/test_server.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/test_server.cc	2020-06-09 20:00:19.370433480 +0200
@@ -10,19 +10,4 @@
 #include "dbus/test_service.h"
 
 int main(int argc, char** argv) {
-  base::AtExitManager exit_manager;
-  base::CommandLine::Init(argc, argv);
-  TestTimeouts::Initialize();
-
-  base::Thread dbus_thread("D-Bus Thread");
-  base::Thread::Options thread_options;
-  thread_options.message_pump_type = base::MessagePumpType::IO;
-  CHECK(dbus_thread.StartWithOptions(thread_options));
-
-  dbus::TestService::Options options;
-  options.dbus_task_runner = dbus_thread.task_runner();
-  dbus::TestService* test_service = new dbus::TestService(options);
-  CHECK(test_service->StartService());
-  test_service->WaitUntilServiceIsStarted();
-  CHECK(test_service->HasDBusThread());
 }
diff -u a/dbus/test_service.cc b/dbus/test_service.cc
--- a/dbus/test_service.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/test_service.cc	2020-06-09 20:05:43.668200346 +0200
@@ -54,433 +54,108 @@
 }
 
 TestService::~TestService() {
-  Stop();
 }
 
 bool TestService::StartService() {
-  base::Thread::Options thread_options;
-  thread_options.message_pump_type = base::MessagePumpType::IO;
-  return StartWithOptions(thread_options);
+  return true;
 }
 
 void TestService::WaitUntilServiceIsStarted() {
-  // Wait until the ownership of the service name is obtained.
-  on_name_obtained_.Wait();
 }
 
 void TestService::ShutdownAndBlock() {
-  task_runner()->PostTask(FROM_HERE,
-                          base::BindOnce(&TestService::ShutdownAndBlockInternal,
-                                         base::Unretained(this)));
 }
 
 bool TestService::HasDBusThread() {
-  return bus_->HasDBusThread();
+  return true;
 }
 
 void TestService::ShutdownAndBlockInternal() {
-  if (HasDBusThread())
-    bus_->ShutdownOnDBusThreadAndBlock();
-  else
-    bus_->ShutdownAndBlock();
 }
 
 void TestService::SendTestSignal(const std::string& message) {
-  task_runner()->PostTask(FROM_HERE,
-                          base::BindOnce(&TestService::SendTestSignalInternal,
-                                         base::Unretained(this), message));
 }
 
 void TestService::SendTestSignalFromRoot(const std::string& message) {
-  task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&TestService::SendTestSignalFromRootInternal,
-                                base::Unretained(this), message));
 }
 
 void TestService::SendTestSignalInternal(const std::string& message) {
-  Signal signal("org.chromium.TestInterface", "Test");
-  MessageWriter writer(&signal);
-  writer.AppendString(message);
-  exported_object_->SendSignal(&signal);
 }
 
 void TestService::SendTestSignalFromRootInternal(const std::string& message) {
-  Signal signal("org.chromium.TestInterface", "Test");
-  MessageWriter writer(&signal);
-  writer.AppendString(message);
-
-  bus_->RequestOwnership(
-      service_name_, request_ownership_options_,
-      base::BindOnce(&TestService::OnOwnership, base::Unretained(this),
-                     base::DoNothing::Once<bool>()));
-
-  // Use "/" just like dbus-send does.
-  ExportedObject* root_object = bus_->GetExportedObject(ObjectPath("/"));
-  root_object->SendSignal(&signal);
 }
 
 void TestService::RequestOwnership(base::OnceCallback<void(bool)> callback) {
-  task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&TestService::RequestOwnershipInternal,
-                                base::Unretained(this), std::move(callback)));
 }
 
 void TestService::RequestOwnershipInternal(
-    base::OnceCallback<void(bool)> callback) {
-  bus_->RequestOwnership(
-      service_name_, request_ownership_options_,
-      base::BindOnce(&TestService::OnOwnership, base::Unretained(this),
-                     std::move(callback)));
 }
 
 void TestService::OnOwnership(base::OnceCallback<void(bool)> callback,
                               const std::string& service_name,
                               bool success) {
-  has_ownership_ = success;
-  LOG_IF(ERROR, !success) << "Failed to own: " << service_name;
-  std::move(callback).Run(success);
-
-  on_name_obtained_.Signal();
 }
 
 void TestService::ReleaseOwnership(base::OnceClosure callback) {
-  bus_->GetDBusTaskRunner()->PostTask(
-      FROM_HERE, base::BindOnce(&TestService::ReleaseOwnershipInternal,
-                                base::Unretained(this), std::move(callback)));
 }
 
 void TestService::ReleaseOwnershipInternal(base::OnceClosure callback) {
-  bus_->ReleaseOwnership(service_name_);
-  has_ownership_ = false;
-
-  bus_->GetOriginTaskRunner()->PostTask(FROM_HERE, std::move(callback));
 }
 
 void TestService::SetSendImmediatePropertiesChanged() {
-  send_immediate_properties_changed_ = true;
 }
 
 void TestService::OnExported(const std::string& interface_name,
                              const std::string& method_name,
                              bool success) {
-  if (!success) {
-    LOG(ERROR) << "Failed to export: " << interface_name << "."
-               << method_name;
-    // Returning here will make WaitUntilServiceIsStarted() to time out
-    // and return false.
-    return;
-  }
-
-  ++num_exported_methods_;
-  if (num_exported_methods_ == kNumMethodsToExport) {
-    // As documented in exported_object.h, the service name should be
-    // requested after all methods are exposed.
-    bus_->RequestOwnership(
-        service_name_, request_ownership_options_,
-        base::BindOnce(&TestService::OnOwnership, base::Unretained(this),
-                       base::DoNothing::Once<bool>()));
-  }
 }
 
 void TestService::Run(base::RunLoop* run_loop) {
-  Bus::Options bus_options;
-  bus_options.bus_type = Bus::SESSION;
-  bus_options.connection_type = Bus::PRIVATE;
-  bus_options.dbus_task_runner = dbus_task_runner_;
-  bus_ = new Bus(bus_options);
-
-  exported_object_ = bus_->GetExportedObject(
-      ObjectPath("/org/chromium/TestObject"));
-
-  int num_methods = 0;
-  exported_object_->ExportMethod(
-      "org.chromium.TestInterface", "Echo",
-      base::BindRepeating(&TestService::Echo, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      "org.chromium.TestInterface", "SlowEcho",
-      base::BindRepeating(&TestService::SlowEcho, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      "org.chromium.TestInterface", "AsyncEcho",
-      base::BindRepeating(&TestService::AsyncEcho, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      "org.chromium.TestInterface", "BrokenMethod",
-      base::BindRepeating(&TestService::BrokenMethod, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      "org.chromium.TestInterface", "PerformAction",
-      base::BindRepeating(&TestService::PerformAction, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      kPropertiesInterface, kPropertiesGetAll,
-      base::BindRepeating(&TestService::GetAllProperties,
-                          base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      kPropertiesInterface, kPropertiesGet,
-      base::BindRepeating(&TestService::GetProperty, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_->ExportMethod(
-      kPropertiesInterface, kPropertiesSet,
-      base::BindRepeating(&TestService::SetProperty, base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  exported_object_manager_ = bus_->GetExportedObject(
-      ObjectPath("/org/chromium/TestService"));
-
-  exported_object_manager_->ExportMethod(
-      kObjectManagerInterface, kObjectManagerGetManagedObjects,
-      base::BindRepeating(&TestService::GetManagedObjects,
-                          base::Unretained(this)),
-      base::BindOnce(&TestService::OnExported, base::Unretained(this)));
-  ++num_methods;
-
-  // Just print an error message as we don't want to crash tests.
-  // Tests will fail at a call to WaitUntilServiceIsStarted().
-  if (num_methods != kNumMethodsToExport) {
-    LOG(ERROR) << "The number of methods does not match";
-  }
-  run_loop->Run();
 }
 
 void TestService::Echo(MethodCall* method_call,
                        ExportedObject::ResponseSender response_sender) {
-  MessageReader reader(method_call);
-  std::string text_message;
-  if (!reader.PopString(&text_message)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-  MessageWriter writer(response.get());
-  writer.AppendString(text_message);
-  std::move(response_sender).Run(std::move(response));
 }
 
 void TestService::SlowEcho(MethodCall* method_call,
                            ExportedObject::ResponseSender response_sender) {
-  base::PlatformThread::Sleep(TestTimeouts::tiny_timeout());
-  Echo(method_call, std::move(response_sender));
 }
 
 void TestService::AsyncEcho(MethodCall* method_call,
                             ExportedObject::ResponseSender response_sender) {
-  // Schedule a call to Echo() to send an asynchronous response after we return.
-  task_runner()->PostDelayedTask(
-      FROM_HERE,
-      base::BindOnce(&TestService::Echo, base::Unretained(this), method_call,
-                     std::move(response_sender)),
-      TestTimeouts::tiny_timeout());
 }
 
 void TestService::BrokenMethod(MethodCall* method_call,
                                ExportedObject::ResponseSender response_sender) {
-  std::move(response_sender).Run(std::unique_ptr<Response>());
 }
 
 
 void TestService::GetAllProperties(
     MethodCall* method_call,
     ExportedObject::ResponseSender response_sender) {
-  MessageReader reader(method_call);
-  std::string interface;
-  if (!reader.PopString(&interface)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-  MessageWriter writer(response.get());
-
-  AddPropertiesToWriter(&writer);
-
-  std::move(response_sender).Run(std::move(response));
 }
 
 void TestService::GetProperty(MethodCall* method_call,
                               ExportedObject::ResponseSender response_sender) {
-  MessageReader reader(method_call);
-  std::string interface;
-  if (!reader.PopString(&interface)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  std::string name;
-  if (!reader.PopString(&name)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  if (name == "Name") {
-    // Return the previous value for the "Name" property:
-    // Variant<"TestService">
-    std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-    MessageWriter writer(response.get());
-
-    writer.AppendVariantOfString("TestService");
-
-    std::move(response_sender).Run(std::move(response));
-  } else if (name == "Version") {
-    // Return a new value for the "Version" property:
-    // Variant<20>
-    std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-    MessageWriter writer(response.get());
-
-    writer.AppendVariantOfInt16(20);
-
-    std::move(response_sender).Run(std::move(response));
-  } else if (name == "Methods") {
-    // Return the previous value for the "Methods" property:
-    // Variant<["Echo", "SlowEcho", "AsyncEcho", "BrokenMethod"]>
-    std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-    MessageWriter writer(response.get());
-    MessageWriter variant_writer(nullptr);
-    MessageWriter variant_array_writer(nullptr);
-
-    writer.OpenVariant("as", &variant_writer);
-    variant_writer.OpenArray("s", &variant_array_writer);
-    variant_array_writer.AppendString("Echo");
-    variant_array_writer.AppendString("SlowEcho");
-    variant_array_writer.AppendString("AsyncEcho");
-    variant_array_writer.AppendString("BrokenMethod");
-    variant_writer.CloseContainer(&variant_array_writer);
-    writer.CloseContainer(&variant_writer);
-
-    std::move(response_sender).Run(std::move(response));
-  } else if (name == "Objects") {
-    // Return the previous value for the "Objects" property:
-    // Variant<[objectpath:"/TestObjectPath"]>
-    std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-    MessageWriter writer(response.get());
-    MessageWriter variant_writer(nullptr);
-    MessageWriter variant_array_writer(nullptr);
-
-    writer.OpenVariant("ao", &variant_writer);
-    variant_writer.OpenArray("o", &variant_array_writer);
-    variant_array_writer.AppendObjectPath(ObjectPath("/TestObjectPath"));
-    variant_writer.CloseContainer(&variant_array_writer);
-    writer.CloseContainer(&variant_writer);
-
-    std::move(response_sender).Run(std::move(response));
-  } else if (name == "Bytes") {
-    // Return the previous value for the "Bytes" property:
-    // Variant<[0x54, 0x65, 0x73, 0x74]>
-    std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-    MessageWriter writer(response.get());
-    MessageWriter variant_writer(nullptr);
-    MessageWriter variant_array_writer(nullptr);
-
-    writer.OpenVariant("ay", &variant_writer);
-    const uint8_t bytes[] = {0x54, 0x65, 0x73, 0x74};
-    variant_writer.AppendArrayOfBytes(bytes, sizeof(bytes));
-    writer.CloseContainer(&variant_writer);
-
-    std::move(response_sender).Run(std::move(response));
-  } else {
-    // Return error.
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
 }
 
 void TestService::SetProperty(MethodCall* method_call,
                               ExportedObject::ResponseSender response_sender) {
-  MessageReader reader(method_call);
-  std::string interface;
-  if (!reader.PopString(&interface)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  std::string name;
-  if (!reader.PopString(&name)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  if (name != "Name") {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  std::string value;
-  if (!reader.PopVariantOfString(&value)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  SendPropertyChangedSignal(value);
-
-  std::move(response_sender).Run(Response::FromMethodCall(method_call));
 }
 
 void TestService::PerformAction(
       MethodCall* method_call,
       ExportedObject::ResponseSender response_sender) {
-  MessageReader reader(method_call);
-  std::string action;
-  ObjectPath object_path;
-  if (!reader.PopString(&action) || !reader.PopObjectPath(&object_path)) {
-    std::move(response_sender).Run(std::unique_ptr<Response>());
-    return;
-  }
-
-  if (action == "AddObject") {
-    AddObject(object_path);
-  } else if (action == "RemoveObject") {
-    RemoveObject(object_path);
-  } else if (action == "SetSendImmediatePropertiesChanged") {
-    SetSendImmediatePropertiesChanged();
-  } else if (action == "ReleaseOwnership") {
-    ReleaseOwnership(base::BindOnce(&TestService::PerformActionResponse,
-                                    base::Unretained(this), method_call,
-                                    std::move(response_sender)));
-    return;
-  } else if (action == "Ownership") {
-    ReleaseOwnership(base::BindOnce(&TestService::OwnershipReleased,
-                                    base::Unretained(this), method_call,
-                                    std::move(response_sender)));
-    return;
-  } else if (action == "InvalidateProperty") {
-    SendPropertyInvalidatedSignal();
-  }
-
-  std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-  std::move(response_sender).Run(std::move(response));
 }
 
 void TestService::PerformActionResponse(
     MethodCall* method_call,
     ExportedObject::ResponseSender response_sender) {
-  std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-  std::move(response_sender).Run(std::move(response));
 }
 
 void TestService::OwnershipReleased(
     MethodCall* method_call,
     ExportedObject::ResponseSender response_sender) {
-  RequestOwnership(base::BindOnce(&TestService::OwnershipRegained,
-                                  base::Unretained(this), method_call,
-                                  std::move(response_sender)));
 }
 
 
@@ -488,215 +163,39 @@
     MethodCall* method_call,
     ExportedObject::ResponseSender response_sender,
     bool success) {
-  PerformActionResponse(method_call, std::move(response_sender));
 }
 
 
 void TestService::GetManagedObjects(
     MethodCall* method_call,
     ExportedObject::ResponseSender response_sender) {
-  std::unique_ptr<Response> response = Response::FromMethodCall(method_call);
-  MessageWriter writer(response.get());
-
-  // The managed objects response is a dictionary of object paths identifying
-  // the object(s) with a dictionary of strings identifying the interface(s)
-  // they implement and then a dictionary of property values.
-  //
-  // Thus this looks something like:
-  //
-  // {
-  //   "/org/chromium/TestObject": {
-  //     "org.chromium.TestInterface": { /* Properties */ }
-  //   }
-  // }
-
-
-  MessageWriter array_writer(nullptr);
-  MessageWriter dict_entry_writer(nullptr);
-  MessageWriter object_array_writer(nullptr);
-  MessageWriter object_dict_entry_writer(nullptr);
-
-  writer.OpenArray("{oa{sa{sv}}}", &array_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendObjectPath(ObjectPath("/org/chromium/TestObject"));
-  dict_entry_writer.OpenArray("{sa{sv}}", &object_array_writer);
-
-  object_array_writer.OpenDictEntry(&object_dict_entry_writer);
-  object_dict_entry_writer.AppendString("org.chromium.TestInterface");
-  AddPropertiesToWriter(&object_dict_entry_writer);
-  object_array_writer.CloseContainer(&object_dict_entry_writer);
-
-  dict_entry_writer.CloseContainer(&object_array_writer);
-
-  array_writer.CloseContainer(&dict_entry_writer);
-  writer.CloseContainer(&array_writer);
-
-  std::move(response_sender).Run(std::move(response));
-
-  if (send_immediate_properties_changed_)
-    SendPropertyChangedSignal("ChangedTestServiceName");
 }
 
 void TestService::AddPropertiesToWriter(MessageWriter* writer) {
-  // The properties response is a dictionary of strings identifying the
-  // property and a variant containing the property value. We return all
-  // of the properties, thus the response is:
-  //
-  // {
-  //   "Name": Variant<"TestService">,
-  //   "Version": Variant<10>,
-  //   "Methods": Variant<["Echo", "SlowEcho", "AsyncEcho", "BrokenMethod"]>,
-  //   "Objects": Variant<[objectpath:"/TestObjectPath"]>
-  //   "Bytes": Variant<[0x54, 0x65, 0x73, 0x74]>
-  // }
-
-  MessageWriter array_writer(nullptr);
-  MessageWriter dict_entry_writer(nullptr);
-  MessageWriter variant_writer(nullptr);
-  MessageWriter variant_array_writer(nullptr);
-
-  writer->OpenArray("{sv}", &array_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Name");
-  dict_entry_writer.AppendVariantOfString("TestService");
-  array_writer.CloseContainer(&dict_entry_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Version");
-  dict_entry_writer.AppendVariantOfInt16(10);
-  array_writer.CloseContainer(&dict_entry_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Methods");
-  dict_entry_writer.OpenVariant("as", &variant_writer);
-  variant_writer.OpenArray("s", &variant_array_writer);
-  variant_array_writer.AppendString("Echo");
-  variant_array_writer.AppendString("SlowEcho");
-  variant_array_writer.AppendString("AsyncEcho");
-  variant_array_writer.AppendString("BrokenMethod");
-  variant_writer.CloseContainer(&variant_array_writer);
-  dict_entry_writer.CloseContainer(&variant_writer);
-  array_writer.CloseContainer(&dict_entry_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Objects");
-  dict_entry_writer.OpenVariant("ao", &variant_writer);
-  variant_writer.OpenArray("o", &variant_array_writer);
-  variant_array_writer.AppendObjectPath(ObjectPath("/TestObjectPath"));
-  variant_writer.CloseContainer(&variant_array_writer);
-  dict_entry_writer.CloseContainer(&variant_writer);
-  array_writer.CloseContainer(&dict_entry_writer);
-
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Bytes");
-  dict_entry_writer.OpenVariant("ay", &variant_writer);
-  const uint8_t bytes[] = {0x54, 0x65, 0x73, 0x74};
-  variant_writer.AppendArrayOfBytes(bytes, sizeof(bytes));
-  dict_entry_writer.CloseContainer(&variant_writer);
-  array_writer.CloseContainer(&dict_entry_writer);
-
-  writer->CloseContainer(&array_writer);
 }
 
 void TestService::AddObject(const ObjectPath& object_path) {
-  task_runner()->PostTask(FROM_HERE,
-                          base::BindOnce(&TestService::AddObjectInternal,
-                                         base::Unretained(this), object_path));
 }
 
 void TestService::AddObjectInternal(const ObjectPath& object_path) {
-  Signal signal(kObjectManagerInterface, kObjectManagerInterfacesAdded);
-  MessageWriter writer(&signal);
-  writer.AppendObjectPath(object_path);
-
-  MessageWriter array_writer(nullptr);
-  MessageWriter dict_entry_writer(nullptr);
-
-  writer.OpenArray("{sa{sv}}", &array_writer);
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("org.chromium.TestInterface");
-  AddPropertiesToWriter(&dict_entry_writer);
-  array_writer.CloseContainer(&dict_entry_writer);
-  writer.CloseContainer(&array_writer);
-
-  exported_object_manager_->SendSignal(&signal);
 }
 
 void TestService::RemoveObject(const ObjectPath& object_path) {
-  task_runner()->PostTask(FROM_HERE,
-                          base::BindOnce(&TestService::RemoveObjectInternal,
-                                         base::Unretained(this), object_path));
 }
 
 void TestService::RemoveObjectInternal(const ObjectPath& object_path) {
-  Signal signal(kObjectManagerInterface, kObjectManagerInterfacesRemoved);
-  MessageWriter writer(&signal);
-
-  writer.AppendObjectPath(object_path);
-
-  std::vector<std::string> interfaces;
-  interfaces.push_back("org.chromium.TestInterface");
-  writer.AppendArrayOfStrings(interfaces);
-
-  exported_object_manager_->SendSignal(&signal);
 }
 
 void TestService::SendPropertyChangedSignal(const std::string& name) {
-  task_runner()->PostTask(
-      FROM_HERE, base::BindOnce(&TestService::SendPropertyChangedSignalInternal,
-                                base::Unretained(this), name));
 }
 
 void TestService::SendPropertyChangedSignalInternal(const std::string& name) {
-  Signal signal(kPropertiesInterface, kPropertiesChanged);
-  MessageWriter writer(&signal);
-  writer.AppendString("org.chromium.TestInterface");
-
-  MessageWriter array_writer(nullptr);
-  MessageWriter dict_entry_writer(nullptr);
-
-  writer.OpenArray("{sv}", &array_writer);
-  array_writer.OpenDictEntry(&dict_entry_writer);
-  dict_entry_writer.AppendString("Name");
-  dict_entry_writer.AppendVariantOfString(name);
-  array_writer.CloseContainer(&dict_entry_writer);
-  writer.CloseContainer(&array_writer);
-
-  MessageWriter invalidated_array_writer(nullptr);
-
-  writer.OpenArray("s", &invalidated_array_writer);
-  writer.CloseContainer(&invalidated_array_writer);
-
-  exported_object_->SendSignal(&signal);
 }
 
 void TestService::SendPropertyInvalidatedSignal() {
-  task_runner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&TestService::SendPropertyInvalidatedSignalInternal,
-                     base::Unretained(this)));
 }
 
 void TestService::SendPropertyInvalidatedSignalInternal() {
-  Signal signal(kPropertiesInterface, kPropertiesChanged);
-  MessageWriter writer(&signal);
-  writer.AppendString("org.chromium.TestInterface");
-
-  MessageWriter array_writer(nullptr);
-  MessageWriter dict_entry_writer(nullptr);
-
-  writer.OpenArray("{sv}", &array_writer);
-  writer.CloseContainer(&array_writer);
-
-  MessageWriter invalidated_array_writer(nullptr);
-
-  writer.OpenArray("s", &invalidated_array_writer);
-  invalidated_array_writer.AppendString("Name");
-  writer.CloseContainer(&invalidated_array_writer);
-
-  exported_object_->SendSignal(&signal);
 }
 
 }  // namespace dbus
diff -u a/dbus/util_unittest.cc b/dbus/util_unittest.cc
--- a/dbus/util_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/util_unittest.cc	2020-06-09 20:06:19.781285008 +0200
@@ -7,10 +7,4 @@
 
 namespace dbus {
 
-TEST(UtilTest, GetAbsoluteMemberName) {
-  EXPECT_EQ("InterfaceName.MemberName",
-            GetAbsoluteMemberName("InterfaceName", "MemberName"));
-  EXPECT_EQ(".", GetAbsoluteMemberName("", ""));
-}
-
 }  // namespace dbus
diff -u a/dbus/values_util.cc b/dbus/values_util.cc
--- a/dbus/values_util.cc	2020-05-18 20:40:23.000000000 +0200
+++ b/dbus/values_util.cc	2020-06-09 20:09:06.246805426 +0200
@@ -24,285 +24,38 @@
 
 // Pops values from |reader| and appends them to |list_value|.
 bool PopListElements(MessageReader* reader, base::ListValue* list_value) {
-  while (reader->HasMoreData()) {
-    std::unique_ptr<base::Value> element_value = PopDataAsValue(reader);
-    if (!element_value)
-      return false;
-    list_value->Append(std::move(element_value));
-  }
   return true;
 }
 
 // Pops dict-entries from |reader| and sets them to |dictionary_value|
 bool PopDictionaryEntries(MessageReader* reader,
                           base::DictionaryValue* dictionary_value) {
-  while (reader->HasMoreData()) {
-    DCHECK_EQ(Message::DICT_ENTRY, reader->GetDataType());
-    MessageReader entry_reader(nullptr);
-    if (!reader->PopDictEntry(&entry_reader))
-      return false;
-    // Get key as a string.
-    std::string key_string;
-    if (entry_reader.GetDataType() == Message::STRING) {
-      // If the type of keys is STRING, pop it directly.
-      if (!entry_reader.PopString(&key_string))
-        return false;
-    } else {
-      // If the type of keys is not STRING, convert it to string.
-      std::unique_ptr<base::Value> key(PopDataAsValue(&entry_reader));
-      if (!key)
-        return false;
-      // Use JSONWriter to convert an arbitrary value to a string.
-      base::JSONWriter::Write(*key, &key_string);
-    }
-    // Get the value and set the key-value pair.
-    std::unique_ptr<base::Value> value = PopDataAsValue(&entry_reader);
-    if (!value)
-      return false;
-    dictionary_value->SetWithoutPathExpansion(key_string, std::move(value));
-  }
   return true;
 }
 
 // Gets the D-Bus type signature for the value.
 std::string GetTypeSignature(const base::Value& value) {
-  switch (value.type()) {
-    case base::Value::Type::BOOLEAN:
-      return "b";
-    case base::Value::Type::INTEGER:
-      return "i";
-    case base::Value::Type::DOUBLE:
-      return "d";
-    case base::Value::Type::STRING:
-      return "s";
-    case base::Value::Type::BINARY:
-      return "ay";
-    case base::Value::Type::DICTIONARY:
-      return "a{sv}";
-    case base::Value::Type::LIST:
-      return "av";
-    default:
-      DLOG(ERROR) << "Unexpected type " << value.type();
-      return std::string();
-  }
+  return "b";
 }
 
 }  // namespace
 
 std::unique_ptr<base::Value> PopDataAsValue(MessageReader* reader) {
   std::unique_ptr<base::Value> result;
-  switch (reader->GetDataType()) {
-    case Message::INVALID_DATA:
-      // Do nothing.
-      break;
-    case Message::BYTE: {
-      uint8_t value = 0;
-      if (reader->PopByte(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::BOOL: {
-      bool value = false;
-      if (reader->PopBool(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::INT16: {
-      int16_t value = 0;
-      if (reader->PopInt16(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::UINT16: {
-      uint16_t value = 0;
-      if (reader->PopUint16(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::INT32: {
-      int32_t value = 0;
-      if (reader->PopInt32(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::UINT32: {
-      uint32_t value = 0;
-      if (reader->PopUint32(&value)) {
-        result = std::make_unique<base::Value>(static_cast<double>(value));
-      }
-      break;
-    }
-    case Message::INT64: {
-      int64_t value = 0;
-      if (reader->PopInt64(&value)) {
-        DLOG_IF(WARNING, !IsExactlyRepresentableByDouble(value)) <<
-            value << " is not exactly representable by double";
-        result = std::make_unique<base::Value>(static_cast<double>(value));
-      }
-      break;
-    }
-    case Message::UINT64: {
-      uint64_t value = 0;
-      if (reader->PopUint64(&value)) {
-        DLOG_IF(WARNING, !IsExactlyRepresentableByDouble(value)) <<
-            value << " is not exactly representable by double";
-        result = std::make_unique<base::Value>(static_cast<double>(value));
-      }
-      break;
-    }
-    case Message::DOUBLE: {
-      double value = 0;
-      if (reader->PopDouble(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::STRING: {
-      std::string value;
-      if (reader->PopString(&value))
-        result = std::make_unique<base::Value>(value);
-      break;
-    }
-    case Message::OBJECT_PATH: {
-      ObjectPath value;
-      if (reader->PopObjectPath(&value))
-        result = std::make_unique<base::Value>(value.value());
-      break;
-    }
-    case Message::UNIX_FD: {
-      // Cannot distinguish a file descriptor from an int
-      NOTREACHED();
-      break;
-    }
-    case Message::ARRAY: {
-      MessageReader sub_reader(nullptr);
-      if (reader->PopArray(&sub_reader)) {
-        // If the type of the array's element is DICT_ENTRY, create a
-        // DictionaryValue, otherwise create a ListValue.
-        if (sub_reader.GetDataType() == Message::DICT_ENTRY) {
-          std::unique_ptr<base::DictionaryValue> dictionary_value(
-              new base::DictionaryValue);
-          if (PopDictionaryEntries(&sub_reader, dictionary_value.get()))
-            result = std::move(dictionary_value);
-        } else {
-          std::unique_ptr<base::ListValue> list_value(new base::ListValue);
-          if (PopListElements(&sub_reader, list_value.get()))
-            result = std::move(list_value);
-        }
-      }
-      break;
-    }
-    case Message::STRUCT: {
-      MessageReader sub_reader(nullptr);
-      if (reader->PopStruct(&sub_reader)) {
-        std::unique_ptr<base::ListValue> list_value(new base::ListValue);
-        if (PopListElements(&sub_reader, list_value.get()))
-          result = std::move(list_value);
-      }
-      break;
-    }
-    case Message::DICT_ENTRY:
-      // DICT_ENTRY must be popped as an element of an array.
-      NOTREACHED();
-      break;
-    case Message::VARIANT: {
-      MessageReader sub_reader(nullptr);
-      if (reader->PopVariant(&sub_reader))
-        result = PopDataAsValue(&sub_reader);
-      break;
-    }
-  }
   return result;
 }
 
 void AppendBasicTypeValueData(MessageWriter* writer, const base::Value& value) {
-  switch (value.type()) {
-    case base::Value::Type::BOOLEAN: {
-      bool bool_value = false;
-      bool success = value.GetAsBoolean(&bool_value);
-      DCHECK(success);
-      writer->AppendBool(bool_value);
-      break;
-    }
-    case base::Value::Type::INTEGER: {
-      int int_value = 0;
-      bool success = value.GetAsInteger(&int_value);
-      DCHECK(success);
-      writer->AppendInt32(int_value);
-      break;
-    }
-    case base::Value::Type::DOUBLE: {
-      double double_value = 0;
-      bool success = value.GetAsDouble(&double_value);
-      DCHECK(success);
-      writer->AppendDouble(double_value);
-      break;
-    }
-    case base::Value::Type::STRING: {
-      std::string string_value;
-      bool success = value.GetAsString(&string_value);
-      DCHECK(success);
-      writer->AppendString(string_value);
-      break;
-    }
-    default:
-      DLOG(ERROR) << "Unexpected type " << value.type();
-      break;
-  }
 }
 
 void AppendBasicTypeValueDataAsVariant(MessageWriter* writer,
                                        const base::Value& value) {
-  MessageWriter sub_writer(nullptr);
-  writer->OpenVariant(GetTypeSignature(value), &sub_writer);
-  AppendBasicTypeValueData(&sub_writer, value);
-  writer->CloseContainer(&sub_writer);
 }
 
 void AppendValueData(MessageWriter* writer, const base::Value& value) {
-  switch (value.type()) {
-    case base::Value::Type::DICTIONARY: {
-      const base::DictionaryValue* dictionary = nullptr;
-      value.GetAsDictionary(&dictionary);
-      dbus::MessageWriter array_writer(nullptr);
-      writer->OpenArray("{sv}", &array_writer);
-      for (base::DictionaryValue::Iterator iter(*dictionary);
-           !iter.IsAtEnd(); iter.Advance()) {
-        dbus::MessageWriter dict_entry_writer(nullptr);
-        array_writer.OpenDictEntry(&dict_entry_writer);
-        dict_entry_writer.AppendString(iter.key());
-        AppendValueDataAsVariant(&dict_entry_writer, iter.value());
-        array_writer.CloseContainer(&dict_entry_writer);
-      }
-      writer->CloseContainer(&array_writer);
-      break;
-    }
-    case base::Value::Type::LIST: {
-      const base::ListValue* list = nullptr;
-      value.GetAsList(&list);
-      dbus::MessageWriter array_writer(nullptr);
-      writer->OpenArray("v", &array_writer);
-      for (const auto& value : *list) {
-        AppendValueDataAsVariant(&array_writer, value);
-      }
-      writer->CloseContainer(&array_writer);
-      break;
-    }
-    case base::Value::Type::BOOLEAN:
-    case base::Value::Type::INTEGER:
-    case base::Value::Type::DOUBLE:
-    case base::Value::Type::STRING:
-      AppendBasicTypeValueData(writer, value);
-      break;
-    default:
-      DLOG(ERROR) << "Unexpected type: " << value.type();
-  }
 }
 
 void AppendValueDataAsVariant(MessageWriter* writer, const base::Value& value) {
-  MessageWriter variant_writer(nullptr);
-  writer->OpenVariant(GetTypeSignature(value), &variant_writer);
-  AppendValueData(&variant_writer, value);
-  writer->CloseContainer(&variant_writer);
 }
 
 }  // namespace dbus
diff -u a/dbus/values_util_unittest.cc b/dbus/values_util_unittest.cc
--- a/dbus/values_util_unittest.cc	2020-05-18 20:39:20.000000000 +0200
+++ b/dbus/values_util_unittest.cc	2020-06-09 20:07:04.944307352 +0200
@@ -20,668 +20,4 @@
 
 namespace dbus {
 
-TEST(ValuesUtilTest, PopBasicTypes) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append basic type values.
-  MessageWriter writer(response.get());
-  const uint8_t kByteValue = 42;
-  writer.AppendByte(kByteValue);
-  const bool kBoolValue = true;
-  writer.AppendBool(kBoolValue);
-  const int16_t kInt16Value = -43;
-  writer.AppendInt16(kInt16Value);
-  const uint16_t kUint16Value = 44;
-  writer.AppendUint16(kUint16Value);
-  const int32_t kInt32Value = -45;
-  writer.AppendInt32(kInt32Value);
-  const uint32_t kUint32Value = 46;
-  writer.AppendUint32(kUint32Value);
-  const int64_t kInt64Value = -47;
-  writer.AppendInt64(kInt64Value);
-  const uint64_t kUint64Value = 48;
-  writer.AppendUint64(kUint64Value);
-  const double kDoubleValue = 4.9;
-  writer.AppendDouble(kDoubleValue);
-  const std::string kStringValue = "fifty";
-  writer.AppendString(kStringValue);
-  const std::string kEmptyStringValue;
-  writer.AppendString(kEmptyStringValue);
-  const ObjectPath kObjectPathValue("/ObjectPath");
-  writer.AppendObjectPath(kObjectPathValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  std::unique_ptr<base::Value> expected_value;
-  // Pop a byte.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kByteValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a bool.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kBoolValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an int16_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kInt16Value));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a uint16_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kUint16Value));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an int32_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kInt32Value));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a uint32_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(static_cast<double>(kUint32Value)));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an int64_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(static_cast<double>(kInt64Value)));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a uint64_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(static_cast<double>(kUint64Value)));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a double.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kDoubleValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a string.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kStringValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an empty string.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kEmptyStringValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an object path.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kObjectPathValue.value()));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-}
-
-TEST(ValuesUtilTest, PopVariant) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append variant values.
-  MessageWriter writer(response.get());
-  const bool kBoolValue = true;
-  writer.AppendVariantOfBool(kBoolValue);
-  const int32_t kInt32Value = -45;
-  writer.AppendVariantOfInt32(kInt32Value);
-  const double kDoubleValue = 4.9;
-  writer.AppendVariantOfDouble(kDoubleValue);
-  const std::string kStringValue = "fifty";
-  writer.AppendVariantOfString(kStringValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  std::unique_ptr<base::Value> expected_value;
-  // Pop a bool.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kBoolValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop an int32_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kInt32Value));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a double.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kDoubleValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  // Pop a string.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(kStringValue));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-}
-
-// Pop extremely large integers which cannot be precisely represented in
-// double.
-TEST(ValuesUtilTest, PopExtremelyLargeIntegers) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append large integers.
-  MessageWriter writer(response.get());
-  const int64_t kInt64Value = -123456789012345689LL;
-  writer.AppendInt64(kInt64Value);
-  const uint64_t kUint64Value = 9876543210987654321ULL;
-  writer.AppendUint64(kUint64Value);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  std::unique_ptr<base::Value> expected_value;
-  double double_value = 0;
-  // Pop an int64_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(static_cast<double>(kInt64Value)));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  ASSERT_TRUE(value->GetAsDouble(&double_value));
-  EXPECT_NE(kInt64Value, static_cast<int64_t>(double_value));
-  // Pop a uint64_t.
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  expected_value.reset(new base::Value(static_cast<double>(kUint64Value)));
-  EXPECT_TRUE(value->Equals(expected_value.get()));
-  ASSERT_TRUE(value->GetAsDouble(&double_value));
-  EXPECT_NE(kUint64Value, static_cast<uint64_t>(double_value));
-}
-
-TEST(ValuesUtilTest, PopIntArray) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append an int32_t array.
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  std::vector<int32_t> data;
-  data.push_back(0);
-  data.push_back(1);
-  data.push_back(2);
-  writer.OpenArray("i", &sub_writer);
-  for (size_t i = 0; i != data.size(); ++i)
-    sub_writer.AppendInt32(data[i]);
-  writer.CloseContainer(&sub_writer);
-
-  // Create the expected value.
-  std::unique_ptr<base::ListValue> list_value(new base::ListValue);
-  for (size_t i = 0; i != data.size(); ++i)
-    list_value->AppendInteger(data[i]);
-
-  // Pop an int32_t array.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(list_value.get()));
-}
-
-TEST(ValuesUtilTest, PopStringArray) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append a string array.
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  std::vector<std::string> data;
-  data.push_back("Dreamlifter");
-  data.push_back("Beluga");
-  data.push_back("Mriya");
-  writer.AppendArrayOfStrings(data);
-
-  // Create the expected value.
-  std::unique_ptr<base::ListValue> list_value(new base::ListValue);
-  for (size_t i = 0; i != data.size(); ++i)
-    list_value->AppendString(data[i]);
-
-  // Pop a string array.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(list_value.get()));
-}
-
-TEST(ValuesUtilTest, PopStruct) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append a struct.
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  writer.OpenStruct(&sub_writer);
-  const bool kBoolValue = true;
-  sub_writer.AppendBool(kBoolValue);
-  const int32_t kInt32Value = -123;
-  sub_writer.AppendInt32(kInt32Value);
-  const double kDoubleValue = 1.23;
-  sub_writer.AppendDouble(kDoubleValue);
-  const std::string kStringValue = "one two three";
-  sub_writer.AppendString(kStringValue);
-  writer.CloseContainer(&sub_writer);
-
-  // Create the expected value.
-  base::ListValue list_value;
-  list_value.AppendBoolean(kBoolValue);
-  list_value.AppendInteger(kInt32Value);
-  list_value.AppendDouble(kDoubleValue);
-  list_value.AppendString(kStringValue);
-
-  // Pop a struct.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&list_value));
-}
-
-TEST(ValuesUtilTest, PopStringToVariantDictionary) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append a dictionary.
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  MessageWriter entry_writer(nullptr);
-  writer.OpenArray("{sv}", &sub_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey1 = "one";
-  entry_writer.AppendString(kKey1);
-  const bool kBoolValue = true;
-  entry_writer.AppendVariantOfBool(kBoolValue);
-  sub_writer.CloseContainer(&entry_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey2 = "two";
-  entry_writer.AppendString(kKey2);
-  const int32_t kInt32Value = -45;
-  entry_writer.AppendVariantOfInt32(kInt32Value);
-  sub_writer.CloseContainer(&entry_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey3 = "three";
-  entry_writer.AppendString(kKey3);
-  const double kDoubleValue = 4.9;
-  entry_writer.AppendVariantOfDouble(kDoubleValue);
-  sub_writer.CloseContainer(&entry_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey4 = "four";
-  entry_writer.AppendString(kKey4);
-  const std::string kStringValue = "fifty";
-  entry_writer.AppendVariantOfString(kStringValue);
-  sub_writer.CloseContainer(&entry_writer);
-  writer.CloseContainer(&sub_writer);
-
-  // Create the expected value.
-  base::DictionaryValue dictionary_value;
-  dictionary_value.SetBoolean(kKey1, kBoolValue);
-  dictionary_value.SetInteger(kKey2, kInt32Value);
-  dictionary_value.SetDouble(kKey3, kDoubleValue);
-  dictionary_value.SetString(kKey4, kStringValue);
-
-  // Pop a dictinoary.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&dictionary_value));
-}
-
-TEST(ValuesUtilTest, PopDictionaryWithDottedStringKey) {
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  // Append a dictionary.
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  MessageWriter entry_writer(nullptr);
-  writer.OpenArray("{sv}", &sub_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey1 = "www.example.com";  // String including dots.
-  entry_writer.AppendString(kKey1);
-  const bool kBoolValue = true;
-  entry_writer.AppendVariantOfBool(kBoolValue);
-  sub_writer.CloseContainer(&entry_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey2 = ".example";  // String starting with a dot.
-  entry_writer.AppendString(kKey2);
-  const int32_t kInt32Value = -45;
-  entry_writer.AppendVariantOfInt32(kInt32Value);
-  sub_writer.CloseContainer(&entry_writer);
-  sub_writer.OpenDictEntry(&entry_writer);
-  const std::string kKey3 = "example.";  // String ending with a dot.
-  entry_writer.AppendString(kKey3);
-  const double kDoubleValue = 4.9;
-  entry_writer.AppendVariantOfDouble(kDoubleValue);
-  sub_writer.CloseContainer(&entry_writer);
-  writer.CloseContainer(&sub_writer);
-
-  // Create the expected value.
-  base::DictionaryValue dictionary_value;
-  dictionary_value.SetKey(kKey1, base::Value(kBoolValue));
-  dictionary_value.SetKey(kKey2, base::Value(kInt32Value));
-  dictionary_value.SetKey(kKey3, base::Value(kDoubleValue));
-
-  // Pop a dictinoary.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&dictionary_value));
-}
-
-TEST(ValuesUtilTest, PopDoubleToIntDictionary) {
-  // Create test data.
-  const int32_t kValues[] = {0, 1, 1, 2, 3, 5, 8, 13, 21};
-  const std::vector<int32_t> values(kValues, kValues + base::size(kValues));
-  std::vector<double> keys(values.size());
-  for (size_t i = 0; i != values.size(); ++i)
-    keys[i] = std::sqrt(values[i]);
-
-  // Append a dictionary.
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  MessageWriter sub_writer(nullptr);
-  writer.OpenArray("{di}", &sub_writer);
-  for (size_t i = 0; i != values.size(); ++i) {
-    MessageWriter entry_writer(nullptr);
-    sub_writer.OpenDictEntry(&entry_writer);
-    entry_writer.AppendDouble(keys[i]);
-    entry_writer.AppendInt32(values[i]);
-    sub_writer.CloseContainer(&entry_writer);
-  }
-  writer.CloseContainer(&sub_writer);
-
-  // Create the expected value.
-  base::DictionaryValue dictionary_value;
-  for (size_t i = 0; i != values.size(); ++i) {
-    std::string key_string;
-    base::JSONWriter::Write(base::Value(keys[i]), &key_string);
-    dictionary_value.SetKey(key_string, base::Value(values[i]));
-  }
-
-  // Pop a dictionary.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value(PopDataAsValue(&reader));
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&dictionary_value));
-}
-
-TEST(ValuesUtilTest, AppendBasicTypes) {
-  const base::Value kBoolValue(false);
-  const base::Value kIntegerValue(42);
-  const base::Value kDoubleValue(4.2);
-  const base::Value kStringValue("string");
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendBasicTypeValueData(&writer, kBoolValue);
-  AppendBasicTypeValueData(&writer, kIntegerValue);
-  AppendBasicTypeValueData(&writer, kDoubleValue);
-  AppendBasicTypeValueData(&writer, kStringValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kBoolValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kIntegerValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kDoubleValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kStringValue));
-}
-
-TEST(ValuesUtilTest, AppendBasicTypesAsVariant) {
-  const base::Value kBoolValue(false);
-  const base::Value kIntegerValue(42);
-  const base::Value kDoubleValue(4.2);
-  const base::Value kStringValue("string");
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendBasicTypeValueDataAsVariant(&writer, kBoolValue);
-  AppendBasicTypeValueDataAsVariant(&writer, kIntegerValue);
-  AppendBasicTypeValueDataAsVariant(&writer, kDoubleValue);
-  AppendBasicTypeValueDataAsVariant(&writer, kStringValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kBoolValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kIntegerValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kDoubleValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kStringValue));
-}
-
-TEST(ValuesUtilTest, AppendValueDataBasicTypes) {
-  const base::Value kBoolValue(false);
-  const base::Value kIntegerValue(42);
-  const base::Value kDoubleValue(4.2);
-  const base::Value kStringValue("string");
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueData(&writer, kBoolValue);
-  AppendValueData(&writer, kIntegerValue);
-  AppendValueData(&writer, kDoubleValue);
-  AppendValueData(&writer, kStringValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kBoolValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kIntegerValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kDoubleValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kStringValue));
-}
-
-TEST(ValuesUtilTest, AppendValueDataAsVariantBasicTypes) {
-  const base::Value kBoolValue(false);
-  const base::Value kIntegerValue(42);
-  const base::Value kDoubleValue(4.2);
-  const base::Value kStringValue("string");
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueDataAsVariant(&writer, kBoolValue);
-  AppendValueDataAsVariant(&writer, kIntegerValue);
-  AppendValueDataAsVariant(&writer, kDoubleValue);
-  AppendValueDataAsVariant(&writer, kStringValue);
-
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kBoolValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kIntegerValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kDoubleValue));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&kStringValue));
-}
-
-TEST(ValuesUtilTest, AppendDictionary) {
-  // Set up the input dictionary.
-  const std::string kKey1 = "one";
-  const std::string kKey2 = "two";
-  const std::string kKey3 = "three";
-  const std::string kKey4 = "four";
-  const std::string kKey5 = "five";
-  const std::string kKey6 = "six";
-
-  const bool kBoolValue = true;
-  const int32_t kInt32Value = -45;
-  const double kDoubleValue = 4.9;
-  const std::string kStringValue = "fifty";
-
-  auto list_value = std::make_unique<base::ListValue>();
-  list_value->AppendBoolean(kBoolValue);
-  list_value->AppendInteger(kInt32Value);
-
-  auto dictionary_value = std::make_unique<base::DictionaryValue>();
-  dictionary_value->SetBoolean(kKey1, kBoolValue);
-  dictionary_value->SetInteger(kKey2, kDoubleValue);
-
-  base::DictionaryValue test_dictionary;
-  test_dictionary.SetBoolean(kKey1, kBoolValue);
-  test_dictionary.SetInteger(kKey2, kInt32Value);
-  test_dictionary.SetDouble(kKey3, kDoubleValue);
-  test_dictionary.SetString(kKey4, kStringValue);
-  test_dictionary.Set(kKey5, std::move(list_value));
-  test_dictionary.Set(kKey6, std::move(dictionary_value));
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueData(&writer, test_dictionary);
-  base::Value int_value(kInt32Value);
-  AppendValueData(&writer, int_value);
-
-  // Read the data.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&test_dictionary));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&int_value));
-}
-
-TEST(ValuesUtilTest, AppendDictionaryAsVariant) {
-  // Set up the input dictionary.
-  const std::string kKey1 = "one";
-  const std::string kKey2 = "two";
-  const std::string kKey3 = "three";
-  const std::string kKey4 = "four";
-  const std::string kKey5 = "five";
-  const std::string kKey6 = "six";
-
-  const bool kBoolValue = true;
-  const int32_t kInt32Value = -45;
-  const double kDoubleValue = 4.9;
-  const std::string kStringValue = "fifty";
-
-  auto list_value = std::make_unique<base::ListValue>();
-  list_value->AppendBoolean(kBoolValue);
-  list_value->AppendInteger(kInt32Value);
-
-  auto dictionary_value = std::make_unique<base::DictionaryValue>();
-  dictionary_value->SetBoolean(kKey1, kBoolValue);
-  dictionary_value->SetInteger(kKey2, kDoubleValue);
-
-  base::DictionaryValue test_dictionary;
-  test_dictionary.SetBoolean(kKey1, kBoolValue);
-  test_dictionary.SetInteger(kKey2, kInt32Value);
-  test_dictionary.SetDouble(kKey3, kDoubleValue);
-  test_dictionary.SetString(kKey4, kStringValue);
-  test_dictionary.Set(kKey5, std::move(list_value));
-  test_dictionary.Set(kKey6, std::move(dictionary_value));
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueDataAsVariant(&writer, test_dictionary);
-  base::Value int_value(kInt32Value);
-  AppendValueData(&writer, int_value);
-
-  // Read the data.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&test_dictionary));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&int_value));
-}
-
-TEST(ValuesUtilTest, AppendList) {
-  // Set up the input list.
-  const std::string kKey1 = "one";
-  const std::string kKey2 = "two";
-
-  const bool kBoolValue = true;
-  const int32_t kInt32Value = -45;
-  const double kDoubleValue = 4.9;
-  const std::string kStringValue = "fifty";
-
-  std::unique_ptr<base::ListValue> list_value(new base::ListValue());
-  list_value->AppendBoolean(kBoolValue);
-  list_value->AppendInteger(kInt32Value);
-
-  std::unique_ptr<base::DictionaryValue> dictionary_value(
-      new base::DictionaryValue());
-  dictionary_value->SetBoolean(kKey1, kBoolValue);
-  dictionary_value->SetInteger(kKey2, kDoubleValue);
-
-  base::ListValue test_list;
-  test_list.AppendBoolean(kBoolValue);
-  test_list.AppendInteger(kInt32Value);
-  test_list.AppendDouble(kDoubleValue);
-  test_list.AppendString(kStringValue);
-  test_list.Append(std::move(list_value));
-  test_list.Append(std::move(dictionary_value));
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueData(&writer, test_list);
-  base::Value int_value(kInt32Value);
-  AppendValueData(&writer, int_value);
-
-  // Read the data.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&test_list));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&int_value));
-}
-
-TEST(ValuesUtilTest, AppendListAsVariant) {
-  // Set up the input list.
-  const std::string kKey1 = "one";
-  const std::string kKey2 = "two";
-
-  const bool kBoolValue = true;
-  const int32_t kInt32Value = -45;
-  const double kDoubleValue = 4.9;
-  const std::string kStringValue = "fifty";
-
-  std::unique_ptr<base::ListValue> list_value(new base::ListValue());
-  list_value->AppendBoolean(kBoolValue);
-  list_value->AppendInteger(kInt32Value);
-
-  std::unique_ptr<base::DictionaryValue> dictionary_value(
-      new base::DictionaryValue());
-  dictionary_value->SetBoolean(kKey1, kBoolValue);
-  dictionary_value->SetInteger(kKey2, kDoubleValue);
-
-  base::ListValue test_list;
-  test_list.AppendBoolean(kBoolValue);
-  test_list.AppendInteger(kInt32Value);
-  test_list.AppendDouble(kDoubleValue);
-  test_list.AppendString(kStringValue);
-  test_list.Append(std::move(list_value));
-  test_list.Append(std::move(dictionary_value));
-
-  std::unique_ptr<Response> response(Response::CreateEmpty());
-  MessageWriter writer(response.get());
-  AppendValueDataAsVariant(&writer, test_list);
-  base::Value int_value(kInt32Value);
-  AppendValueData(&writer, int_value);
-
-  // Read the data.
-  MessageReader reader(response.get());
-  std::unique_ptr<base::Value> value;
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&test_list));
-  value = PopDataAsValue(&reader);
-  ASSERT_NE(nullptr, value);
-  EXPECT_TRUE(value->Equals(&int_value));
-}
-
 }  // namespace dbus
